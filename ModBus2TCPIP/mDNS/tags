!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	DNSDigest.c	/^	mDNSu32 A,B,C,D;$/;"	m	struct:MD5state_st	file:
ANSWER_REMOTE_HOSTNAME_QUERIES	mDNSDebug.h	192;"	d
ARD_AsNumber	mDNS.c	9471;"	d	file:
ARDisplayString	mDNSEmbeddedAPI.h	3105;"	d
ARListElem	mDNSEmbeddedAPI.h	/^	} ARListElem;$/;"	t	typeref:struct:ARListElem
ARListElem	mDNSEmbeddedAPI.h	/^typedef struct ARListElem$/;"	s
ASSIGNLINK	GenLinkedList.c	45;"	d	file:
AbsoluteMaxDNSMessageData	mDNSEmbeddedAPI.h	1385;"	d
AccelerateThisQuery	mDNS.c	/^mDNSlocal mDNSBool AccelerateThisQuery(mDNS *const m, DNSQuestion *q)$/;"	f
AcknowledgeRecord	mDNS.c	/^mDNSlocal void AcknowledgeRecord(mDNS *const m, AuthRecord *const rr)$/;"	f
Acknowledged	mDNSEmbeddedAPI.h	/^	mDNSu8          Acknowledged;		\/\/ Set if we've given the success callback to the client$/;"	m	struct:AuthRecord_struct
ActivateUnicastQuery	mDNS.c	/^mDNSlocal void ActivateUnicastQuery(mDNS *const m, DNSQuestion *const question, mDNSBool ScheduleImmediately)$/;"	f
ActivateUnicastRegistration	mDNS.c	/^mDNSlocal void ActivateUnicastRegistration(mDNS *const m, AuthRecord *const rr)$/;"	f
ActiveQuestion	mDNS.c	1582;"	d	file:
ActivityStat	NetMonitor.c	/^typedef struct ActivityStat_struct ActivityStat;$/;"	t	typeref:struct:ActivityStat_struct	file:
ActivityStat_struct	NetMonitor.c	/^struct ActivityStat_struct$/;"	s	file:
AddAdditionalsToResponseList	mDNS.c	/^mDNSlocal void AddAdditionalsToResponseList(mDNS *const m, AuthRecord *ResponseRecords, AuthRecord ***nrpp, const mDNSInterfaceID InterfaceID)$/;"	f
AddHost	NetMonitor.c	/^mDNSlocal HostEntry *AddHost(const mDNSAddr *addr, HostList *list)$/;"	f
AddRecordToResponseList	mDNS.c	/^mDNSlocal void AddRecordToResponseList(AuthRecord ***nrpp, AuthRecord *rr, AuthRecord *add)$/;"	f
AddToHead	GenLinkedList.c	/^void		AddToHead( GenLinkedList *pList, void *elem)$/;"	f
AddToTail	GenLinkedList.c	/^void		AddToTail( GenLinkedList *pList, void *elem)$/;"	f
Additional1	mDNSEmbeddedAPI.h	/^	AuthRecord     *Additional1;		\/\/ Recommended additional record to include in response (e.g. SRV for PTR record)$/;"	m	struct:AuthRecord_struct
Additional2	mDNSEmbeddedAPI.h	/^	AuthRecord     *Additional2;		\/\/ Another additional (e.g. TXT for PTR record)$/;"	m	struct:AuthRecord_struct
Addr	mDNSEmbeddedAPI.h	/^	mDNSAddr          Addr;$/;"	m	struct:tcpInfo_t
Addr	mDNSEmbeddedAPI.h	/^	mDNSAddr         Addr;				\/\/ Discovered result: Address of Target host from SRV record$/;"	m	struct:ZoneData_struct
Address	mDNSEmbeddedAPI.h	/^	mDNSAddr          Address;			\/\/ router address$/;"	m	struct:tcpLNTInfo_struct
AddressIsLocalSubnet	mDNS.c	/^mDNSlocal mDNSBool AddressIsLocalSubnet(mDNS *const m, const mDNSInterfaceID InterfaceID, const mDNSAddr *addr)$/;"	f
AddressMatchesFilterList	NetMonitor.c	/^mDNSlocal mDNSBool AddressMatchesFilterList(const mDNSAddr *srcaddr)$/;"	f
AddressProxy	mDNSEmbeddedAPI.h	/^	mDNSAddr        AddressProxy;		\/\/ For reverse-mapping Sleep Proxy PTR records, address in question$/;"	m	struct:AuthRecord_struct
Advertise	mDNSEmbeddedAPI.h	/^	mDNSu8          Advertise;			\/\/ False if you are only searching on this interface$/;"	m	struct:NetworkInterfaceInfo_struct
AdvertiseHostname	uDNS.c	/^mDNSlocal void AdvertiseHostname(mDNS *m, HostnameInfo *h)$/;"	f
AdvertiseInterface	mDNS.c	/^mDNSlocal void AdvertiseInterface(mDNS *const m, NetworkInterfaceInfo *set)$/;"	f
AdvertiseLocalAddresses	mDNSEmbeddedAPI.h	/^	mDNSBool AdvertiseLocalAddresses;$/;"	m	struct:mDNS_struct
AdvertisedV4	mDNSEmbeddedAPI.h	/^	mDNSAddr          AdvertisedV4;         \/\/ IPv4 address pointed to by hostname$/;"	m	struct:mDNS_struct
AdvertisedV6	mDNSEmbeddedAPI.h	/^	mDNSAddr          AdvertisedV6;         \/\/ IPv6 address pointed to by hostname$/;"	m	struct:mDNS_struct
AllDNSAdminGroup	DNSCommon.c	/^mDNSexport const mDNSv4Addr AllDNSAdminGroup   = { { 239, 255, 255, 251 } };$/;"	v
AllDNSLinkGroup_v4	DNSCommon.c	/^mDNSexport const mDNSAddr   AllDNSLinkGroup_v4 = { mDNSAddrType_IPv4, { { { 224,   0,   0, 251 } } } };$/;"	v
AllDNSLinkGroup_v6	DNSCommon.c	/^mDNSexport const mDNSAddr   AllDNSLinkGroup_v6 = { mDNSAddrType_IPv6, { { { 0xFF,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0xFB } } } };$/;"	v
AllSystemsMcast	DNSCommon.c	/^mDNSexport const mDNSv4Addr AllSystemsMcast    = { { 224,   0,   0,   1 } }; \/\/ For NAT-PMP Annoucements$/;"	v
AllowRemoteQuery	mDNSEmbeddedAPI.h	/^	mDNSu8          AllowRemoteQuery;	\/\/ Set if we allow hosts not on the local link to query this record$/;"	m	struct:AuthRecord_struct
AllowedRRSpace	DNSCommon.h	334;"	d
AnalyseHost	NetMonitor.c	/^mDNSlocal void AnalyseHost(mDNS *const m, HostEntry *entry, const mDNSInterfaceID InterfaceID)$/;"	f
AnnounceCount	mDNSEmbeddedAPI.h	/^	mDNSu8          AnnounceCount;		\/\/ Number of announcements remaining (kDNSRecordTypeShared)$/;"	m	struct:AuthRecord_struct
AnnounceOwner	mDNSEmbeddedAPI.h	/^	mDNSs32  AnnounceOwner;				\/\/ After waking from sleep, include OWNER option in packets until this time$/;"	m	struct:mDNS_struct
AnswerAllLocalQuestionsWithLocalAuthRecord	mDNS.c	/^mDNSlocal void AnswerAllLocalQuestionsWithLocalAuthRecord(mDNS *const m, AuthRecord *rr, QC_result AddRecord)$/;"	f
AnswerCurrentQuestionWithResourceRecord	mDNS.c	/^mDNSexport void AnswerCurrentQuestionWithResourceRecord(mDNS *const m, CacheRecord *const rr, const QC_result AddRecord)$/;"	f
AnswerLocalQuestionWithLocalAuthRecord	mDNS.c	/^mDNSlocal void AnswerLocalQuestionWithLocalAuthRecord(mDNS *const m, DNSQuestion *q, AuthRecord *rr, QC_result AddRecord)$/;"	f
AnswerNewLocalOnlyQuestion	mDNS.c	/^mDNSlocal void AnswerNewLocalOnlyQuestion(mDNS *const m)$/;"	f
AnswerNewQuestion	mDNS.c	/^mDNSlocal void AnswerNewQuestion(mDNS *const m)$/;"	f
AnsweredLocalQ	mDNSEmbeddedAPI.h	/^	mDNSu8          AnsweredLocalQ;		\/\/ Set if this AuthRecord has been delivered to any local question (LocalOnly or mDNSInterface_Any)$/;"	m	struct:AuthRecord_struct
Answers	mDNSEmbeddedAPI.h	/^	mDNSu32                       Answers;$/;"	m	struct:ServiceInfoQuery_struct
AnyTypeRecordAnswersQuestion	DNSCommon.c	/^mDNSexport mDNSBool AnyTypeRecordAnswersQuestion(const ResourceRecord *const rr, const DNSQuestion *const q)$/;"	f
AppendDNSNameString	DNSCommon.c	/^mDNSexport mDNSu8 *AppendDNSNameString(domainname *const name, const char *cstring)$/;"	f
AppendDomainLabel	DNSCommon.c	/^mDNSexport mDNSu8 *AppendDomainLabel(domainname *const name, const domainlabel *const label)$/;"	f
AppendDomainName	DNSCommon.c	/^mDNSexport mDNSu8 *AppendDomainName(domainname *const name, const domainname *const append)$/;"	f
AppendLabelSuffix	DNSCommon.c	/^mDNSexport void AppendLabelSuffix(domainlabel *const name, mDNSu32 val, const mDNSBool RichText)$/;"	f
AppendLiteralLabelString	DNSCommon.c	/^mDNSexport mDNSu8 *AppendLiteralLabelString(domainname *const name, const char *cstr)$/;"	f
AssignDomainName	mDNSEmbeddedAPI.h	3017;"	d
AssignOffsetLink	GenLinkedList.c	/^static void	AssignOffsetLink( void *elem, void *link, size_t linkOffset)$/;"	f	file:
AuthInfo	mDNSEmbeddedAPI.h	/^	DomainAuthInfo       *AuthInfo;			\/\/ Non-NULL if query is currently being done using Private DNS$/;"	m	struct:DNSQuestion_struct
AuthInfoList	mDNSEmbeddedAPI.h	/^	DomainAuthInfo   *AuthInfoList;         \/\/ list of domains requiring authentication for updates$/;"	m	struct:mDNS_struct
AuthRecord	mDNSEmbeddedAPI.h	/^typedef struct AuthRecord_struct AuthRecord;$/;"	t	typeref:struct:AuthRecord_struct
AuthRecord_struct	mDNSEmbeddedAPI.h	/^struct AuthRecord_struct$/;"	s
AuthRecord_uDNS	mDNSEmbeddedAPI.h	2061;"	d
AuthRecs	mDNSEmbeddedAPI.h	/^	ARListElem *AuthRecs;$/;"	m	struct:SearchListElem
AutoTarget	mDNSEmbeddedAPI.h	/^	mDNSu8          AutoTarget;			\/\/ Set if the target of this record (PTR, CNAME, SRV, etc.) is our host name$/;"	m	struct:AuthRecord_struct
AutoTunnel	mDNSEmbeddedAPI.h	/^	mDNSBool         AutoTunnel;$/;"	m	struct:DomainAuthInfo
AutoTunnelDeviceInfo	mDNSEmbeddedAPI.h	/^	AuthRecord       AutoTunnelDeviceInfo;	\/\/ Device info of tunnel endpoint$/;"	m	struct:DomainAuthInfo
AutoTunnelHostAddr	mDNSEmbeddedAPI.h	/^	mDNSv6Addr        AutoTunnelHostAddr;	\/\/ IPv6 address advertised for AutoTunnel services on this machine$/;"	m	struct:mDNS_struct
AutoTunnelHostAddrActive	mDNSEmbeddedAPI.h	/^	mDNSBool          AutoTunnelHostAddrActive;$/;"	m	struct:mDNS_struct
AutoTunnelHostRecord	mDNSEmbeddedAPI.h	/^	AuthRecord       AutoTunnelHostRecord;	\/\/ User-visible hostname; used as SRV target for AutoTunnel services$/;"	m	struct:DomainAuthInfo
AutoTunnelLabel	mDNSEmbeddedAPI.h	/^	domainlabel       AutoTunnelLabel;		\/\/ Used to construct hostname for *IPv4* address of tunnel endpoints$/;"	m	struct:mDNS_struct
AutoTunnelNAT	mDNSEmbeddedAPI.h	/^	NATTraversalInfo AutoTunnelNAT;$/;"	m	struct:DomainAuthInfo
AutoTunnelService	mDNSEmbeddedAPI.h	/^	AuthRecord       AutoTunnelService;		\/\/ Service record (possibly NAT-Mapped) of IKE daemon implementing tunnel endpoint$/;"	m	struct:DomainAuthInfo
AutoTunnelTarget	mDNSEmbeddedAPI.h	/^	AuthRecord       AutoTunnelTarget;		\/\/ Opaque hostname of tunnel endpoint; used as SRV target for AutoTunnelService record$/;"	m	struct:DomainAuthInfo
AutoTunnelUnregistered	mDNSEmbeddedAPI.h	2286;"	d
AutomaticBrowseDomainQ	mDNSEmbeddedAPI.h	/^	DNSQuestion       AutomaticBrowseDomainQ;$/;"	m	struct:mDNS_struct
AutomaticBrowseQ	mDNSEmbeddedAPI.h	/^	DNSQuestion AutomaticBrowseQ;$/;"	m	struct:SearchListElem
B	DNSDigest.c	/^	mDNSu32 A,B,C,D;$/;"	m	struct:MD5state_st	file:
BE_FETCH32	DNSDigest.c	554;"	d	file:
BIND_8_COMPAT	nss_mdns.c	87;"	d	file:
BackLinkOffset	GenLinkedList.h	/^				BackLinkOffset;$/;"	m	struct:GenDoubleLinkedList
Base64	DNSDigest.c	/^static const char Base64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/";$/;"	v	file:
BeginSleepProcessing	mDNS.c	/^mDNSlocal void BeginSleepProcessing(mDNS *const m)$/;"	f
BetterMatchForName	mDNS.c	/^mDNSlocal int BetterMatchForName(const domainname *name, int namecount, const domainname *newname, int newcount,$/;"	f
BrowseCallback	Client.c	/^static void BrowseCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f	file:
BrowseQ	mDNSEmbeddedAPI.h	/^	DNSQuestion BrowseQ;$/;"	m	struct:SearchListElem
BuildQuestion	mDNS.c	/^mDNSlocal mDNSBool BuildQuestion(mDNS *const m, DNSMessage *query, mDNSu8 **queryptr, DNSQuestion *q,$/;"	f
C	DNSDigest.c	/^	mDNSu32 A,B,C,D;$/;"	m	struct:MD5state_st	file:
CACHE_HASH_SLOTS	mDNSEmbeddedAPI.h	2536;"	d
CMP_DNS_SUFFIX_BAD_DOMAIN	nss_mdns.c	/^	CMP_DNS_SUFFIX_BAD_DOMAIN = -2$/;"	e	enum:__anon10	file:
CMP_DNS_SUFFIX_BAD_NAME	nss_mdns.c	/^	CMP_DNS_SUFFIX_BAD_NAME = 1,$/;"	e	enum:__anon10	file:
CMP_DNS_SUFFIX_FAILURE	nss_mdns.c	/^	CMP_DNS_SUFFIX_FAILURE = 0,$/;"	e	enum:__anon10	file:
CMP_DNS_SUFFIX_SUCCESS	nss_mdns.c	/^	CMP_DNS_SUFFIX_SUCCESS = 1,$/;"	e	enum:__anon10	file:
CNAMEReferrals	mDNSEmbeddedAPI.h	/^	mDNSu32               CNAMEReferrals;	\/\/ Count of how many CNAME redirections we've done$/;"	m	struct:DNSQuestion_struct
CONFIG_FILE	PosixDaemon.c	106;"	d	file:
CONF_LINE_SIZE	nss_mdns.c	1688;"	d	file:
CRActiveQuestion	mDNSEmbeddedAPI.h	/^	DNSQuestion    *CRActiveQuestion;	\/\/ Points to an active question referencing this answer$/;"	m	struct:CacheRecord_struct
CRDisplayString	mDNSEmbeddedAPI.h	3106;"	d
CacheCheckGracePeriod	mDNS.c	3114;"	d	file:
CacheEntity	mDNSEmbeddedAPI.h	/^typedef union CacheEntity_union CacheEntity;$/;"	t	typeref:union:CacheEntity_union
CacheEntity_union	mDNSEmbeddedAPI.h	/^union CacheEntity_union { CacheEntity *next; CacheGroup cg; CacheRecord cr; };$/;"	u
CacheGroup	mDNSEmbeddedAPI.h	/^typedef struct CacheGroup_struct CacheGroup;$/;"	t	typeref:struct:CacheGroup_struct
CacheGroupForName	mDNS.c	/^mDNSexport CacheGroup *CacheGroupForName(const mDNS *const m, const mDNSu32 slot, const mDNSu32 namehash, const domainname *const name)$/;"	f
CacheGroupForRecord	mDNS.c	/^mDNSlocal CacheGroup *CacheGroupForRecord(const mDNS *const m, const mDNSu32 slot, const ResourceRecord *const rr)$/;"	f
CacheGroup_struct	mDNSEmbeddedAPI.h	/^struct CacheGroup_struct				\/\/ Header object for a list of CacheRecords with the same name$/;"	s
CacheHasAddressTypeForName	mDNS.c	/^mDNSlocal const CacheRecord *CacheHasAddressTypeForName(mDNS *const m, const domainname *const name, const mDNSu32 namehash)$/;"	f
CacheRecord	mDNSEmbeddedAPI.h	/^typedef struct CacheRecord_struct CacheRecord;$/;"	t	typeref:struct:CacheRecord_struct
CacheRecordAdd	mDNS.c	/^mDNSlocal void CacheRecordAdd(mDNS *const m, CacheRecord *rr)$/;"	f
CacheRecordDeferredAdd	mDNS.c	/^mDNSlocal void CacheRecordDeferredAdd(mDNS *const m, CacheRecord *rr)$/;"	f
CacheRecordRmv	mDNS.c	/^mDNSlocal void CacheRecordRmv(mDNS *const m, CacheRecord *rr)$/;"	f
CacheRecord_struct	mDNSEmbeddedAPI.h	/^struct CacheRecord_struct$/;"	s
Callback	mDNSPosix.c	/^	mDNSPosixEventCallback		Callback;$/;"	m	struct:PosixEventSource	file:
CanReceiveUnicastOn5353	mDNSEmbeddedAPI.h	/^	mDNSBool CanReceiveUnicastOn5353;$/;"	m	struct:mDNS_struct
CancelGetZoneData	mDNS.c	/^mDNSexport void CancelGetZoneData(mDNS *const m, ZoneData *nta)$/;"	f
CheckCacheExpiration	mDNS.c	/^mDNSlocal void CheckCacheExpiration(mDNS *const m, CacheGroup *const cg)$/;"	f
CheckDNSServerPenalties	uDNS.c	/^mDNSlocal mDNSs32 CheckDNSServerPenalties(mDNS *m)$/;"	f
CheckForSoonToExpireRecords	mDNS.c	/^mDNSlocal mDNSs32 CheckForSoonToExpireRecords(mDNS *const m, const domainname *const name, const mDNSu32 namehash, const mDNSu32 slot)$/;"	f
CheckNATMappings	uDNS.c	/^mDNSlocal void CheckNATMappings(mDNS *m)$/;"	f
CheckProxyRecords	mDNS.c	/^mDNSlocal void CheckProxyRecords(mDNS *const m, AuthRecord *list)$/;"	f
CheckRecordRegistrations	uDNS.c	/^mDNSlocal mDNSs32 CheckRecordRegistrations(mDNS *m)$/;"	f
CheckServiceRegistrations	uDNS.c	/^mDNSlocal mDNSs32 CheckServiceRegistrations(mDNS *m)$/;"	f
CheckThatPortNumberIsUsable	Responder.c	/^static mDNSBool CheckThatPortNumberIsUsable(long portNumber, mDNSBool printExplanation)$/;"	f	file:
CheckThatRichTextNameIsUsable	Responder.c	/^static mDNSBool CheckThatRichTextNameIsUsable(const char *richTextName, mDNSBool printExplanation)$/;"	f	file:
CheckThatServiceTypeIsUsable	Client.c	/^static mDNSBool CheckThatServiceTypeIsUsable(const char *serviceType, mDNSBool printExplanation)$/;"	f	file:
CheckThatServiceTypeIsUsable	Responder.c	/^static mDNSBool CheckThatServiceTypeIsUsable(const char *serviceType, mDNSBool printExplanation)$/;"	f	file:
ChildName	mDNSEmbeddedAPI.h	/^	domainname       ChildName;			\/\/ Name for which we're trying to find the responsible server$/;"	m	struct:ZoneData_struct
ClearInterfaceList	mDNSPosix.c	/^mDNSlocal void ClearInterfaceList(mDNS *const m)$/;"	f
ClearProxyRecords	mDNS.c	/^mDNSlocal void ClearProxyRecords(mDNS *const m, const OwnerOptData *const owner, AuthRecord *const thelist)$/;"	f
ClientCallbackDeferred	mDNSEmbeddedAPI.h	/^	mDNSBool          ClientCallbackDeferred;	\/\/ invoke client callback on completion of pending operation(s)$/;"	m	struct:ServiceRecordSet_struct
ClientID	mDNSEmbeddedAPI.h	/^	mDNSu32 ClientID;  \/\/ Opaque ID field to be used by client to map an AddRecord call to a set of Extra records$/;"	m	struct:ExtraResourceRecord_struct
ClientTunnel	mDNSEmbeddedAPI.h	/^	} ClientTunnel;$/;"	t	typeref:struct:ClientTunnel
ClientTunnel	mDNSEmbeddedAPI.h	/^typedef struct ClientTunnel$/;"	s
CompareHosts	NetMonitor.c	/^mDNSlocal int CompareHosts(const void *p1, const void *p2)$/;"	f
CompareRData	mDNS.c	/^mDNSlocal int CompareRData(const AuthRecord *const our, const CacheRecord *const pkt)$/;"	f
CompileTimeAssertionChecks_DNS_SD	dns_sd.h	/^struct CompileTimeAssertionChecks_DNS_SD$/;"	s
CompileTimeAssertionChecks_mDNS	mDNSEmbeddedAPI.h	/^struct CompileTimeAssertionChecks_mDNS$/;"	s
CompileTimeAssertionChecks_uDNS	uDNS.c	/^struct CompileTimeAssertionChecks_uDNS$/;"	s	file:
CompleteDeregistration	mDNS.c	/^mDNSexport void CompleteDeregistration(mDNS *const m, AuthRecord *rr)$/;"	f
CompleteRDataUpdate	mDNS.c	/^mDNSlocal void CompleteRDataUpdate(mDNS *const m, AuthRecord *const rr)$/;"	f
CompleteSRVNatMap	uDNS.c	/^mDNSlocal void CompleteSRVNatMap(mDNS *m, NATTraversalInfo *n)$/;"	f
CompressedDomainNameLength	DNSCommon.c	/^mDNSexport mDNSu16 CompressedDomainNameLength(const domainname *const name, const domainname *parent)$/;"	f
Conflict	mDNSEmbeddedAPI.h	/^	mDNSBool             Conflict;	\/\/ Set if this record set was forcibly deregistered because of a conflict$/;"	m	struct:ServiceRecordSet_struct
ConstructServiceName	DNSCommon.c	/^mDNSexport mDNSu8 *ConstructServiceName(domainname *const fqdn,$/;"	f
ConstructSleepProxyServerName	mDNS.c	/^mDNSlocal void ConstructSleepProxyServerName(mDNS *const m, domainlabel *name)$/;"	f
Context	mDNSPosix.c	/^	void						*Context;$/;"	m	struct:PosixEventSource	file:
ConvertDomainLabelToCString	mDNSEmbeddedAPI.h	3067;"	d
ConvertDomainLabelToCString_unescaped	mDNSEmbeddedAPI.h	3066;"	d
ConvertDomainLabelToCString_withescape	DNSCommon.c	/^mDNSexport char *ConvertDomainLabelToCString_withescape(const domainlabel *const label, char *ptr, char esc)$/;"	f
ConvertDomainNameToCString	mDNSEmbeddedAPI.h	3070;"	d
ConvertDomainNameToCString_unescaped	mDNSEmbeddedAPI.h	3069;"	d
ConvertDomainNameToCString_withescape	DNSCommon.c	/^mDNSexport char *ConvertDomainNameToCString_withescape(const domainname *const name, char *ptr, char esc)$/;"	f
ConvertUTF8PstringToRFC1034HostLabel	DNSCommon.c	/^mDNSexport void ConvertUTF8PstringToRFC1034HostLabel(const mDNSu8 UTF8Name[], domainlabel *const hostlabel)$/;"	f
CountLabels	DNSCommon.c	/^mDNSexport int CountLabels(const domainname *d)$/;"	f
CreateNewCacheEntry	mDNS.c	/^mDNSexport CacheRecord *CreateNewCacheEntry(mDNS *const m, const mDNSu32 slot, CacheGroup *cg)$/;"	f
CurrentAnswers	mDNSEmbeddedAPI.h	/^	mDNSu32               CurrentAnswers;	\/\/ Number of records currently in the cache that answer this question$/;"	m	struct:DNSQuestion_struct
CurrentNATTraversal	mDNSEmbeddedAPI.h	/^	NATTraversalInfo *CurrentNATTraversal;$/;"	m	struct:mDNS_struct
CurrentQuestion	mDNSEmbeddedAPI.h	/^	DNSQuestion *CurrentQuestion;		\/\/ Next question about to be examined in AnswerLocalQuestions()$/;"	m	struct:mDNS_struct
CurrentRecord	mDNSEmbeddedAPI.h	/^	AuthRecord *CurrentRecord;			\/\/ Next AuthRecord about to be examined$/;"	m	struct:mDNS_struct
CurrentSOA	mDNSEmbeddedAPI.h	/^	domainname       *CurrentSOA;		\/\/ Points to somewhere within ChildName$/;"	m	struct:ZoneData_struct
CurrentServiceRecordSet	uDNS.c	/^ServiceRecordSet *CurrentServiceRecordSet = mDNSNULL;$/;"	v
D	DNSDigest.c	/^	mDNSu32 A,B,C,D;$/;"	m	struct:MD5state_st	file:
DATABASE	nss_mdns.c	380;"	d	file:
DATA_ORDER_IS_LITTLE_ENDIAN	DNSDigest.c	344;"	d	file:
DEFAULT_UPDATE_LEASE	uDNS.h	241;"	d
DLLAddToHead	GenLinkedList.c	/^void			DLLAddToHead( GenDoubleLinkedList *pList, void *elem)$/;"	f
DLLRemoveFromList	GenLinkedList.c	/^void			DLLRemoveFromList( GenDoubleLinkedList *pList, void *elem)$/;"	f
DNSDigest_Base64ToBin	DNSDigest.c	/^mDNSlocal mDNSs32 DNSDigest_Base64ToBin(const char *src, mDNSu8 *target, mDNSu32 targsize)$/;"	f
DNSDigest_ConstructHMACKey	DNSDigest.c	/^mDNSlocal void DNSDigest_ConstructHMACKey(DomainAuthInfo *info, const mDNSu8 *key, mDNSu32 len)		$/;"	f
DNSDigest_ConstructHMACKeyfromBase64	DNSDigest.c	/^mDNSexport mDNSs32 DNSDigest_ConstructHMACKeyfromBase64(DomainAuthInfo *info, const char *b64key)$/;"	f
DNSDigest_SignMessage	DNSDigest.c	/^mDNSexport void DNSDigest_SignMessage(DNSMessage *msg, mDNSu8 **end, DomainAuthInfo *info, mDNSu16 tcode)$/;"	f
DNSDigest_SignMessageHostByteOrder	mDNSEmbeddedAPI.h	3224;"	d
DNSDigest_VerifyMessage	DNSDigest.c	/^mDNSexport mDNSBool DNSDigest_VerifyMessage(DNSMessage *msg, mDNSu8 *end, LargeCacheRecord * lcr, DomainAuthInfo *info, mDNSu16 * rcode, mDNSu16 * tcode)$/;"	f
DNSEXTPort	DNSCommon.c	/^mDNSexport const mDNSIPPort DNSEXTPort             = { { DNSEXTPortAsNumber             >> 8, DNSEXTPortAsNumber             & 0xFF } };$/;"	v
DNSEXTPortAsNumber	DNSCommon.c	614;"	d	file:
DNSOpt_Data_Space	mDNSEmbeddedAPI.h	1665;"	d
DNSOpt_Header_Space	mDNSEmbeddedAPI.h	1646;"	d
DNSOpt_LLQData_Space	mDNSEmbeddedAPI.h	1647;"	d
DNSOpt_LeaseData_Space	mDNSEmbeddedAPI.h	1648;"	d
DNSOpt_OwnerData_ID_Space	mDNSEmbeddedAPI.h	1649;"	d
DNSOpt_OwnerData_ID_Wake_PW4_Space	mDNSEmbeddedAPI.h	1651;"	d
DNSOpt_OwnerData_ID_Wake_PW6_Space	mDNSEmbeddedAPI.h	1652;"	d
DNSOpt_OwnerData_ID_Wake_Space	mDNSEmbeddedAPI.h	1650;"	d
DNSOpt_Owner_Space	mDNSEmbeddedAPI.h	1663;"	d
DNSQuestion	mDNSEmbeddedAPI.h	/^typedef struct DNSQuestion_struct DNSQuestion;$/;"	t	typeref:struct:DNSQuestion_struct
DNSQuestion_struct	mDNSEmbeddedAPI.h	/^struct DNSQuestion_struct$/;"	s
DNSRecordRef	dns_sd.h	/^typedef struct _DNSRecordRef_t *DNSRecordRef;$/;"	t	typeref:struct:_DNSRecordRef_t
DNSRelayTestQuestion	uDNS.c	/^mDNSlocal const domainname *DNSRelayTestQuestion = (const domainname*)$/;"	v
DNSSD_API	dns_sd.h	90;"	d
DNSSD_API	dns_sd.h	92;"	d
DNSSERVER_PENALTY_TIME	uDNS.h	239;"	d
DNSServer	mDNSEmbeddedAPI.h	/^	} DNSServer;$/;"	t	typeref:struct:DNSServer
DNSServer	mDNSEmbeddedAPI.h	/^typedef struct DNSServer$/;"	s
DNSServer_Disabled	mDNSEmbeddedAPI.h	/^	DNSServer_Disabled = 3$/;"	e	enum:__anon46
DNSServer_Failed	mDNSEmbeddedAPI.h	/^	DNSServer_Failed   = 2,$/;"	e	enum:__anon46
DNSServer_FlagDelete	mDNSEmbeddedAPI.h	/^	DNSServer_FlagDelete = 1,$/;"	e	enum:__anon47
DNSServer_FlagNew	mDNSEmbeddedAPI.h	/^	DNSServer_FlagNew    = 2$/;"	e	enum:__anon47
DNSServer_Passed	mDNSEmbeddedAPI.h	/^	DNSServer_Passed   = 1,$/;"	e	enum:__anon46
DNSServer_Untested	mDNSEmbeddedAPI.h	/^	DNSServer_Untested = 0,$/;"	e	enum:__anon46
DNSServers	mDNSEmbeddedAPI.h	/^	DNSServer        *DNSServers;           \/\/ list of DNS servers$/;"	m	struct:mDNS_struct
DNSServiceBrowseReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceBrowseReply)$/;"	t
DNSServiceDomainEnumReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceDomainEnumReply)$/;"	t
DNSServiceErrorType	dns_sd.h	/^typedef int32_t  DNSServiceErrorType;$/;"	t
DNSServiceFlags	dns_sd.h	/^typedef uint32_t DNSServiceFlags;$/;"	t
DNSServiceGetAddrInfoReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceGetAddrInfoReply)$/;"	t
DNSServiceNATPortMappingReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceNATPortMappingReply)$/;"	t
DNSServiceProtocol	dns_sd.h	/^typedef uint32_t DNSServiceProtocol;$/;"	t
DNSServiceQueryRecordReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceQueryRecordReply)$/;"	t
DNSServiceRef	dns_sd.h	/^typedef struct _DNSServiceRef_t *DNSServiceRef;$/;"	t	typeref:struct:_DNSServiceRef_t
DNSServiceRegisterRecordReply	dns_sd.h	/^ typedef void (DNSSD_API *DNSServiceRegisterRecordReply)$/;"	t
DNSServiceRegisterReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceRegisterReply)$/;"	t
DNSServiceResolveReply	dns_sd.h	/^typedef void (DNSSD_API *DNSServiceResolveReply)$/;"	t
DNSTypeName	DNSCommon.c	/^mDNSexport char *DNSTypeName(mDNSu16 rrtype)$/;"	f
DNS_ClassValues	mDNSEmbeddedAPI.h	/^	} DNS_ClassValues;$/;"	t	typeref:enum:__anon16
DNS_Flags	DNSCommon.h	/^	} DNS_Flags;$/;"	t	typeref:enum:__anon8
DNS_LABEL_MAXLEN	nss_mdns.c	336;"	d	file:
DNS_NAME_MAXLEN	nss_mdns.c	338;"	d	file:
DNS_OP_Name	DNSCommon.c	2845;"	d	file:
DNS_PTR_AF_INET6_SIZE	nss_mdns.c	177;"	d	file:
DNS_PTR_AF_INET_SIZE	nss_mdns.c	154;"	d	file:
DNS_RC_Name	DNSCommon.c	2853;"	d	file:
DNS_RDATA_TO_NAME_BAD_FORMAT	nss_mdns.c	/^	DNS_RDATA_TO_NAME_BAD_FORMAT = -1,$/;"	e	enum:__anon11	file:
DNS_RDATA_TO_NAME_PTR	nss_mdns.c	/^	DNS_RDATA_TO_NAME_PTR = -3,$/;"	e	enum:__anon11	file:
DNS_RDATA_TO_NAME_TOO_LONG	nss_mdns.c	/^	DNS_RDATA_TO_NAME_TOO_LONG = -2,$/;"	e	enum:__anon11	file:
DNS_TypeValues	mDNSEmbeddedAPI.h	/^	} DNS_TypeValues;$/;"	t	typeref:enum:__anon17
DNameListElem	mDNSEmbeddedAPI.h	/^	} DNameListElem;$/;"	t	typeref:struct:DNameListElem
DNameListElem	mDNSEmbeddedAPI.h	/^typedef struct DNameListElem$/;"	s
DeadvertiseInterface	mDNS.c	/^mDNSlocal void DeadvertiseInterface(mDNS *const m, NetworkInterfaceInfo *set)$/;"	f
DeconstructServiceName	DNSCommon.c	/^mDNSexport mDNSBool DeconstructServiceName(const domainname *const fqdn,$/;"	f
DefBrowseQ	mDNSEmbeddedAPI.h	/^	DNSQuestion DefBrowseQ;$/;"	m	struct:SearchListElem
DefRegisterQ	mDNSEmbeddedAPI.h	/^	DNSQuestion DefRegisterQ;$/;"	m	struct:SearchListElem
DefaultAPIntervalForRecordType	mDNS.c	1743;"	d	file:
DefaultAnnounceIntervalForTypeShared	mDNS.c	1740;"	d	file:
DefaultAnnounceIntervalForTypeUnique	mDNS.c	1741;"	d	file:
DefaultProbeCountForRecordType	mDNS.c	1731;"	d	file:
DefaultProbeCountForTypeUnique	mDNS.c	1730;"	d	file:
DefaultProbeIntervalForTypeUnique	mDNS.c	1739;"	d	file:
DefaultTTLforRRType	mDNSEmbeddedAPI.h	1345;"	d
DeferredStatus	mDNSEmbeddedAPI.h	/^	mStatus           DeferredStatus;			\/\/ status to deliver when above flag is set$/;"	m	struct:ServiceRecordSet_struct
DelayAnswering	mDNSEmbeddedAPI.h	/^	mDNSs32               DelayAnswering;	\/\/ Set if we want to defer answering this question until the cache settles$/;"	m	struct:DNSQuestion_struct
DelayDelivery	mDNSEmbeddedAPI.h	/^	mDNSs32         DelayDelivery;		\/\/ Set if we want to defer delivery of this answer to local clients$/;"	m	struct:CacheRecord_struct
DelaySleep	mDNSEmbeddedAPI.h	/^	mDNSs32  DelaySleep;				\/\/ To inhibit re-sleeping too quickly right after wake$/;"	m	struct:mDNS_struct
DependentOn	mDNSEmbeddedAPI.h	/^	AuthRecord     *DependentOn;		\/\/ This record depends on another for its uniqueness checking$/;"	m	struct:AuthRecord_struct
DeregLoop	mDNS.c	/^mDNSlocal void DeregLoop(mDNS *const m, AuthRecord *const start)$/;"	f
DeregisterOurServices	Responder.c	/^static void DeregisterOurServices(void)$/;"	f	file:
DetermineMaxEventFD	mDNSPosix.c	/^mDNSlocal void	DetermineMaxEventFD(void)$/;"	f
DeviceInfo	mDNSEmbeddedAPI.h	/^	AuthRecord  DeviceInfo;$/;"	m	struct:mDNS_struct
DeviceInfoName	mDNSEmbeddedAPI.h	2772;"	d
DiscardDeregistrations	mDNS.c	/^mDNSlocal void DiscardDeregistrations(mDNS *const m)$/;"	f
DiscardPort	DNSCommon.c	/^mDNSexport const mDNSIPPort DiscardPort            = { { DiscardPortAsNumber            >> 8, DiscardPortAsNumber            & 0xFF } };$/;"	v
DiscardPortAsNumber	DNSCommon.c	606;"	d	file:
DisplayError	NetMonitor.c	/^mDNSlocal void DisplayError(const mDNSAddr *srcaddr, const mDNSu8 *ptr, const mDNSu8 *const end, char *msg)$/;"	f
DisplayPacketHeader	NetMonitor.c	/^mDNSlocal void DisplayPacketHeader(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end, const mDNSAddr *srcaddr, mDNSIPPort srcport, const mDNSAddr *dstaddr, const mDNSInterfaceID InterfaceID)$/;"	f
DisplayQuery	NetMonitor.c	/^mDNSlocal void DisplayQuery(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
DisplayResourceRecord	NetMonitor.c	/^mDNSlocal void DisplayResourceRecord(const mDNSAddr *const srcaddr, const char *const op, const ResourceRecord *const pktrr)$/;"	f
DisplayResponse	NetMonitor.c	/^mDNSlocal void DisplayResponse(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *end,$/;"	f
DisposeTCPConn	uDNS.c	/^mDNSexport void DisposeTCPConn(struct tcpInfo_t *tcp)$/;"	f
DivertMulticastAdvertisements	mDNSEmbeddedAPI.h	/^	mDNSBool DivertMulticastAdvertisements; \/\/ from interfaces that do not advertise local addresses to local-only$/;"	m	struct:mDNS_struct
DoOneQuery	Identify.c	/^mDNSlocal void DoOneQuery(DNSQuestion *q, char *qname, mDNSu16 qtype, const mDNSAddr *target, mDNSQuestionCallback callback)$/;"	f
DoQuery	Identify.c	/^mDNSlocal int DoQuery(DNSQuestion *q, char *qname, mDNSu16 qtype, const mDNSAddr *target, mDNSQuestionCallback callback)$/;"	f
DomainAuthInfo	mDNSEmbeddedAPI.h	/^	} DomainAuthInfo;$/;"	t	typeref:struct:DomainAuthInfo
DomainAuthInfo	mDNSEmbeddedAPI.h	/^typedef struct DomainAuthInfo$/;"	s
DomainNameHashValue	DNSCommon.c	/^mDNSexport mDNSu32 DomainNameHashValue(const domainname *const name)$/;"	f
DomainNameLength	mDNSEmbeddedAPI.h	3038;"	d
DomainNameLengthLimit	DNSCommon.c	/^mDNSexport mDNSu16 DomainNameLengthLimit(const domainname *const name, const mDNSu8 *limit)$/;"	f
DummyCallback	mDNS.c	/^mDNSlocal void DummyCallback(mDNS *const m, AuthRecord *rr, mStatus result)$/;"	f
DumpPacket	DNSCommon.c	/^mDNSexport void DumpPacket(mDNS *const m, mStatus status, mDNSBool sent, char *transport,$/;"	f
DumpRecords	DNSCommon.c	/^mDNSlocal const mDNSu8 *DumpRecords(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *ptr, const mDNSu8 *const end, int count, char *label)$/;"	f
DumpStateLog	PosixDaemon.c	/^mDNSlocal void DumpStateLog(mDNS *const m)$/;"	f
DupSuppress	mDNSEmbeddedAPI.h	/^	DupSuppressInfo       DupSuppress[DupSuppressInfoSize];$/;"	m	struct:DNSQuestion_struct
DupSuppressInfo	mDNSEmbeddedAPI.h	/^	} DupSuppressInfo;$/;"	t	typeref:struct:__anon48
DupSuppressInfoSize	mDNSEmbeddedAPI.h	2240;"	d
DuplicateOf	mDNSEmbeddedAPI.h	/^	DNSQuestion          *DuplicateOf;$/;"	m	struct:DNSQuestion_struct
DuplicateRecords	mDNSEmbeddedAPI.h	/^	AuthRecord *DuplicateRecords;		\/\/ Records currently 'on hold' because they are duplicates of existing records$/;"	m	struct:mDNS_struct
DynDNSHostNameCallback	mDNS.c	/^mDNSlocal void DynDNSHostNameCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
DynDNSHostname	PosixDaemon.c	/^static domainname DynDNSHostname;$/;"	v	file:
DynDNSZone	PosixDaemon.c	/^static domainname DynDNSZone;                \/\/ Default wide-area zone for service registration$/;"	v	file:
ENTNAME	nss_mdns.c	379;"	d	file:
EXEC	Makefile	/^EXEC = mDNSResponder$/;"	m
ExactlyOneFilter	NetMonitor.c	210;"	d	file:
ExampleClientEventLoop	ExampleClientApp.c	/^mDNSexport void ExampleClientEventLoop(mDNS *const m)$/;"	f
ExpectUnicastResp	mDNSEmbeddedAPI.h	/^	mDNSs32               ExpectUnicastResp;\/\/ Set when we send a query with the kDNSQClass_UnicastResponse bit set$/;"	m	struct:DNSQuestion_struct
ExpectUnique	mDNSEmbeddedAPI.h	/^	mDNSBool              ExpectUnique;		\/\/ Set by client if it's expecting unique RR(s) for this question, not shared RRs$/;"	m	struct:DNSQuestion_struct
ExpectingUnicastResponseForQuestion	mDNS.c	/^mDNSlocal DNSQuestion *ExpectingUnicastResponseForQuestion(const mDNS *const m, const mDNSIPPort port, const mDNSOpaque16 id, const DNSQuestion *const question)$/;"	f
ExpectingUnicastResponseForRecord	mDNS.c	/^mDNSlocal mDNSBool ExpectingUnicastResponseForRecord(mDNS *const m, const mDNSAddr *const srcaddr, const mDNSBool SrcLocal, const mDNSIPPort port, const mDNSOpaque16 id, const CacheRecord *const rr)$/;"	f
ExpireDupSuppressInfo	mDNS.c	/^mDNSlocal void ExpireDupSuppressInfo(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 time)$/;"	f
ExpireDupSuppressInfoOnInterface	mDNS.c	/^mDNSlocal void ExpireDupSuppressInfoOnInterface(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 time, mDNSInterfaceID InterfaceID)$/;"	f
ExpiryTime	mDNSEmbeddedAPI.h	/^	mDNSs32                     ExpiryTime;			\/\/ Time this mapping expires, or zero if no mapping$/;"	m	struct:NATTraversalInfo_struct
ExternalAddress	mDNSEmbeddedAPI.h	/^	mDNSv4Addr                  ExternalAddress;	\/\/ Initially set to onesIPv4Addr, until first callback$/;"	m	struct:NATTraversalInfo_struct
ExternalAddress	mDNSEmbeddedAPI.h	/^	mDNSv4Addr        ExternalAddress;$/;"	m	struct:mDNS_struct
ExternalPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort                  ExternalPort;$/;"	m	struct:NATTraversalInfo_struct
ExtraResourceRecord	mDNSEmbeddedAPI.h	/^typedef struct ExtraResourceRecord_struct ExtraResourceRecord;$/;"	t	typeref:struct:ExtraResourceRecord_struct
ExtraResourceRecord_struct	mDNSEmbeddedAPI.h	/^struct ExtraResourceRecord_struct$/;"	s
ExtractServiceType	NetMonitor.c	/^mDNSexport mDNSBool ExtractServiceType(const domainname *const fqdn, domainname *const srvtype)$/;"	f
Extras	mDNSEmbeddedAPI.h	/^	ExtraResourceRecord *Extras;	\/\/ Optional list of extra AuthRecords attached to this service registration$/;"	m	struct:ServiceRecordSet_struct
F	DNSDigest.c	977;"	d	file:
FORALL_CACHERECORDS	mDNSEmbeddedAPI.h	2714;"	d
FQDN	mDNSEmbeddedAPI.h	/^	domainname        FQDN;$/;"	m	struct:mDNS_struct
FilterAddr	NetMonitor.c	/^	mDNSAddr FilterAddr;$/;"	m	struct:FilterList_struct	file:
FilterInterface	NetMonitor.c	/^static int FilterInterface = 0;$/;"	v	file:
FilterList	NetMonitor.c	/^typedef struct FilterList_struct FilterList;$/;"	t	typeref:struct:FilterList_struct	file:
FilterList_struct	NetMonitor.c	/^struct FilterList_struct$/;"	s	file:
Filters	NetMonitor.c	/^static FilterList *Filters;$/;"	v	file:
FindCompressionPointer	DNSCommon.c	/^mDNSexport const mDNSu8 *FindCompressionPointer(const mDNSu8 *const base, const mDNSu8 *const end, const mDNSu8 *const domname)$/;"	f
FindDuplicateQuestion	mDNS.c	/^mDNSlocal DNSQuestion *FindDuplicateQuestion(const mDNS *const m, const DNSQuestion *const question)$/;"	f
FindFirstAdvertisedInterface	mDNS.c	/^mDNSlocal NetworkInterfaceInfo *FindFirstAdvertisedInterface(mDNS *const m)$/;"	f
FindHost	NetMonitor.c	/^mDNSlocal HostEntry *FindHost(const mDNSAddr *addr, HostList *list)$/;"	f
FindIdenticalRecordInCache	mDNS.c	/^mDNSlocal CacheRecord *FindIdenticalRecordInCache(const mDNS *const m, const ResourceRecord *const pktrr)$/;"	f
FindRRSet	mDNS.c	/^mDNSlocal const AuthRecord *FindRRSet(const mDNS *const m, const CacheRecord *const pktrr)$/;"	f
FindSPSInCache	mDNS.c	/^mDNSexport void FindSPSInCache(mDNS *const m, const DNSQuestion *const q, const CacheRecord *sps[3])$/;"	f
FindSPSInCache1	mDNS.c	/^mDNSlocal const CacheRecord *FindSPSInCache1(mDNS *const m, const DNSQuestion *const q, const CacheRecord *const c0, const CacheRecord *const c1)$/;"	f
FindUpdate	NetMonitor.c	/^mDNSlocal const mDNSu8 *FindUpdate(mDNS *const m, const DNSMessage *const query, const mDNSu8 *ptr, const mDNSu8 *const end,$/;"	f
FirstInterfaceForID	mDNS.c	/^mDNSlocal NetworkInterfaceInfo *FirstInterfaceForID(mDNS *const m, const mDNSInterfaceID InterfaceID)$/;"	f
FirstLabel	mDNSEmbeddedAPI.h	3029;"	d
FlappingInterface1	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID       FlappingInterface1;\/\/ Set when an interface goes away, to flag if remove events are delivered for this Q$/;"	m	struct:DNSQuestion_struct
FlappingInterface2	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID       FlappingInterface2;\/\/ Set when an interface goes away, to flag if remove events are delivered for this Q$/;"	m	struct:DNSQuestion_struct
ForceMCast	mDNSEmbeddedAPI.h	/^	mDNSBool              ForceMCast;		\/\/ Set by client to force mDNS query, even for apparently uDNS names$/;"	m	struct:DNSQuestion_struct
ForceMCast	mDNSEmbeddedAPI.h	/^	mDNSu8          ForceMCast;			\/\/ Set by client to advertise solely via multicast, even for apparently unicast names$/;"	m	struct:AuthRecord_struct
ForceNaturalAlignment	dns_sd.h	/^typedef union _TXTRecordRef_t { char PrivateData[16]; char *ForceNaturalAlignment; } TXTRecordRef;$/;"	m	union:_TXTRecordRef_t
FoundDomain	uDNS.c	/^mDNSlocal void FoundDomain(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
FoundServiceInfo	mDNS.c	/^mDNSlocal void FoundServiceInfo(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
FoundServiceInfoSRV	mDNS.c	/^mDNSlocal void FoundServiceInfoSRV(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
FoundServiceInfoTXT	mDNS.c	/^mDNSlocal void FoundServiceInfoTXT(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
FoundStaticHostname	uDNS.c	/^mDNSlocal void FoundStaticHostname(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
FreeARElemCallback	uDNS.c	/^mDNSlocal void FreeARElemCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
FreePosixNetworkInterface	mDNSPosix.c	/^mDNSlocal void FreePosixNetworkInterface(PosixNetworkInterface *intf)$/;"	f
FwdLinkOffset	GenLinkedList.h	/^	size_t		FwdLinkOffset,$/;"	m	struct:GenDoubleLinkedList
G	DNSDigest.c	978;"	d	file:
GETLINK	GenLinkedList.c	42;"	d	file:
GETOFFSET	GenLinkedList.c	202;"	d	file:
GET_SA_LEN	mDNSUNP.h	113;"	d
GET_SA_LEN	mDNSUNP.h	116;"	d
GET_SA_LEN	mDNSUNP.h	119;"	d
GenDoubleLinkedList	GenLinkedList.h	/^struct	GenDoubleLinkedList$/;"	s
GenDoubleLinkedList	GenLinkedList.h	/^typedef struct GenDoubleLinkedList	GenDoubleLinkedList;$/;"	t	typeref:struct:GenDoubleLinkedList
GenLinkedList	GenLinkedList.h	/^struct	GenLinkedList$/;"	s
GenLinkedList	GenLinkedList.h	/^typedef struct GenLinkedList	GenLinkedList;$/;"	t	typeref:struct:GenLinkedList
GenLinkedOffsetList	GenLinkedList.h	/^struct	GenLinkedOffsetList$/;"	s
GenLinkedOffsetList	GenLinkedList.h	/^typedef struct GenLinkedOffsetList	GenLinkedOffsetList;$/;"	t	typeref:struct:GenLinkedOffsetList
GenerateUnicastResponse	mDNS.c	/^mDNSlocal mDNSu8 *GenerateUnicastResponse(const DNSMessage *const query, const mDNSu8 *const end,$/;"	f
GetAnyBestServer	mDNS.c	/^mDNSlocal DNSServer *GetAnyBestServer(mDNS *m, const domainname *name)$/;"	f
GetAuthInfoForName	uDNS.c	/^mDNSexport DomainAuthInfo *GetAuthInfoForName(mDNS *m, const domainname *const name)$/;"	f
GetAuthInfoForName_direct	uDNS.c	/^mDNSlocal DomainAuthInfo *GetAuthInfoForName_direct(mDNS *m, const domainname *const name)$/;"	f
GetAuthInfoForName_internal	uDNS.c	/^mDNSexport DomainAuthInfo *GetAuthInfoForName_internal(mDNS *m, const domainname *const name)$/;"	f
GetAuthInfoForQuestion	uDNS.c	/^mDNSexport DomainAuthInfo *GetAuthInfoForQuestion(mDNS *m, const DNSQuestion *const q)	\/\/ Must be called with lock held$/;"	f
GetCacheEntity	mDNS.c	/^mDNSlocal CacheEntity *GetCacheEntity(mDNS *const m, const CacheGroup *const PreserveCG)$/;"	f
GetCacheGroup	mDNS.c	/^mDNSlocal CacheGroup *GetCacheGroup(mDNS *const m, const mDNSu32 slot, const ResourceRecord *const rr)$/;"	f
GetCacheRecord	mDNS.c	/^mDNSlocal CacheRecord *GetCacheRecord(mDNS *const m, CacheGroup *cg, mDNSu16 RDLength)$/;"	f
GetConfigOption	PlatformCommon.c	/^mDNSlocal mDNSBool GetConfigOption(char *dst, const char *option, FILE *f)$/;"	f
GetEffectiveTTL	mDNS.c	/^mDNSlocal mDNSu32 GetEffectiveTTL(const uDNS_LLQType LLQType, mDNSu32 ttl)		\/\/ TTL in seconds$/;"	f
GetFirstActiveInterface	DNSCommon.c	/^mDNSexport NetworkInterfaceInfo *GetFirstActiveInterface(NetworkInterfaceInfo *intf)$/;"	f
GetHeadPtr	GenLinkedList.c	/^void		*GetHeadPtr( GenLinkedOffsetList *pList)$/;"	f
GetIPv4FromName	mDNS.c	/^mDNSlocal mStatus GetIPv4FromName(mDNSAddr *const a, const domainname *const name)$/;"	f
GetIPv6FromName	mDNS.c	/^mDNSlocal mStatus GetIPv6FromName(mDNSAddr *const a, const domainname *const name)$/;"	f
GetLLQEventPort	uDNS.c	/^mDNSlocal mDNSu16 GetLLQEventPort(const mDNS *const m, const mDNSAddr *const dst)$/;"	f
GetLLQOptData	DNSCommon.c	/^mDNSexport const rdataOPT *GetLLQOptData(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end)$/;"	f
GetLabelDecimalValue	mDNS.c	/^mDNSlocal mStatus GetLabelDecimalValue(const mDNSu8 *const src, mDNSu8 *dst)$/;"	f
GetLargeResourceRecord	DNSCommon.c	/^mDNSexport const mDNSu8 *GetLargeResourceRecord(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *ptr,$/;"	f
GetNextActiveInterfaceID	DNSCommon.c	/^mDNSexport mDNSInterfaceID GetNextActiveInterfaceID(const NetworkInterfaceInfo *intf)$/;"	f
GetNextScheduledEvent	DNSCommon.c	/^mDNSlocal mDNSs32 GetNextScheduledEvent(const mDNS *const m)$/;"	f
GetNextUnPenalizedServer	mDNS.c	/^mDNSlocal DNSServer *GetNextUnPenalizedServer(mDNS *m, DNSServer *prev)$/;"	f
GetOffsetLink	GenLinkedList.c	/^void		*GetOffsetLink( GenLinkedOffsetList *pList, void *elem)$/;"	f
GetPktLease	DNSCommon.c	/^mDNSexport mDNSu32 GetPktLease(mDNS *m, DNSMessage *msg, const mDNSu8 *end)$/;"	f
GetRDLength	DNSCommon.c	/^mDNSexport mDNSu16 GetRDLength(const ResourceRecord *const rr, mDNSBool estimate)$/;"	f
GetRDLengthMem	mDNS.c	/^mDNSlocal mDNSu16 GetRDLengthMem(const ResourceRecord *const rr)$/;"	f
GetRRDisplayString_rdb	DNSCommon.c	/^mDNSexport char *GetRRDisplayString_rdb(const ResourceRecord *const rr, const RDataBody *const rd1, char *const buffer)$/;"	f
GetRRDomainNameTarget	DNSCommon.h	313;"	d
GetServerForName	mDNS.c	/^mDNSexport DNSServer *GetServerForName(mDNS *m, const domainname *name, DNSServer *prev)$/;"	f
GetServiceTarget	uDNS.c	/^mDNSexport const domainname *GetServiceTarget(mDNS *m, AuthRecord *const rr)$/;"	f
GetStaticHostname	uDNS.c	/^mDNSlocal void GetStaticHostname(mDNS *m)$/;"	f
GetTailPtr	GenLinkedList.c	/^void		*GetTailPtr( GenLinkedOffsetList *pList)$/;"	f
GetUserSpecifiedFriendlyComputerName	mDNSPosix.c	/^mDNSlocal void GetUserSpecifiedFriendlyComputerName(domainlabel *const namelabel)$/;"	f
GetUserSpecifiedRFC1034ComputerName	mDNSPosix.c	/^mDNSlocal void GetUserSpecifiedRFC1034ComputerName(domainlabel *const namelabel)$/;"	f
GetZoneData_QuestionCallback	uDNS.c	/^mDNSlocal void GetZoneData_QuestionCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
GetZoneData_StartQuery	uDNS.c	/^mDNSlocal mStatus GetZoneData_StartQuery(mDNS *const m, ZoneData *zd, mDNSu16 qtype)$/;"	f
GotADD	mDNSEmbeddedAPI.h	/^	mDNSu8                        GotADD;$/;"	m	struct:ServiceInfoQuery_struct
GotPacketFromHost	NetMonitor.c	/^mDNSlocal HostEntry *GotPacketFromHost(const mDNSAddr *addr, HostPkt_Type t, mDNSOpaque16 id)$/;"	f
GotSRV	mDNSEmbeddedAPI.h	/^	mDNSu8                        GotSRV;$/;"	m	struct:ServiceInfoQuery_struct
GotTXT	mDNSEmbeddedAPI.h	/^	mDNSu8                        GotTXT;$/;"	m	struct:ServiceInfoQuery_struct
GrantCacheExtensions	mDNS.c	/^mDNSexport void GrantCacheExtensions(mDNS *const m, DNSQuestion *q, mDNSu32 lease)$/;"	f
GrantUpdateCredit	mDNS.c	/^mDNSlocal void GrantUpdateCredit(AuthRecord *rr)$/;"	f
H	DNSDigest.c	979;"	d	file:
HASH_BLOCK_DATA_ORDER	DNSDigest.c	365;"	d	file:
HASH_BLOCK_DATA_ORDER_ALIGNED	DNSDigest.c	312;"	d	file:
HASH_BLOCK_DATA_ORDER_ALIGNED	DNSDigest.c	628;"	d	file:
HASH_BLOCK_DATA_ORDER_ALIGNED	DNSDigest.c	642;"	d	file:
HASH_BLOCK_HOST_ORDER	DNSDigest.c	363;"	d	file:
HASH_CBLOCK	DNSDigest.c	349;"	d	file:
HASH_CTX	DNSDigest.c	348;"	d	file:
HASH_FINAL	DNSDigest.c	/^int HASH_FINAL (unsigned char *md, HASH_CTX *c)$/;"	f
HASH_FINAL	DNSDigest.c	354;"	d	file:
HASH_LBLOCK	DNSDigest.c	350;"	d	file:
HASH_LBLOCK	DNSDigest.c	496;"	d	file:
HASH_LONG	DNSDigest.c	346;"	d	file:
HASH_LONG_LOG2	DNSDigest.c	347;"	d	file:
HASH_LONG_LOG2	DNSDigest.c	500;"	d	file:
HASH_MAKE_STRING	DNSDigest.c	356;"	d	file:
HASH_TRANSFORM	DNSDigest.c	/^void HASH_TRANSFORM (HASH_CTX *c, const unsigned char *data)$/;"	f
HASH_TRANSFORM	DNSDigest.c	353;"	d	file:
HASH_UPDATE	DNSDigest.c	/^int HASH_UPDATE (HASH_CTX *c, const void *data_, unsigned long len)$/;"	f
HASH_UPDATE	DNSDigest.c	352;"	d	file:
HIHardware	NetMonitor.c	/^	UTF8str255 HIHardware;$/;"	m	struct:__anon6	file:
HIHardware	mDNSEmbeddedAPI.h	/^	UTF8str255  HIHardware;$/;"	m	struct:mDNS_struct
HISoftware	NetMonitor.c	/^	UTF8str255 HISoftware;$/;"	m	struct:__anon6	file:
HISoftware	mDNSEmbeddedAPI.h	/^	UTF8str255  HISoftware;$/;"	m	struct:mDNS_struct
HMAC	mDNSEmbeddedAPI.h	/^	mDNSEthAddr  HMAC;		\/\/ Host's primary identifier (e.g. MAC of on-board Ethernet)$/;"	m	struct:__anon33
HMAC_IPAD	DNSDigest.c	1369;"	d	file:
HMAC_IPAD	mDNSEmbeddedAPI.h	2282;"	d
HMAC_LEN	mDNSEmbeddedAPI.h	2281;"	d
HMAC_MD5_AlgName	DNSDigest.c	1373;"	d	file:
HMAC_OPAD	DNSDigest.c	1370;"	d	file:
HMAC_OPAD	mDNSEmbeddedAPI.h	2283;"	d
HOST_FETCH32	DNSDigest.c	633;"	d	file:
HOST_FETCH32	DNSDigest.c	635;"	d	file:
HOST_FETCH32	DNSDigest.c	647;"	d	file:
HOST_FETCH32	DNSDigest.c	649;"	d	file:
HOST_c2l	DNSDigest.c	663;"	d	file:
HOST_c2l	DNSDigest.c	699;"	d	file:
HOST_c2l_p	DNSDigest.c	684;"	d	file:
HOST_c2l_p	DNSDigest.c	720;"	d	file:
HOST_l2c	DNSDigest.c	691;"	d	file:
HOST_l2c	DNSDigest.c	727;"	d	file:
HOST_p_c2l	DNSDigest.c	668;"	d	file:
HOST_p_c2l	DNSDigest.c	704;"	d	file:
HOST_p_c2l_p	DNSDigest.c	675;"	d	file:
HOST_p_c2l_p	DNSDigest.c	711;"	d	file:
HandleSIG	ExampleClientApp.c	/^mDNSlocal void HandleSIG(int signal)$/;"	f
HandleSIG	Identify.c	/^mDNSlocal void HandleSIG(int signal)$/;"	f
HandleSigHup	Responder.c	/^static void HandleSigHup(int sigraised)$/;"	f	file:
HandleSigInt	Responder.c	/^static void HandleSigInt(int sigraised)$/;"	f	file:
HandleSigQuit	Responder.c	/^static void HandleSigQuit(int sigraised)$/;"	f	file:
HandleSigUsr1	Responder.c	/^static void HandleSigUsr1(int sigraised)$/;"	f	file:
HashSlot	DNSCommon.h	369;"	d
Head	GenLinkedList.h	/^	size_t		Head,$/;"	m	struct:GenLinkedOffsetList
Head	GenLinkedList.h	/^	void		*Head,$/;"	m	struct:GenDoubleLinkedList
Head	GenLinkedList.h	/^	void		*Head,$/;"	m	struct:GenLinkedList
HexDump	NetMonitor.c	/^mDNSlocal void HexDump(const mDNSu8 *ptr, const mDNSu8 *const end)$/;"	f
HexVal	mDNS.c	2592;"	d	file:
Host	mDNSEmbeddedAPI.h	/^	domainname       Host;				\/\/ Discovered result: Target host from SRV record$/;"	m	struct:ZoneData_struct
HostEntry	NetMonitor.c	/^	} HostEntry;$/;"	t	typeref:struct:__anon6	file:
HostEntryTotalPackets	NetMonitor.c	264;"	d	file:
HostInterfaces	mDNSEmbeddedAPI.h	/^	NetworkInterfaceInfo *HostInterfaces;$/;"	m	struct:mDNS_struct
HostList	NetMonitor.c	/^	} HostList;$/;"	t	typeref:struct:__anon7	file:
HostNameCallback	ProxyResponder.c	/^mDNSlocal void HostNameCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
HostPkt_B	NetMonitor.c	/^	HostPkt_B        = 3,		\/\/ Bad$/;"	e	enum:__anon5	file:
HostPkt_L	NetMonitor.c	/^	HostPkt_L        = 1,		\/\/ Legacy Query$/;"	e	enum:__anon5	file:
HostPkt_NumTypes	NetMonitor.c	/^	HostPkt_NumTypes = 4$/;"	e	enum:__anon5	file:
HostPkt_Q	NetMonitor.c	/^	HostPkt_Q        = 0,		\/\/ Query$/;"	e	enum:__anon5	file:
HostPkt_R	NetMonitor.c	/^	HostPkt_R        = 2,		\/\/ Response$/;"	e	enum:__anon5	file:
HostPkt_Type	NetMonitor.c	/^	} HostPkt_Type;$/;"	t	typeref:enum:__anon5	file:
HostnameCallback	uDNS.c	/^mDNSlocal void HostnameCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
HostnameInfo	mDNSEmbeddedAPI.h	/^	} HostnameInfo;$/;"	t	typeref:struct:HostnameInfo
HostnameInfo	mDNSEmbeddedAPI.h	/^typedef struct HostnameInfo$/;"	s
Hostnames	mDNSEmbeddedAPI.h	/^	HostnameInfo     *Hostnames;            \/\/ List of registered hostnames + hostname metadata$/;"	m	struct:mDNS_struct
I	DNSDigest.c	980;"	d	file:
IFI_ALIAS	mDNSUNP.h	167;"	d
IFI_HADDR	mDNSUNP.h	123;"	d
IFI_NAME	mDNSUNP.h	122;"	d
IFNAMSIZ	NetMonitor.c	130;"	d	file:
IMAC	mDNSEmbeddedAPI.h	/^	mDNSEthAddr  IMAC;		\/\/ Interface's MAC address (if different to primary MAC)$/;"	m	struct:__anon33
INADDR_NONE	ProxyResponder.c	152;"	d	file:
INET6_ADDRSTRLEN	mDNSUNP.h	162;"	d
INIT_DATA_A	DNSDigest.c	1008;"	d	file:
INIT_DATA_B	DNSDigest.c	1009;"	d	file:
INIT_DATA_C	DNSDigest.c	1010;"	d	file:
INIT_DATA_D	DNSDigest.c	1011;"	d	file:
INIT_UCAST_POLL_INTERVAL	uDNS.h	232;"	d
IPSECPort	DNSCommon.c	/^mDNSexport const mDNSIPPort IPSECPort              = { { IPSECPortAsNumber              >> 8, IPSECPortAsNumber              & 0xFF } };$/;"	v
IPSECPortAsNumber	DNSCommon.c	610;"	d	file:
IPv4Available	mDNSEmbeddedAPI.h	/^	mDNSu8          IPv4Available;		\/\/ If InterfaceActive, set if v4 available on this InterfaceID$/;"	m	struct:NetworkInterfaceInfo_struct
IPv4HostList	NetMonitor.c	/^static HostList IPv4HostList = { 0, 0, 0 };$/;"	v	file:
IPv6Available	mDNSEmbeddedAPI.h	/^	mDNSu8          IPv6Available;		\/\/ If InterfaceActive, set if v6 available on this InterfaceID$/;"	m	struct:NetworkInterfaceInfo_struct
IPv6HostList	NetMonitor.c	/^static HostList IPv6HostList = { 0, 0, 0 };$/;"	v	file:
IS_A_PRINTF_STYLE_FUNCTION	mDNSDebug.h	206;"	d
IS_A_PRINTF_STYLE_FUNCTION	mDNSDebug.h	208;"	d
IdenticalResourceRecord	DNSCommon.h	284;"	d
IdenticalSameNameRecord	DNSCommon.h	293;"	d
IfChangeRec	mDNSPosix.c	/^struct IfChangeRec$/;"	s	file:
IfChangeRec	mDNSPosix.c	/^typedef struct IfChangeRec	IfChangeRec;$/;"	t	typeref:struct:IfChangeRec	file:
ImmedAdditional	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID ImmedAdditional;	\/\/ Hint that we might want to also send this record, just to be helpful$/;"	m	struct:AuthRecord_struct
ImmedAnswer	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID ImmedAnswer;		\/\/ Someone on this interface issued a query we need to answer (all-ones for all interfaces)$/;"	m	struct:AuthRecord_struct
ImmedAnswerMarkTime	mDNSEmbeddedAPI.h	/^	mDNSs32         ImmedAnswerMarkTime;$/;"	m	struct:AuthRecord_struct
ImmedUnicast	mDNSEmbeddedAPI.h	/^	mDNSu8          ImmedUnicast;		\/\/ Set if we may send our response directly via unicast to the requester$/;"	m	struct:AuthRecord_struct
InFlightRDLen	mDNSEmbeddedAPI.h	/^	mDNSu16 InFlightRDLen;	\/\/ currently being registered$/;"	m	struct:AuthRecord_struct
InFlightRData	mDNSEmbeddedAPI.h	/^	RData *InFlightRData;$/;"	m	struct:AuthRecord_struct
IncludeInProbe	mDNSEmbeddedAPI.h	/^	mDNSu8          IncludeInProbe;		\/\/ Set if this RR is being put into a probe right now$/;"	m	struct:AuthRecord_struct
IncrementLabelSuffix	DNSCommon.c	/^mDNSexport void IncrementLabelSuffix(domainlabel *name, mDNSBool RichText)$/;"	f
InfoCallback	Identify.c	/^mDNSlocal void InfoCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
InitDoubleLinkedList	GenLinkedList.c	/^void		InitDoubleLinkedList( GenDoubleLinkedList *pList, size_t fwdLinkOffset,$/;"	f
InitLinkedList	GenLinkedList.c	/^void		InitLinkedList( GenLinkedList *pList, size_t linkOffset)$/;"	f
InitLinkedOffsetList	GenLinkedList.c	/^void		InitLinkedOffsetList( GenLinkedOffsetList *pList, size_t linkOffset)$/;"	f
InitialAnnounceCount	mDNS.c	1733;"	d	file:
InitialQuestionInterval	uDNS.h	246;"	d
InitializeDNSMessage	DNSCommon.c	/^mDNSexport void InitializeDNSMessage(DNSMessageHeader *h, mDNSOpaque16 id, mDNSOpaque16 flags)$/;"	f
InitializeLastAPTime	mDNS.c	/^mDNSlocal void InitializeLastAPTime(mDNS *const m, AuthRecord *const rr)$/;"	f
InitializeNetWakeState	mDNS.c	/^mDNSlocal void InitializeNetWakeState(mDNS *const m, NetworkInterfaceInfo *set)$/;"	f
InlineCacheGroupNameSize	mDNSEmbeddedAPI.h	1703;"	d
InlineCacheGroupNameSize	mDNSEmbeddedAPI.h	1705;"	d
InlineCacheGroupNameSize	mDNSEmbeddedAPI.h	1709;"	d
InlineCacheGroupNameSize	mDNSEmbeddedAPI.h	1711;"	d
InlineCacheRDSize	mDNSEmbeddedAPI.h	1698;"	d
IntPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort                  IntPort;			\/\/ Client's internal port number (doesn't change)$/;"	m	struct:NATTraversalInfo_struct
InterfaceActive	mDNSEmbeddedAPI.h	/^	mDNSu8          InterfaceActive;	\/\/ Set if interface is sending & receiving packets (see comment above)$/;"	m	struct:NetworkInterfaceInfo_struct
InterfaceChangeCallback	mDNSPosix.c	/^mDNSlocal void InterfaceChangeCallback(int fd, short filter, void *context)$/;"	f
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID             InterfaceID;$/;"	m	struct:NATTraversalInfo_struct
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID       InterfaceID;		\/\/ Non-zero if you want to issue queries only on a single specific IP interface$/;"	m	struct:DNSQuestion_struct
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID       InterfaceID;$/;"	m	struct:__anon48
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID  InterfaceID;		\/\/ Set if this RR is specific to one interface$/;"	m	struct:__anon42
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID InterfaceID;		\/\/ ID of the interface the response was received on$/;"	m	struct:__anon53
InterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID InterfaceID;		\/\/ Identifies physical interface; MUST NOT be 0, -1, or -2$/;"	m	struct:NetworkInterfaceInfo_struct
InterfaceNameForID	mDNS.c	/^mDNSexport char *InterfaceNameForID(mDNS *const m, const mDNSInterfaceID InterfaceID)$/;"	f
IsLLQ	mDNS.c	7288;"	d	file:
IsLocalDomain	DNSCommon.c	/^mDNSexport mDNSBool IsLocalDomain(const domainname *d)$/;"	f
IsUnicastUpdate	DNSCommon.c	2168;"	d	file:
KnownBugs	mDNSEmbeddedAPI.h	/^	mDNSu32  KnownBugs;$/;"	m	struct:mDNS_struct
LE_FETCH32	DNSDigest.c	561;"	d	file:
LE_FETCH32	DNSDigest.c	570;"	d	file:
LLQErr_BadVers	mDNSEmbeddedAPI.h	/^	LLQErr_BadVers    = 5,$/;"	e	enum:__anon50
LLQErr_FormErr	mDNSEmbeddedAPI.h	/^	LLQErr_FormErr    = 3,$/;"	e	enum:__anon50
LLQErr_NoError	mDNSEmbeddedAPI.h	/^	LLQErr_NoError    = 0,$/;"	e	enum:__anon50
LLQErr_NoSuchLLQ	mDNSEmbeddedAPI.h	/^	LLQErr_NoSuchLLQ  = 4,$/;"	e	enum:__anon50
LLQErr_ServFull	mDNSEmbeddedAPI.h	/^	LLQErr_ServFull   = 1,$/;"	e	enum:__anon50
LLQErr_Static	mDNSEmbeddedAPI.h	/^	LLQErr_Static     = 2,$/;"	e	enum:__anon50
LLQErr_UnknownErr	mDNSEmbeddedAPI.h	/^	LLQErr_UnknownErr = 6$/;"	e	enum:__anon50
LLQGotZoneData	uDNS.c	/^mDNSexport void LLQGotZoneData(mDNS *const m, mStatus err, const ZoneData *zoneInfo)$/;"	f
LLQNAT	mDNSEmbeddedAPI.h	/^	NATTraversalInfo  LLQNAT;					\/\/ Single shared NAT Traversal to receive inbound LLQ notifications$/;"	m	struct:mDNS_struct
LLQNATCallback	mDNS.c	/^mDNSlocal void LLQNATCallback(mDNS *m, NATTraversalInfo *n)$/;"	f
LLQOptData	mDNSEmbeddedAPI.h	/^	} LLQOptData;$/;"	t	typeref:struct:__anon32
LLQ_Established	mDNSEmbeddedAPI.h	/^	LLQ_Established       = 3,$/;"	e	enum:__anon49
LLQ_InitialRequest	mDNSEmbeddedAPI.h	/^	LLQ_InitialRequest    = 1,$/;"	e	enum:__anon49
LLQ_POLL_INTERVAL	uDNS.h	236;"	d
LLQ_Poll	mDNSEmbeddedAPI.h	/^	LLQ_Poll              = 4$/;"	e	enum:__anon49
LLQ_SecondaryRequest	mDNSEmbeddedAPI.h	/^	LLQ_SecondaryRequest  = 2,$/;"	e	enum:__anon49
LLQ_State	mDNSEmbeddedAPI.h	/^	} LLQ_State;$/;"	t	typeref:enum:__anon49
LNTDiscoveryOp	mDNSEmbeddedAPI.h	/^	LNTDiscoveryOp      = 1,$/;"	e	enum:__anon41
LNTExternalAddrOp	mDNSEmbeddedAPI.h	/^	LNTExternalAddrOp   = 2,$/;"	e	enum:__anon41
LNTOp_t	mDNSEmbeddedAPI.h	/^	} LNTOp_t;$/;"	t	typeref:enum:__anon41
LNTPortMapDeleteOp	mDNSEmbeddedAPI.h	/^	LNTPortMapDeleteOp  = 4$/;"	e	enum:__anon41
LNTPortMapOp	mDNSEmbeddedAPI.h	/^	LNTPortMapOp        = 3,$/;"	e	enum:__anon41
LNT_MAXBUFSIZE	mDNSEmbeddedAPI.h	1852;"	d
LOG_CONS	mDNSDebug.c	86;"	d	file:
LOG_HELPER_BODY	mDNSDebug.c	125;"	d	file:
LOG_PERROR	mDNSDebug.c	87;"	d	file:
LOG_PID	mDNSDebug.c	85;"	d	file:
LabelContainsSuffix	DNSCommon.c	/^mDNSexport mDNSBool LabelContainsSuffix(const domainlabel *const name, const mDNSBool RichText)$/;"	f
LargeAnswers	mDNSEmbeddedAPI.h	/^	mDNSu32               LargeAnswers;		\/\/ Number of answers with rdata > 1024 bytes$/;"	m	struct:DNSQuestion_struct
LargeCacheRecord	mDNSEmbeddedAPI.h	/^	} LargeCacheRecord;$/;"	t	typeref:struct:__anon45
LastAPTime	mDNSEmbeddedAPI.h	/^	mDNSs32         LastAPTime;			\/\/ In platform time units: Last time we sent announcement\/probe$/;"	m	struct:AuthRecord_struct
LastAnswerPktNum	mDNSEmbeddedAPI.h	/^	mDNSs32               LastAnswerPktNum;	\/\/ The sequence number of the last response packet containing an answer to this Q$/;"	m	struct:DNSQuestion_struct
LastLabel	DNSCommon.c	/^mDNSexport const mDNSu8 *LastLabel(const domainname *d)$/;"	f
LastMCInterface	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID LastMCInterface;	\/\/ Interface this record was multicast on at the time LastMCTime was recorded$/;"	m	struct:AuthRecord_struct
LastMCTime	mDNSEmbeddedAPI.h	/^	mDNSs32         LastMCTime;			\/\/ Last time we multicast this record (used to guard against packet-storm attacks)$/;"	m	struct:AuthRecord_struct
LastNATMapResultCode	mDNSEmbeddedAPI.h	/^	mDNSu16           LastNATMapResultCode;		\/\/ Most recent error code for mappings$/;"	m	struct:mDNS_struct
LastNATReplyLocalTime	mDNSEmbeddedAPI.h	/^	mDNSs32           LastNATReplyLocalTime;	\/\/ Local time in ticks when most recent NAT packet was received$/;"	m	struct:mDNS_struct
LastNATupseconds	mDNSEmbeddedAPI.h	/^	mDNSu32           LastNATupseconds;			\/\/ NAT engine uptime in seconds, from most recent NAT packet$/;"	m	struct:mDNS_struct
LastQTime	mDNSEmbeddedAPI.h	/^	mDNSs32               LastQTime;		\/\/ Last scheduled transmission of this Q on *all* applicable interfaces$/;"	m	struct:DNSQuestion_struct
LastQTxTime	mDNSEmbeddedAPI.h	/^	mDNSs32               LastQTxTime;		\/\/ Last time this Q was sent on one (but not necessarily all) interfaces$/;"	m	struct:DNSQuestion_struct
LastQuery	NetMonitor.c	/^	mDNSs32    LastQuery;$/;"	m	struct:__anon6	file:
LastUnansweredTime	mDNSEmbeddedAPI.h	/^	mDNSs32         LastUnansweredTime;	\/\/ In platform time units; last time we incremented UnansweredQueries$/;"	m	struct:CacheRecord_struct
LastUsed	mDNSEmbeddedAPI.h	/^	mDNSs32         LastUsed;			\/\/ In platform time units$/;"	m	struct:CacheRecord_struct
Lifetime	mDNSEmbeddedAPI.h	/^	mDNSu32                     Lifetime;$/;"	m	struct:NATTraversalInfo_struct
LinkOffset	GenLinkedList.h	/^	size_t		LinkOffset;$/;"	m	struct:GenLinkedList
LinkOffset	GenLinkedList.h	/^	size_t		LinkOffset;$/;"	m	struct:GenLinkedOffsetList
LocalOnlyQuestions	mDNSEmbeddedAPI.h	/^	DNSQuestion *LocalOnlyQuestions;	\/\/ Questions with InterfaceID set to mDNSInterface_LocalOnly$/;"	m	struct:mDNS_struct
LocalRecordReady	DNSCommon.h	318;"	d
LocalSocket	mDNSEmbeddedAPI.h	/^	UDPSocket            *LocalSocket;$/;"	m	struct:DNSQuestion_struct
LocateAdditionals	DNSCommon.c	/^mDNSexport const mDNSu8 *LocateAdditionals(const DNSMessage *const msg, const mDNSu8 *const end)$/;"	f
LocateAnswers	DNSCommon.c	/^mDNSexport const mDNSu8 *LocateAnswers(const DNSMessage *const msg, const mDNSu8 *const end)$/;"	f
LocateAuthorities	DNSCommon.c	/^mDNSexport const mDNSu8 *LocateAuthorities(const DNSMessage *const msg, const mDNSu8 *const end)$/;"	f
LocateOptRR	DNSCommon.c	/^mDNSexport const mDNSu8 *LocateOptRR(const DNSMessage *const msg, const mDNSu8 *const end, int minsize)$/;"	f
LogInfo	mDNSDebug.h	246;"	d
LogInfo	mDNSDebug.h	252;"	d
LogInfo	mDNSDebug.h	263;"	d
LogMsg	mDNSDebug.h	243;"	d
LogMsg	mDNSDebug.h	249;"	d
LogMsg	mDNSDebug.h	260;"	d
LogMsgNoIdent	mDNSDebug.h	290;"	d
LogMsgWithLevelv	mDNSDebug.c	/^mDNSlocal void LogMsgWithLevelv(mDNSLogLevel_t logLevel, const char *format, va_list ptr)$/;"	f
LogOperation	mDNSDebug.h	244;"	d
LogOperation	mDNSDebug.h	250;"	d
LogOperation	mDNSDebug.h	261;"	d
LogSPS	mDNSDebug.h	245;"	d
LogSPS	mDNSDebug.h	251;"	d
LogSPS	mDNSDebug.h	262;"	d
LongLived	mDNSEmbeddedAPI.h	/^	mDNSBool              LongLived;        \/\/ Set by client for calls to mDNS_StartQuery to indicate LLQs to unicast layer.$/;"	m	struct:DNSQuestion_struct
LoopbackIPCPort	DNSCommon.c	/^mDNSexport const mDNSIPPort LoopbackIPCPort        = { { LoopbackIPCPortAsNumber        >> 8, LoopbackIPCPortAsNumber        & 0xFF } };$/;"	v
LoopbackIPCPortAsNumber	DNSCommon.c	616;"	d	file:
MAC	mDNSEmbeddedAPI.h	/^	mDNSEthAddr     MAC;$/;"	m	struct:NetworkInterfaceInfo_struct
MAX_DOMAIN_LABEL	mDNSEmbeddedAPI.h	1305;"	d
MAX_DOMAIN_NAME	mDNSEmbeddedAPI.h	1309;"	d
MAX_ESCAPED_DOMAIN_LABEL	mDNSEmbeddedAPI.h	1326;"	d
MAX_ESCAPED_DOMAIN_NAME	mDNSEmbeddedAPI.h	1327;"	d
MAX_PROXY_RECORDS	mDNSEmbeddedAPI.h	2700;"	d
MAX_REVERSE_MAPPING_NAME	mDNSEmbeddedAPI.h	1335;"	d
MAX_REVERSE_MAPPING_NAME_V4	mDNSEmbeddedAPI.h	1333;"	d
MAX_REVERSE_MAPPING_NAME_V6	mDNSEmbeddedAPI.h	1334;"	d
MAX_UCAST_POLL_INTERVAL	uDNS.h	234;"	d
MAX_UCAST_UNANSWERED_QUERIES	uDNS.h	238;"	d
MD32_REG_T	DNSDigest.c	941;"	d	file:
MD5_BLOCK_BYTES	DNSDigest.c	278;"	d	file:
MD5_BLOCK_LONG	DNSDigest.c	279;"	d	file:
MD5_CBLOCK	DNSDigest.c	292;"	d	file:
MD5_CTX	DNSDigest.c	/^} MD5_CTX;$/;"	t	typeref:struct:MD5state_st	file:
MD5_DIGEST_LENGTH	DNSDigest.c	277;"	d	file:
MD5_DIGEST_LENGTH	DNSDigest.c	294;"	d	file:
MD5_Init	DNSDigest.c	/^int MD5_Init(MD5_CTX *c)$/;"	f
MD5_LBLOCK	DNSDigest.c	293;"	d	file:
MD5_LEN	DNSDigest.c	1371;"	d	file:
MD5_LEN	mDNSEmbeddedAPI.h	2284;"	d
MD5_LONG_LOG2	DNSDigest.c	304;"	d	file:
MD5state_st	DNSDigest.c	/^typedef struct MD5state_st$/;"	s	file:
MDNS_C99_VA_ARGS	mDNSDebug.h	219;"	d
MDNS_C99_VA_ARGS	mDNSDebug.h	222;"	d
MDNS_C99_VA_ARGS	mDNSDebug.h	227;"	d
MDNS_C99_VA_ARGS	mDNSDebug.h	231;"	d
MDNS_C99_VA_ARGS	mDNSDebug.h	235;"	d
MDNS_CHECK_PRINTF_STYLE_FUNCTIONS	mDNSDebug.h	180;"	d
MDNS_GNU_VA_ARGS	mDNSDebug.h	220;"	d
MDNS_GNU_VA_ARGS	mDNSDebug.h	223;"	d
MDNS_GNU_VA_ARGS	mDNSDebug.h	228;"	d
MDNS_GNU_VA_ARGS	mDNSDebug.h	232;"	d
MDNS_GNU_VA_ARGS	mDNSDebug.h	236;"	d
MDNS_HAS_VA_ARG_MACROS	mDNSDebug.h	225;"	d
MDNS_HAS_VA_ARG_MACROS	mDNSDebug.h	229;"	d
MDNS_HAS_VA_ARG_MACROS	mDNSDebug.h	233;"	d
MDNS_HAS_VA_ARG_MACROS	mDNSDebug.h	237;"	d
MDNS_LOG_DEBUG	mDNSDebug.h	/^	MDNS_LOG_DEBUG,$/;"	e	enum:__anon65
MDNS_LOG_INFO	mDNSDebug.h	/^	MDNS_LOG_INFO,$/;"	e	enum:__anon65
MDNS_LOG_MSG	mDNSDebug.h	/^	MDNS_LOG_MSG,$/;"	e	enum:__anon65
MDNS_LOG_OPERATION	mDNSDebug.h	/^	MDNS_LOG_OPERATION,$/;"	e	enum:__anon65
MDNS_LOG_SPS	mDNSDebug.h	/^	MDNS_LOG_SPS,$/;"	e	enum:__anon65
MDNS_VERBOSE	nss_mdns.c	/^const int MDNS_VERBOSE = 0;$/;"	v
MPExpectingKA	mDNSEmbeddedAPI.h	/^	mDNSBool        MPExpectingKA;		\/\/ Multi-packet query handling: Set when we increment MPUnansweredQ; allows one KA$/;"	m	struct:CacheRecord_struct
MPLastUnansweredQT	mDNSEmbeddedAPI.h	/^	mDNSs32         MPLastUnansweredQT;	\/\/ Multi-packet query handling: Last time we incremented MPUnansweredQ$/;"	m	struct:CacheRecord_struct
MPUnansweredKA	mDNSEmbeddedAPI.h	/^	mDNSu32         MPUnansweredKA;		\/\/ Multi-packet query handling: Number of times we've seen this record in a KA list$/;"	m	struct:CacheRecord_struct
MPUnansweredQ	mDNSEmbeddedAPI.h	/^	mDNSu32         MPUnansweredQ;		\/\/ Multi-packet query handling: Number of times we've seen a query for this record$/;"	m	struct:CacheRecord_struct
MachineHasActiveIPv6	mDNS.c	/^mDNSlocal mDNSBool MachineHasActiveIPv6(mDNS *const m)$/;"	f
MainCallback	mDNSEmbeddedAPI.h	/^	mDNSCallback *MainCallback;$/;"	m	struct:mDNS_struct
MainContext	mDNSEmbeddedAPI.h	/^	void         *MainContext;$/;"	m	struct:mDNS_struct
MainLoop	PosixDaemon.c	/^mDNSlocal mStatus MainLoop(mDNS *m) \/\/ Loop until we quit.$/;"	f
MakeDomainLabelFromLiteralString	DNSCommon.c	/^mDNSexport mDNSBool MakeDomainLabelFromLiteralString(domainlabel *const label, const char *cstr)$/;"	f
MakeDomainNameFromDNSNameString	DNSCommon.c	/^mDNSexport mDNSu8 *MakeDomainNameFromDNSNameString(domainname *const name, const char *cstr)$/;"	f
MakeNegativeCacheRecord	mDNS.c	/^mDNSexport void MakeNegativeCacheRecord(mDNS *const m, CacheRecord *const cr,$/;"	f
MakeTCPConn	uDNS.c	/^mDNSlocal tcpInfo_t *MakeTCPConn(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
MarkedForDeletion	mDNSEmbeddedAPI.h	/^	mDNSBool   MarkedForDeletion;$/;"	m	struct:ClientTunnel
MatchDependentOn	mDNS.c	/^mDNSlocal mDNSBool MatchDependentOn(const mDNS *const m, const CacheRecord *const pktrr, const AuthRecord *const master)$/;"	f
MaxMsg	mDNSEmbeddedAPI.h	2577;"	d
MaxQuestionInterval	mDNS.c	3180;"	d	file:
MaxRDLength	mDNSEmbeddedAPI.h	/^	mDNSu16    MaxRDLength;	\/\/ Amount of storage allocated for rdata (usually sizeof(RDataBody))$/;"	m	struct:__anon37
MaxRDLength	mDNSEmbeddedAPI.h	/^	mDNSu16    MaxRDLength;	\/\/ Storage allocated for data (may be greater than InlineCacheRDSize if additional storage follows this object)$/;"	m	struct:__anon38
MaxUnansweredQueries	mDNS.c	1752;"	d	file:
MaxWidth	NetMonitor.c	585;"	d	file:
MaximumRDSize	mDNSEmbeddedAPI.h	1684;"	d
McastTxRx	mDNSEmbeddedAPI.h	/^	mDNSu8          McastTxRx;			\/\/ Send\/Receive multicast on this { InterfaceID, address family } ?$/;"	m	struct:NetworkInterfaceInfo_struct
MsgBuffer	mDNSEmbeddedAPI.h	/^	char MsgBuffer[MaxMsg];				\/\/ Temp storage used while building error log messages$/;"	m	struct:mDNS_struct
MulticastDNSPort	DNSCommon.c	/^mDNSexport const mDNSIPPort MulticastDNSPort       = { { MulticastDNSPortAsNumber       >> 8, MulticastDNSPortAsNumber       & 0xFF } };$/;"	v
MulticastDNSPortAsNumber	DNSCommon.c	615;"	d	file:
MulticastHostname	mDNSEmbeddedAPI.h	/^	domainname  MulticastHostname;		\/\/ Fully Qualified "dot-local" Host Name, e.g. "Foo.local."$/;"	m	struct:mDNS_struct
MustSendRecord	mDNS.c	5352;"	d	file:
NATErr_NetFail	mDNSEmbeddedAPI.h	/^	NATErr_NetFail = 3,$/;"	e	enum:__anon40
NATErr_None	mDNSEmbeddedAPI.h	/^	NATErr_None    = 0,$/;"	e	enum:__anon40
NATErr_Opcode	mDNSEmbeddedAPI.h	/^	NATErr_Opcode  = 5$/;"	e	enum:__anon40
NATErr_Refused	mDNSEmbeddedAPI.h	/^	NATErr_Refused = 2,$/;"	e	enum:__anon40
NATErr_Res	mDNSEmbeddedAPI.h	/^	NATErr_Res     = 4,$/;"	e	enum:__anon40
NATErr_Vers	mDNSEmbeddedAPI.h	/^	NATErr_Vers    = 1,$/;"	e	enum:__anon40
NATErr_t	mDNSEmbeddedAPI.h	/^typedef mDNSu16 NATErr_t;$/;"	t
NATLease	mDNSEmbeddedAPI.h	/^	mDNSu32                     NATLease;			\/\/ Requested lifetime in seconds (doesn't change)$/;"	m	struct:NATTraversalInfo_struct
NATMAP_DEFAULT_LEASE	mDNSEmbeddedAPI.h	1782;"	d
NATMAP_INIT_RETRY	mDNSEmbeddedAPI.h	1781;"	d
NATMAP_MAX_RETRY_INTERVAL	mDNSEmbeddedAPI.h	1779;"	d
NATMAP_MIN_RETRY_INTERVAL	mDNSEmbeddedAPI.h	1780;"	d
NATMAP_VERS	mDNSEmbeddedAPI.h	1783;"	d
NATMcastRecvskt	mDNSEmbeddedAPI.h	/^	UDPSocket        *NATMcastRecvskt;			\/\/ For receiving NAT-PMP AddrReply multicasts from router on port 5350$/;"	m	struct:mDNS_struct
NATOp_AddrRequest	mDNSEmbeddedAPI.h	/^	NATOp_AddrRequest    = 0,$/;"	e	enum:__anon39
NATOp_AddrResponse	mDNSEmbeddedAPI.h	/^	NATOp_AddrResponse   = 0x80 | 0,$/;"	e	enum:__anon39
NATOp_MapTCP	mDNSEmbeddedAPI.h	/^	NATOp_MapTCP         = 2,$/;"	e	enum:__anon39
NATOp_MapTCPResponse	mDNSEmbeddedAPI.h	/^	NATOp_MapTCPResponse = 0x80 | 2,$/;"	e	enum:__anon39
NATOp_MapUDP	mDNSEmbeddedAPI.h	/^	NATOp_MapUDP         = 1,$/;"	e	enum:__anon39
NATOp_MapUDPResponse	mDNSEmbeddedAPI.h	/^	NATOp_MapUDPResponse = 0x80 | 1,$/;"	e	enum:__anon39
NATOp_t	mDNSEmbeddedAPI.h	/^	} NATOp_t;$/;"	t	typeref:enum:__anon39
NATPMPAnnouncementPort	DNSCommon.c	/^mDNSexport const mDNSIPPort NATPMPAnnouncementPort = { { NATPMPAnnouncementPortAsNumber >> 8, NATPMPAnnouncementPortAsNumber & 0xFF } };$/;"	v
NATPMPAnnouncementPortAsNumber	DNSCommon.c	612;"	d	file:
NATPMPPort	DNSCommon.c	/^mDNSexport const mDNSIPPort NATPMPPort             = { { NATPMPPortAsNumber             >> 8, NATPMPPortAsNumber             & 0xFF } };$/;"	v
NATPMPPortAsNumber	DNSCommon.c	613;"	d	file:
NATSetNextRenewalTime	uDNS.c	/^mDNSlocal void NATSetNextRenewalTime(mDNS *const m, NATTraversalInfo *n)$/;"	f
NATTraversalClientCallback	mDNSEmbeddedAPI.h	/^typedef void (*NATTraversalClientCallback)(mDNS *m, NATTraversalInfo *n);$/;"	t
NATTraversalInfo	mDNSEmbeddedAPI.h	/^typedef struct NATTraversalInfo_struct NATTraversalInfo;$/;"	t	typeref:struct:NATTraversalInfo_struct
NATTraversalInfo_struct	mDNSEmbeddedAPI.h	/^struct NATTraversalInfo_struct$/;"	s
NATTraversals	mDNSEmbeddedAPI.h	/^	NATTraversalInfo *NATTraversals;$/;"	m	struct:mDNS_struct
NATinfo	mDNSEmbeddedAPI.h	/^	NATTraversalInfo  NATinfo;$/;"	m	struct:ServiceRecordSet_struct
NO_HINFO	mDNS.c	1554;"	d	file:
NR_AdditionalTo	mDNSEmbeddedAPI.h	/^	AuthRecord     *NR_AdditionalTo;	\/\/ Set if this record was selected by virtue of being additional to another$/;"	m	struct:AuthRecord_struct
NR_AnswerTo	mDNSEmbeddedAPI.h	/^	const mDNSu8   *NR_AnswerTo;		\/\/ Set if this record was selected by virtue of being a direct answer to a question$/;"	m	struct:AuthRecord_struct
NSIPCPort	DNSCommon.c	/^mDNSexport const mDNSIPPort NSIPCPort              = { { NSIPCPortAsNumber              >> 8, NSIPCPortAsNumber              & 0xFF } };$/;"	v
NSIPCPortAsNumber	DNSCommon.c	611;"	d	file:
NSSCallback	mDNS.c	/^mDNSlocal void NSSCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
NToH16	DNSDigest.c	/^mDNSlocal mDNSu16 NToH16(mDNSu8 * bytes)$/;"	f
NToH32	DNSDigest.c	/^mDNSlocal mDNSu32 NToH32(mDNSu8 * bytes)$/;"	f
NameCallback	Identify.c	/^mDNSlocal void NameCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
NetWake	mDNSEmbeddedAPI.h	/^	mDNSu8          NetWake;			\/\/ Set if Wake-On-Magic-Packet is enabled on this interface$/;"	m	struct:NetworkInterfaceInfo_struct
NetWakeBrowse	mDNSEmbeddedAPI.h	/^	DNSQuestion     NetWakeBrowse;$/;"	m	struct:NetworkInterfaceInfo_struct
NetWakeResolve	mDNS.c	/^mDNSlocal void NetWakeResolve(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
NetWakeResolve	mDNSEmbeddedAPI.h	/^	DNSQuestion     NetWakeResolve[3];	\/\/ For fault-tolerance, we try up to three Sleep Proxies$/;"	m	struct:NetworkInterfaceInfo_struct
NetworkInterfaceInfo	mDNSEmbeddedAPI.h	/^typedef struct NetworkInterfaceInfo_struct NetworkInterfaceInfo;$/;"	t	typeref:struct:NetworkInterfaceInfo_struct
NetworkInterfaceInfo_struct	mDNSEmbeddedAPI.h	/^struct NetworkInterfaceInfo_struct$/;"	s
NewLocalOnlyQuestions	mDNSEmbeddedAPI.h	/^	DNSQuestion *NewLocalOnlyQuestions;	\/\/ Fresh local-only questions not yet answered$/;"	m	struct:mDNS_struct
NewLocalRecords	mDNSEmbeddedAPI.h	/^	AuthRecord *NewLocalRecords;		\/\/ Fresh local-only records not yet delivered to local-only questions$/;"	m	struct:mDNS_struct
NewQuestions	mDNSEmbeddedAPI.h	/^	DNSQuestion *NewQuestions;			\/\/ Fresh questions not yet answered from cache$/;"	m	struct:mDNS_struct
NewRData	mDNSEmbeddedAPI.h	/^	RData          *NewRData;			\/\/ Set if we are updating this record with new rdata$/;"	m	struct:AuthRecord_struct
NewResult	mDNSEmbeddedAPI.h	/^	mStatus                     NewResult;			\/\/ New error code; will be copied to Result just prior to invoking callback$/;"	m	struct:NATTraversalInfo_struct
Next	mDNSPosix.c	/^	struct  PosixEventSource	*Next;$/;"	m	struct:PosixEventSource	typeref:struct:PosixEventSource::PosixEventSource	file:
NextCacheCheck	mDNSEmbeddedAPI.h	/^	mDNSs32  NextCacheCheck;			\/\/ Next time to refresh cache record before it expires$/;"	m	struct:mDNS_struct
NextInCFList	mDNSEmbeddedAPI.h	/^	CacheRecord    *NextInCFList;		\/\/ Set if this is in the list of records we just received with the cache flush bit set$/;"	m	struct:CacheRecord_struct
NextInDQList	mDNSEmbeddedAPI.h	/^	DNSQuestion          *NextInDQList;$/;"	m	struct:DNSQuestion_struct
NextInKAList	mDNSEmbeddedAPI.h	/^	CacheRecord    *NextInKAList;		\/\/ Link to the next element in the chain of known answers to send$/;"	m	struct:CacheRecord_struct
NextRequiredQuery	mDNSEmbeddedAPI.h	/^	mDNSs32         NextRequiredQuery;	\/\/ In platform time units$/;"	m	struct:CacheRecord_struct
NextResponse	mDNSEmbeddedAPI.h	/^	AuthRecord     *NextResponse;		\/\/ Link to the next element in the chain of responses to generate$/;"	m	struct:AuthRecord_struct
NextSPSAttempt	mDNSEmbeddedAPI.h	/^	mDNSs32         NextSPSAttempt;		\/\/ -1 if we're not currently attempting to register with any Sleep Proxy$/;"	m	struct:NetworkInterfaceInfo_struct
NextSPSAttemptTime	mDNSEmbeddedAPI.h	/^	mDNSs32         NextSPSAttemptTime;$/;"	m	struct:NetworkInterfaceInfo_struct
NextSRVUpdate	mDNSEmbeddedAPI.h	/^	mDNSs32           NextSRVUpdate;        \/\/ Time to perform delayed update$/;"	m	struct:mDNS_struct
NextScheduledEvent	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledEvent;		\/\/ Derived from values below$/;"	m	struct:mDNS_struct
NextScheduledNATOp	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledNATOp;		\/\/ Next time to send NAT-traversal packets$/;"	m	struct:mDNS_struct
NextScheduledProbe	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledProbe;		\/\/ Next time to probe for new authoritative record$/;"	m	struct:mDNS_struct
NextScheduledQuery	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledQuery;		\/\/ Next time to send query in its exponential backoff sequence$/;"	m	struct:mDNS_struct
NextScheduledResponse	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledResponse;		\/\/ Next time to send authoritative record(s) in responses$/;"	m	struct:mDNS_struct
NextScheduledSPRetry	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledSPRetry;		\/\/ Time next sleep proxy registration action is required.$/;"	m	struct:mDNS_struct
NextScheduledSPS	mDNSEmbeddedAPI.h	/^	mDNSs32  NextScheduledSPS;			\/\/ Next time to purge expiring Sleep Proxy records$/;"	m	struct:mDNS_struct
NextUpdateCredit	mDNSEmbeddedAPI.h	/^	mDNSs32         NextUpdateCredit;	\/\/ Time next token is added to bucket$/;"	m	struct:AuthRecord_struct
NextuDNSEvent	mDNSEmbeddedAPI.h	/^	mDNSs32           NextuDNSEvent;		\/\/ uDNS next event$/;"	m	struct:mDNS_struct
Nh	DNSDigest.c	/^	mDNSu32 Nl,Nh;$/;"	m	struct:MD5state_st	file:
Nl	DNSDigest.c	/^	mDNSu32 Nl,Nh;$/;"	m	struct:MD5state_st	file:
NoAnswer	mDNSEmbeddedAPI.h	/^	mDNSu8                NoAnswer;			\/\/ Set if we want to suppress answers until tunnel setup has completed$/;"	m	struct:DNSQuestion_struct
NoAnswer_Fail	mDNSEmbeddedAPI.h	/^enum { NoAnswer_Normal = 0, NoAnswer_Suspended = 1, NoAnswer_Fail = 2 };$/;"	e	enum:__anon51
NoAnswer_Normal	mDNSEmbeddedAPI.h	/^enum { NoAnswer_Normal = 0, NoAnswer_Suspended = 1, NoAnswer_Fail = 2 };$/;"	e	enum:__anon51
NoAnswer_Suspended	mDNSEmbeddedAPI.h	/^enum { NoAnswer_Normal = 0, NoAnswer_Suspended = 1, NoAnswer_Fail = 2 };$/;"	e	enum:__anon51
NoCacheAnswer	mDNS.c	/^mDNSlocal void NoCacheAnswer(mDNS *const m, CacheRecord *rr)$/;"	f
NoSuchServiceCallback	ProxyResponder.c	/^mDNSlocal void NoSuchServiceCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
NoTestQuery	uDNS.c	/^mDNSlocal mDNSBool NoTestQuery(DNSQuestion *q)$/;"	f
NonZeroTime	mDNSEmbeddedAPI.h	/^mDNSinline mDNSs32 NonZeroTime(mDNSs32 t) { if (t) return(t); else return(1); }$/;"	f
NormalMaxDNSMessageData	mDNSEmbeddedAPI.h	1386;"	d
NotAnInteger	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 2]; mDNSu16 NotAnInteger; } mDNSOpaque16;$/;"	m	union:__anon18
NotAnInteger	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 4]; mDNSu32 NotAnInteger; } mDNSOpaque32;$/;"	m	union:__anon19
NoteSignal	mDNSPosix.c	/^mDNSlocal void	NoteSignal(int signum)$/;"	f
NotifySD	mDNSPosix.c	/^	int	NotifySD;$/;"	m	struct:IfChangeRec	file:
NumAAAA	Identify.c	/^static volatile int NumAnswers, NumAddr, NumAAAA, NumHINFO;$/;"	v	file:
NumAdditionals	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumAddr	Identify.c	/^static volatile int NumAnswers, NumAddr, NumAAAA, NumHINFO;$/;"	v	file:
NumAnswers	Identify.c	/^static volatile int NumAnswers, NumAddr, NumAAAA, NumHINFO;$/;"	v	file:
NumAnswers	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumCacheRecordsForInterfaceID	DNSCommon.c	/^mDNSexport mDNSu32 NumCacheRecordsForInterfaceID(const mDNS *const m, mDNSInterfaceID id)$/;"	f
NumFailedProbes	mDNSEmbeddedAPI.h	/^	mDNSu32 NumFailedProbes;$/;"	m	struct:mDNS_struct
NumGoodbyes	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumHINFO	Identify.c	/^static volatile int NumAnswers, NumAddr, NumAAAA, NumHINFO;$/;"	v	file:
NumLegacy	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumPktB	NetMonitor.c	/^static int NumPktQ, NumPktL, NumPktR, NumPktB;	\/\/ Query\/Legacy\/Response\/Bad$/;"	v	file:
NumPktL	NetMonitor.c	/^static int NumPktQ, NumPktL, NumPktR, NumPktB;	\/\/ Query\/Legacy\/Response\/Bad$/;"	v	file:
NumPktQ	NetMonitor.c	/^static int NumPktQ, NumPktL, NumPktR, NumPktB;	\/\/ Query\/Legacy\/Response\/Bad$/;"	v	file:
NumPktR	NetMonitor.c	/^static int NumPktQ, NumPktL, NumPktR, NumPktB;	\/\/ Query\/Legacy\/Response\/Bad$/;"	v	file:
NumProbes	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumQueries	NetMonitor.c	/^	mDNSu32    NumQueries;$/;"	m	struct:__anon6	file:
NumQuestions	NetMonitor.c	/^static int NumProbes, NumGoodbyes, NumQuestions, NumLegacy, NumAnswers, NumAdditionals;$/;"	v	file:
NumSubTypes	mDNSEmbeddedAPI.h	/^	mDNSu32              NumSubTypes;$/;"	m	struct:ServiceRecordSet_struct
OPBanner	NetMonitor.c	217;"	d	file:
OP_NumTypes	NetMonitor.c	/^	OP_NumTypes = 6$/;"	e	enum:__anon4	file:
OP_answer	NetMonitor.c	/^	OP_answer       = 3,$/;"	e	enum:__anon4	file:
OP_browsea	NetMonitor.c	/^	OP_browsea      = 3,$/;"	e	enum:__anon4	file:
OP_browsegroup	NetMonitor.c	/^	OP_browsegroup  = 2,$/;"	e	enum:__anon4	file:
OP_browseq	NetMonitor.c	/^	OP_browseq      = 2,$/;"	e	enum:__anon4	file:
OP_goodbye	NetMonitor.c	/^	OP_goodbye      = 1,$/;"	e	enum:__anon4	file:
OP_probe	NetMonitor.c	/^	OP_probe        = 0,$/;"	e	enum:__anon4	file:
OP_query	NetMonitor.c	/^	OP_query        = 2,$/;"	e	enum:__anon4	file:
OP_resolvea	NetMonitor.c	/^	OP_resolvea     = 5,$/;"	e	enum:__anon4	file:
OP_resolvegroup	NetMonitor.c	/^	OP_resolvegroup = 4,$/;"	e	enum:__anon4	file:
OP_resolveq	NetMonitor.c	/^	OP_resolveq     = 4,$/;"	e	enum:__anon4	file:
OffsetAddToHead	GenLinkedList.c	/^void		OffsetAddToHead( GenLinkedOffsetList *pList, void *elem)$/;"	f
OffsetAddToTail	GenLinkedList.c	/^void		OffsetAddToTail( GenLinkedOffsetList *pList, void *elem)$/;"	f
OffsetRemoveFromList	GenLinkedList.c	/^int		OffsetRemoveFromList( GenLinkedOffsetList *pList, void *elem)$/;"	f
OffsetReplaceElem	GenLinkedList.c	/^int			OffsetReplaceElem( GenLinkedOffsetList *pList, void *elemInList, void *newElem)$/;"	f
OpenIfNotifySocket	mDNSPosix.c	/^mDNSlocal mStatus OpenIfNotifySocket(int *pFD)$/;"	f
OrigRDLen	mDNSEmbeddedAPI.h	/^	mDNSu16 OrigRDLen;		\/\/ previously registered, being deleted$/;"	m	struct:AuthRecord_struct
OrigRData	mDNSEmbeddedAPI.h	/^	RData *OrigRData;$/;"	m	struct:AuthRecord_struct
OwnerOptData	mDNSEmbeddedAPI.h	/^	} OwnerOptData;$/;"	t	typeref:struct:__anon33
PRIVATE_LLQ_SERVICE_TYPE	uDNS.c	/^mDNSlocal const domainname *PRIVATE_LLQ_SERVICE_TYPE    = (const domainname*)"\\x0C_dns-llq-tls"    "\\x04_tcp";$/;"	v
PRIVATE_QUERY_SERVICE_TYPE	uDNS.c	/^mDNSlocal const domainname *PRIVATE_QUERY_SERVICE_TYPE  = (const domainname*)"\\x0E_dns-query-tls"  "\\x04_tcp";$/;"	v
PRIVATE_UPDATE_SERVICE_TYPE	uDNS.c	/^mDNSlocal const domainname *PRIVATE_UPDATE_SERVICE_TYPE = (const domainname*)"\\x0F_dns-update-tls" "\\x04_tcp";$/;"	v
PROC_IFINET6_PATH	mDNSUNP.h	157;"	d
PUBLIC_LLQ_SERVICE_TYPE	uDNS.c	/^mDNSlocal const domainname *PUBLIC_LLQ_SERVICE_TYPE     = (const domainname*)"\\x08_dns-llq"        "\\x04_udp";$/;"	v
PUBLIC_UPDATE_SERVICE_TYPE	uDNS.c	/^mDNSlocal const domainname *PUBLIC_UPDATE_SERVICE_TYPE  = (const domainname*)"\\x0B_dns-update"     "\\x04_udp";$/;"	v
PacketRRConflict	mDNS.c	/^mDNSlocal mDNSBool PacketRRConflict(const mDNS *const m, const AuthRecord *const our, const CacheRecord *const pktrr)$/;"	f
PacketRRMatchesSignature	mDNS.c	/^mDNSlocal mDNSBool PacketRRMatchesSignature(const CacheRecord *const pktrr, const AuthRecord *const authrr)$/;"	f
Pad64	DNSDigest.c	/^static const char Pad64 = '=';$/;"	v	file:
ParseArguments	Client.c	/^static void ParseArguments(int argc, char **argv)$/;"	f	file:
ParseArguments	Responder.c	/^static void ParseArguments(int argc, char **argv)$/;"	f	file:
ParseCmdLinArgs	PosixDaemon.c	/^mDNSlocal void ParseCmdLinArgs(int argc, char **argv)$/;"	f
ParseDNSServers	mDNSPosix.c	/^mDNSexport int ParseDNSServers(mDNS *m, const char *filePath)$/;"	f
ParseTSIGError	uDNS.c	/^mDNSlocal mStatus ParseTSIGError(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end, const domainname *const displayname)$/;"	f
PenalizeDNSServer	uDNS.c	/^mDNSexport void PenalizeDNSServer(mDNS *const m, DNSQuestion *q, mDNSBool QueryFail)$/;"	f
PenaltyTimeForServer	mDNS.c	/^mDNSinline mDNSs32 PenaltyTimeForServer(mDNS *m, DNSServer *server)$/;"	f
PktNum	mDNSEmbeddedAPI.h	/^	mDNSs32  PktNum;					\/\/ Unique sequence number assigned to each received packet$/;"	m	struct:mDNS_struct
PlatformStorage	Client.c	/^static mDNS_PlatformSupport PlatformStorage;  \/\/ Stores this platform's globals$/;"	v	file:
PlatformStorage	Identify.c	/^static mDNS_PlatformSupport PlatformStorage;  \/\/ Stores this platform's globals$/;"	v	file:
PlatformStorage	NetMonitor.c	/^static mDNS_PlatformSupport PlatformStorage;	\/\/ Stores this platform's globals$/;"	v	file:
PlatformStorage	PosixDaemon.c	/^static mDNS_PlatformSupport PlatformStorage;$/;"	v	file:
PlatformStorage	ProxyResponder.c	/^static mDNS_PlatformSupport PlatformStorage;  \/\/ Stores this platform's globals$/;"	v	file:
PlatformStorage	Responder.c	/^static mDNS_PlatformSupport PlatformStorage;  \/\/ Stores this platform's globals$/;"	v	file:
Port	mDNSEmbeddedAPI.h	/^	mDNSIPPort        Port;				\/\/ router port$/;"	m	struct:tcpLNTInfo_struct
Port	mDNSEmbeddedAPI.h	/^	mDNSIPPort        Port;$/;"	m	struct:tcpInfo_t
Port	mDNSEmbeddedAPI.h	/^	mDNSIPPort       Port;				\/\/ Discovered result: Update port, query port, or LLQ port from SRV record$/;"	m	struct:ZoneData_struct
PosixErrorToStatus	mDNSPosix.c	222;"	d	file:
PosixEventSource	mDNSPosix.c	/^struct PosixEventSource$/;"	s	file:
PosixEventSource	mDNSPosix.c	/^typedef struct PosixEventSource	PosixEventSource;$/;"	t	typeref:struct:PosixEventSource	file:
PosixNetworkInterface	mDNSPosix.h	/^struct PosixNetworkInterface$/;"	s
PosixNetworkInterface	mDNSPosix.h	/^typedef struct PosixNetworkInterface PosixNetworkInterface;$/;"	t	typeref:struct:PosixNetworkInterface
PosixService	Responder.c	/^struct PosixService {$/;"	s	file:
PosixService	Responder.c	/^typedef struct PosixService PosixService;$/;"	t	typeref:struct:PosixService	file:
PrimaryMAC	mDNSEmbeddedAPI.h	/^	mDNSEthAddr PrimaryMAC;				\/\/ Used as unique host ID$/;"	m	struct:mDNS_struct
PrintNetLinkMsg	mDNSPosix.c	/^mDNSlocal void		PrintNetLinkMsg(const struct nlmsghdr *pNLMsg)$/;"	f
PrintRoutingSocketMsg	mDNSPosix.c	/^mDNSlocal void		PrintRoutingSocketMsg(const struct ifa_msghdr *pRSMsg)$/;"	f
PrintUsage	Client.c	/^static void PrintUsage()$/;"	f	file:
PrintUsage	Responder.c	/^static void PrintUsage()$/;"	f	file:
Private	mDNSEmbeddedAPI.h	/^	mDNSBool          Private;					\/\/ If zone is private, DNS updates may have to be encrypted to prevent eavesdropping$/;"	m	struct:ServiceRecordSet_struct
Private	mDNSEmbeddedAPI.h	/^	mDNSBool     Private;		\/\/ If zone is private, DNS updates may have to be encrypted to prevent eavesdropping$/;"	m	struct:AuthRecord_struct
PrivateDNSPort	DNSCommon.c	/^mDNSexport const mDNSIPPort PrivateDNSPort         = { { PrivateDNSPortAsNumber         >> 8, PrivateDNSPortAsNumber         & 0xFF } };$/;"	v
PrivateDNSPortAsNumber	DNSCommon.c	618;"	d	file:
PrivateData	dns_sd.h	/^typedef union _TXTRecordRef_t { char PrivateData[16]; char *ForceNaturalAlignment; } TXTRecordRef;$/;"	m	union:_TXTRecordRef_t
PrivateQueryGotZoneData	uDNS.c	/^mDNSlocal void PrivateQueryGotZoneData(mDNS *const m, mStatus err, const ZoneData *zoneInfo)$/;"	f
ProbeCount	mDNSEmbeddedAPI.h	/^	mDNSu8          ProbeCount;			\/\/ Number of probes remaining before this record is valid (kDNSRecordTypeUnique)$/;"	m	struct:AuthRecord_struct
ProbeFailTime	mDNSEmbeddedAPI.h	/^	mDNSs32 ProbeFailTime;$/;"	m	struct:mDNS_struct
ProcessQuery	mDNS.c	/^mDNSlocal mDNSu8 *ProcessQuery(mDNS *const m, const DNSMessage *const query, const mDNSu8 *const end,$/;"	f
ProcessRoutingNotification	mDNSPosix.c	/^mDNSlocal mDNSu32		ProcessRoutingNotification(int sd)$/;"	f
ProcessUnicastResponse	NetMonitor.c	/^mDNSlocal void ProcessUnicastResponse(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *end, const mDNSAddr *srcaddr, const mDNSInterfaceID InterfaceID)$/;"	f
ProgramName	Client.c	/^mDNSexport const char ProgramName[] = "mDNSClientPosix";$/;"	v
ProgramName	Identify.c	/^mDNSexport const char ProgramName[] = "mDNSIdentify";$/;"	v
ProgramName	NetMonitor.c	/^mDNSexport const char ProgramName[] = "mDNSNetMonitor";$/;"	v
ProgramName	ProxyResponder.c	/^mDNSexport const char ProgramName[] = "mDNSProxyResponderPosix";$/;"	v
ProgramName	Responder.c	/^mDNSexport const char ProgramName[] = "mDNSResponderPosix";$/;"	v
Protocol	mDNSEmbeddedAPI.h	/^	mDNSu8                      Protocol;			\/\/ NATOp_MapUDP or NATOp_MapTCP, or zero if just requesting the external IP address$/;"	m	struct:NATTraversalInfo_struct
PrototypeSPSName	mDNSEmbeddedAPI.h	3443;"	d
ProxyHost	ProxyResponder.c	/^	} ProxyHost;$/;"	t	typeref:struct:__anon15	file:
ProxyRecords	mDNSEmbeddedAPI.h	/^	int               ProxyRecords;				\/\/ Total number of records we're holding as proxy$/;"	m	struct:mDNS_struct
PurgeOrReconfirmCacheRecord	mDNS.c	/^mDNSlocal void PurgeOrReconfirmCacheRecord(mDNS *const m, CacheRecord *cr, const DNSServer * const ptr, mDNSBool lameduck)$/;"	f
PutRR_OS	DNSCommon.h	351;"	d
PutRR_OS_TTL	DNSCommon.h	348;"	d
PutResourceRecord	DNSCommon.h	344;"	d
PutResourceRecordTTL	DNSCommon.h	338;"	d
PutResourceRecordTTLJumbo	DNSCommon.h	341;"	d
PutResourceRecordTTLWithLimit	DNSCommon.c	/^mDNSexport mDNSu8 *PutResourceRecordTTLWithLimit(DNSMessage *const msg, mDNSu8 *ptr, mDNSu16 *count, ResourceRecord *rr, mDNSu32 ttl, const mDNSu8 *limit)$/;"	f
QC_add	mDNSEmbeddedAPI.h	/^typedef enum { QC_rmv = 0, QC_add = 1, QC_addnocache = 2 } QC_result;$/;"	e	enum:__anon52
QC_addnocache	mDNSEmbeddedAPI.h	/^typedef enum { QC_rmv = 0, QC_add = 1, QC_addnocache = 2 } QC_result;$/;"	e	enum:__anon52
QC_result	mDNSEmbeddedAPI.h	/^typedef enum { QC_rmv = 0, QC_add = 1, QC_addnocache = 2 } QC_result;$/;"	t	typeref:enum:__anon52
QC_rmv	mDNSEmbeddedAPI.h	/^typedef enum { QC_rmv = 0, QC_add = 1, QC_addnocache = 2 } QC_result;$/;"	e	enum:__anon52
QueryFlags	DNSCommon.c	/^mDNSexport const mDNSOpaque16 QueryFlags      = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery,                0 } };$/;"	v
QuestionCallback	mDNSEmbeddedAPI.h	/^	mDNSQuestionCallback *QuestionCallback;$/;"	m	struct:DNSQuestion_struct
QuestionContext	mDNSEmbeddedAPI.h	/^	void                 *QuestionContext;$/;"	m	struct:DNSQuestion_struct
QuestionIntervalStep	uDNS.h	243;"	d
QuestionIntervalStep2	uDNS.h	244;"	d
QuestionIntervalStep3	uDNS.h	245;"	d
Question_uDNS	mDNSEmbeddedAPI.h	2062;"	d
Questions	mDNSEmbeddedAPI.h	/^	DNSQuestion *Questions;				\/\/ List of all registered questions, active and inactive$/;"	m	struct:mDNS_struct
QueuedRDLen	mDNSEmbeddedAPI.h	/^	mDNSu16 QueuedRDLen;	\/\/ pending operation (re-transmitting if necessary) THEN register the queued update$/;"	m	struct:AuthRecord_struct
QueuedRData	mDNSEmbeddedAPI.h	/^	RData *QueuedRData;$/;"	m	struct:AuthRecord_struct
R0	DNSDigest.c	982;"	d	file:
R1	DNSDigest.c	987;"	d	file:
R2	DNSDigest.c	992;"	d	file:
R3	DNSDigest.c	997;"	d	file:
RData	mDNSEmbeddedAPI.h	/^	} RData;$/;"	t	typeref:struct:__anon37
RDataBody	mDNSEmbeddedAPI.h	/^	} RDataBody;$/;"	t	typeref:union:__anon35
RDataBody2	mDNSEmbeddedAPI.h	/^	} RDataBody2;$/;"	t	typeref:union:__anon36
RDataHashValue	DNSCommon.c	/^mDNSexport mDNSu32 RDataHashValue(const ResourceRecord *const rr)$/;"	f
RData_small	mDNSEmbeddedAPI.h	/^	} RData_small;$/;"	t	typeref:struct:__anon38
RESPONSE_WINDOW	uDNS.h	237;"	d
RESTART_GOODBYE_DELAY	uDNS.h	231;"	d
REVERSE_FETCH32	DNSDigest.c	585;"	d	file:
REVERSE_FETCH32	DNSDigest.c	591;"	d	file:
ROTATE	DNSDigest.c	506;"	d	file:
ROTATE	DNSDigest.c	512;"	d	file:
ROTATE	DNSDigest.c	515;"	d	file:
ROTATE	DNSDigest.c	517;"	d	file:
ROTATE	DNSDigest.c	528;"	d	file:
ROTATE	DNSDigest.c	537;"	d	file:
ROTATE	DNSDigest.c	614;"	d	file:
RRAssertsNonexistence	DNSCommon.h	303;"	d
RRDisplayString	mDNSEmbeddedAPI.h	3104;"	d
RRExpireTime	mDNS.c	1750;"	d	file:
RRSet	mDNSEmbeddedAPI.h	/^	AuthRecord     *RRSet;				\/\/ This unique record is part of an RRSet$/;"	m	struct:AuthRecord_struct
RRTypeAnswersQuestionType	DNSCommon.h	302;"	d
RRTypeIsAddressType	mDNS.c	1719;"	d	file:
RR_A	ProxyResponder.c	/^	AuthRecord RR_A;		\/\/ 'A' (address) record for our ".local" name$/;"	m	struct:__anon15	file:
RR_A	mDNSEmbeddedAPI.h	/^	AuthRecord RR_A;					\/\/ 'A' or 'AAAA' (address) record for our ".local" name$/;"	m	struct:NetworkInterfaceInfo_struct
RR_ADV	mDNSEmbeddedAPI.h	/^	AuthRecord           RR_ADV;	\/\/ e.g. _services._dns-sd._udp.local. PTR _printer._tcp.local.$/;"	m	struct:ServiceRecordSet_struct
RR_CACHE_SIZE	Client.c	108;"	d	file:
RR_CACHE_SIZE	Identify.c	99;"	d	file:
RR_CACHE_SIZE	PosixDaemon.c	110;"	d	file:
RR_HINFO	mDNSEmbeddedAPI.h	/^	AuthRecord RR_HINFO;$/;"	m	struct:NetworkInterfaceInfo_struct
RR_PTR	ProxyResponder.c	/^	AuthRecord RR_PTR;		\/\/ PTR (reverse lookup) record$/;"	m	struct:__anon15	file:
RR_PTR	mDNSEmbeddedAPI.h	/^	AuthRecord           RR_PTR;	\/\/ e.g. _printer._tcp.local.        PTR Name._printer._tcp.local.$/;"	m	struct:ServiceRecordSet_struct
RR_PTR	mDNSEmbeddedAPI.h	/^	AuthRecord RR_PTR;					\/\/ PTR (reverse lookup) record$/;"	m	struct:NetworkInterfaceInfo_struct
RR_SRV	mDNSEmbeddedAPI.h	/^	AuthRecord           RR_SRV;	\/\/ e.g. Name._printer._tcp.local.   SRV 0 0 port target$/;"	m	struct:ServiceRecordSet_struct
RR_TXT	mDNSEmbeddedAPI.h	/^	AuthRecord           RR_TXT;	\/\/ e.g. Name._printer._tcp.local.   TXT PrintQueueName$/;"	m	struct:ServiceRecordSet_struct
RandomQueryDelay	mDNSEmbeddedAPI.h	/^	mDNSs32  RandomQueryDelay;			\/\/ For de-synchronization of query packets on the wire$/;"	m	struct:mDNS_struct
RandomReconfirmDelay	mDNSEmbeddedAPI.h	/^	mDNSu32  RandomReconfirmDelay;		\/\/ For de-synchronization of reconfirmation queries on the wire$/;"	m	struct:mDNS_struct
ReadALine	Responder.c	/^static mDNSBool ReadALine(char *buf, size_t bufSize, FILE *fp)$/;"	f	file:
ReadDDNSSettingsFromConfFile	PlatformCommon.c	/^mDNSexport void ReadDDNSSettingsFromConfFile(mDNS *const m, const char *const filename, domainname *const hostname, domainname *const domain, mDNSBool *DomainDiscoveryDisabled)$/;"	f
RecentAnswerPkts	mDNSEmbeddedAPI.h	/^	mDNSu32               RecentAnswerPkts;	\/\/ Number of answers since the last time we sent this query$/;"	m	struct:DNSQuestion_struct
Reconfigure	PosixDaemon.c	/^static void Reconfigure(mDNS *m)$/;"	f	file:
ReconfirmAntecedents	mDNS.c	/^mDNSlocal void ReconfirmAntecedents(mDNS *const m, const domainname *const name, const mDNSu32 namehash, const int depth)$/;"	f
RecordCallback	mDNSEmbeddedAPI.h	/^	mDNSRecordCallback *RecordCallback;	\/\/ Callback function to call for state changes, and to free memory asynchronously on deregistration$/;"	m	struct:AuthRecord_struct
RecordContext	mDNSEmbeddedAPI.h	/^	void           *RecordContext;		\/\/ Context parameter for the callback function$/;"	m	struct:AuthRecord_struct
RecordDupSuppressInfo	mDNS.c	/^mDNSlocal int RecordDupSuppressInfo(DupSuppressInfo ds[DupSuppressInfoSize], mDNSs32 Time, mDNSInterfaceID InterfaceID, mDNSs32 Type)$/;"	f
RecordHostInfo	NetMonitor.c	/^mDNSlocal void RecordHostInfo(HostEntry *entry, const ResourceRecord *const pktrr)$/;"	f
RecordIsLocalDuplicate	mDNS.c	1970;"	d	file:
RecordLDT	mDNS.c	1968;"	d	file:
RecordProbeFailure	mDNS.c	/^mDNSlocal void RecordProbeFailure(mDNS *const m, const AuthRecord *const rr)$/;"	f
RecordRegistrationGotZoneData	uDNS.c	/^mDNSexport void RecordRegistrationGotZoneData(mDNS *const m, mStatus err, const ZoneData *zoneData)$/;"	f
RecordType	mDNSEmbeddedAPI.h	/^	mDNSu8           RecordType;		\/\/ See enum above$/;"	m	struct:__anon42
RecordUpdatedNiceLabel	PosixDaemon.c	/^mDNSexport void RecordUpdatedNiceLabel(mDNS *const m, mDNSs32 delay)$/;"	f
RecreateNATMappings	uDNS.c	/^mDNSexport void RecreateNATMappings(mDNS *const m)$/;"	f
RefreshCacheRecord	mDNS.c	/^mDNSlocal void RefreshCacheRecord(mDNS *const m, CacheRecord *rr, mDNSu32 ttl)$/;"	f
RegisterNoSuchService	ProxyResponder.c	/^mDNSlocal void RegisterNoSuchService(mDNS *m, AuthRecord *const rr, domainname *proxyhostname,$/;"	f
RegisterOneService	Responder.c	/^static mStatus RegisterOneService(const char *  richTextName, $/;"	f	file:
RegisterOurServices	Responder.c	/^static mStatus RegisterOurServices(void)$/;"	f	file:
RegisterQ	mDNSEmbeddedAPI.h	/^	DNSQuestion RegisterQ;$/;"	m	struct:SearchListElem
RegisterSearchDomains	mDNSEmbeddedAPI.h	/^	mDNSBool          RegisterSearchDomains;$/;"	m	struct:mDNS_struct
RegisterService	ProxyResponder.c	/^mDNSlocal void RegisterService(mDNS *m, ServiceRecordSet *recordset,$/;"	f
RegisterServicesInFile	Responder.c	/^static mStatus RegisterServicesInFile(const char *filePath)$/;"	f	file:
RegistrationCallback	Responder.c	/^static void RegistrationCallback(mDNS *const m, ServiceRecordSet *const thisRegistration, mStatus status)$/;"	f	file:
ReleaseCacheEntity	mDNS.c	/^mDNSlocal void ReleaseCacheEntity(mDNS *const m, CacheEntity *e)$/;"	f
ReleaseCacheGroup	mDNS.c	/^mDNSlocal void ReleaseCacheGroup(mDNS *const m, CacheGroup **cp)$/;"	f
ReleaseCacheRecord	mDNS.c	/^mDNSlocal void ReleaseCacheRecord(mDNS *const m, CacheRecord *r)$/;"	f
RemSpc	DNSCommon.c	718;"	d	file:
RemoveFromList	GenLinkedList.c	/^int		RemoveFromList( GenLinkedList *pList, void *elem)$/;"	f
RemoveLabelSuffix	DNSCommon.c	/^mDNSexport mDNSu32 RemoveLabelSuffix(domainlabel *name, mDNSBool RichText)$/;"	f
ReplaceElem	GenLinkedList.c	/^int			ReplaceElem( GenLinkedList *pList, void *elemInList, void *newElem)$/;"	f
Reply	mDNSEmbeddedAPI.h	/^	mDNSs8           *Reply;			\/\/ xml reply from router$/;"	m	struct:tcpLNTInfo_struct
ReqLease	mDNSEmbeddedAPI.h	/^	mDNSu32               ReqLease;			\/\/ seconds (relative)$/;"	m	struct:DNSQuestion_struct
Request	mDNSEmbeddedAPI.h	/^	mDNSs8           *Request;			\/\/ xml request to router$/;"	m	struct:tcpLNTInfo_struct
RequestUnicast	mDNSEmbeddedAPI.h	/^	mDNSu32               RequestUnicast;	\/\/ Non-zero if we want to send query with kDNSQClass_UnicastResponse bit set$/;"	m	struct:DNSQuestion_struct
RequestedPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort                  RequestedPort;		\/\/ Requested external port; may be updated with actual value assigned by gateway$/;"	m	struct:NATTraversalInfo_struct
RequireGoodbye	mDNSEmbeddedAPI.h	/^	mDNSu8          RequireGoodbye;		\/\/ Set if this RR has been announced on the wire and will require a goodbye packet$/;"	m	struct:AuthRecord_struct
ResetDNSServerPenalties	uDNS.c	/^mDNSexport void ResetDNSServerPenalties(mDNS *m)$/;"	f
ResolveSimultaneousProbe	mDNS.c	/^mDNSlocal void ResolveSimultaneousProbe(mDNS *const m, const DNSMessage *const query, const mDNSu8 *const end,$/;"	f
ResourceRecord	mDNSEmbeddedAPI.h	/^	} ResourceRecord;$/;"	t	typeref:struct:__anon42
ResourceRecordAnswersQuestion	DNSCommon.c	/^mDNSexport mDNSBool ResourceRecordAnswersQuestion(const ResourceRecord *const rr, const DNSQuestion *const q)$/;"	f
ResourceRecordIsValidAnswer	mDNS.c	1721;"	d	file:
ResourceRecordIsValidInterfaceAnswer	mDNS.c	1726;"	d	file:
ResourceRecords	mDNSEmbeddedAPI.h	/^	AuthRecord *ResourceRecords;$/;"	m	struct:mDNS_struct
ResponseFlags	DNSCommon.c	/^mDNSexport const mDNSOpaque16 ResponseFlags   = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_StdQuery | kDNSFlag0_AA, 0 } };$/;"	v
RestartARPProbing	mDNS.c	/^mDNSlocal void RestartARPProbing(mDNS *const m, AuthRecord *const rr)$/;"	f
RestartRecordGetZoneData	mDNS.c	/^mDNSlocal void RestartRecordGetZoneData(mDNS * const m)$/;"	f
Result	mDNSEmbeddedAPI.h	/^	mStatus                     Result;$/;"	m	struct:NATTraversalInfo_struct
RetrySPSRegistrations	mDNS.c	/^mDNSlocal void RetrySPSRegistrations(mDNS *const m)$/;"	f
ReturnIntermed	mDNSEmbeddedAPI.h	/^	mDNSBool              ReturnIntermed;	\/\/ Set by client to request callbacks for intermediate CNAME\/NXDOMAIN results$/;"	m	struct:DNSQuestion_struct
ReverseMap	mDNSEmbeddedAPI.h	/^	DNSQuestion       ReverseMap;           \/\/ Reverse-map query to find static hostname for service target$/;"	m	struct:mDNS_struct
ReverseMapDomainType	mDNS.c	/^mDNSlocal mDNSs32 ReverseMapDomainType(const domainname *const name)$/;"	f
Router	mDNSEmbeddedAPI.h	/^	mDNSAddr          Router;$/;"	m	struct:mDNS_struct
SPSAddr	mDNSEmbeddedAPI.h	/^	mDNSAddr        SPSAddr[3];$/;"	m	struct:NetworkInterfaceInfo_struct
SPSBrowseCallback	mDNSEmbeddedAPI.h	/^	mDNSQuestionCallback *SPSBrowseCallback;    \/\/ So the platform layer can do something useful with SPS browse results$/;"	m	struct:mDNS_struct
SPSMarginalPower	mDNSEmbeddedAPI.h	/^	mDNSu8            SPSMarginalPower;			\/\/ 10-99$/;"	m	struct:mDNS_struct
SPSMetric	mDNSEmbeddedAPI.h	3447;"	d
SPSPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort      SPSPort[3];$/;"	m	struct:NetworkInterfaceInfo_struct
SPSPortability	mDNSEmbeddedAPI.h	/^	mDNSu8            SPSPortability;			\/\/ 10-99$/;"	m	struct:mDNS_struct
SPSProxyListChanged	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID   SPSProxyListChanged;$/;"	m	struct:mDNS_struct
SPSRecordCallback	mDNS.c	/^mDNSlocal void SPSRecordCallback(mDNS *const m, AuthRecord *const ar, mStatus result)$/;"	f
SPSRecords	mDNSEmbeddedAPI.h	/^	ServiceRecordSet  SPSRecords;$/;"	m	struct:mDNS_struct
SPSSocket	mDNSEmbeddedAPI.h	/^	UDPSocket        *SPSSocket;$/;"	m	struct:mDNS_struct
SPSState	mDNSEmbeddedAPI.h	/^	mDNSu8            SPSState;					\/\/ 0 = off, 1 = running, 2 = shutting down, 3 = suspended during sleep$/;"	m	struct:mDNS_struct
SPSTotalPower	mDNSEmbeddedAPI.h	/^	mDNSu8            SPSTotalPower;			\/\/ 10-99$/;"	m	struct:mDNS_struct
SPSType	mDNSEmbeddedAPI.h	/^	mDNSu8            SPSType;					\/\/ 0 = off, 10-99 encodes desirability metric$/;"	m	struct:mDNS_struct
SRSUpdatePort	mDNSEmbeddedAPI.h	/^	mDNSIPPort        SRSUpdatePort;			\/\/ port on which server accepts dynamic updates$/;"	m	struct:ServiceRecordSet_struct
SRSUpdateServer	mDNSEmbeddedAPI.h	/^	mDNSAddr          SRSUpdateServer;			\/\/ primary name server for the record's zone  !!!KRS not technically correct to cache longer than TTL$/;"	m	struct:ServiceRecordSet_struct
SRVChanged	mDNSEmbeddedAPI.h	/^	mDNSBool          SRVChanged;				\/\/ temporarily deregistered service because its SRV target or port changed$/;"	m	struct:ServiceRecordSet_struct
SRVUpdateDeferred	mDNSEmbeddedAPI.h	/^	mDNSBool          SRVUpdateDeferred;		\/\/ do we need to change target or port once current operation completes?$/;"	m	struct:ServiceRecordSet_struct
SSDPPort	DNSCommon.c	/^mDNSexport const mDNSIPPort SSDPPort               = { { SSDPPortAsNumber               >> 8, SSDPPortAsNumber               & 0xFF } };$/;"	v
SSDPPortAsNumber	DNSCommon.c	609;"	d	file:
SSDPSocket	mDNSEmbeddedAPI.h	/^	UDPSocket        *SSDPSocket;               \/\/ For SSDP request\/response$/;"	m	struct:mDNS_struct
SSDPWANPPPConnection	mDNSEmbeddedAPI.h	/^	mDNSBool          SSDPWANPPPConnection;     \/\/ whether we should send the SSDP query for WANIPConnection or WANPPPConnection$/;"	m	struct:mDNS_struct
SSHPort	DNSCommon.c	/^mDNSexport const mDNSIPPort SSHPort                = { { SSHPortAsNumber                >> 8, SSHPortAsNumber                & 0xFF } };$/;"	v
SSHPortAsNumber	DNSCommon.c	607;"	d	file:
SSH_AsNumber	mDNS.c	9470;"	d	file:
STRINGIFY	DNSCommon.h	177;"	d
STRINGIFY_ARGUMENT_WITHOUT_EXPANSION	DNSCommon.h	176;"	d
SameDomainLabel	DNSCommon.c	/^mDNSexport mDNSBool SameDomainLabel(const mDNSu8 *a, const mDNSu8 *b)$/;"	f
SameDomainLabelCS	mDNSEmbeddedAPI.h	3021;"	d
SameDomainName	DNSCommon.c	/^mDNSexport mDNSBool SameDomainName(const domainname *const d1, const domainname *const d2)$/;"	f
SameDomainNameCS	DNSCommon.c	/^mDNSexport mDNSBool SameDomainNameCS(const domainname *const d1, const domainname *const d2)$/;"	f
SameNameRecordAnswersQuestion	DNSCommon.c	/^mDNSexport mDNSBool SameNameRecordAnswersQuestion(const ResourceRecord *const rr, const DNSQuestion *const q)$/;"	f
SameQTarget	mDNS.c	7275;"	d	file:
SameRDataBody	DNSCommon.c	/^mDNSexport mDNSBool SameRDataBody(const ResourceRecord *const r1, const RDataBody *const r2)$/;"	f
SameResourceRecordNameClassInterface	mDNS.c	/^mDNSlocal mDNSBool SameResourceRecordNameClassInterface(const AuthRecord *const r1, const AuthRecord *const r2)$/;"	f
SameResourceRecordSignature	mDNS.c	1763;"	d	file:
SearchForInterfaceByName	mDNSPosix.c	/^mDNSlocal PosixNetworkInterface *SearchForInterfaceByName(mDNS *const m, const char *intfName)$/;"	f
SearchList	uDNS.c	/^mDNSexport SearchListElem *SearchList = mDNSNULL;$/;"	v
SearchListElem	mDNSEmbeddedAPI.h	/^	} SearchListElem;$/;"	t	typeref:struct:SearchListElem
SearchListElem	mDNSEmbeddedAPI.h	/^typedef struct SearchListElem$/;"	s
SecondLabel	mDNSEmbeddedAPI.h	3030;"	d
SendARP	mDNS.c	/^mDNSlocal void SendARP(mDNS *const m, const mDNSu8 op, const AuthRecord *const rr,$/;"	f
SendDelayedUnicastResponse	mDNS.c	/^mDNSlocal void SendDelayedUnicastResponse(mDNS *const m, const mDNSAddr *const dest, const mDNSInterfaceID InterfaceID)$/;"	f
SendNSECNow	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID SendNSECNow;		\/\/ Set if we need to generate associated NSEC data for this rrname$/;"	m	struct:AuthRecord_struct
SendOnAll	mDNSEmbeddedAPI.h	/^	mDNSBool              SendOnAll;		\/\/ Set if we're sending this question on all active interfaces$/;"	m	struct:DNSQuestion_struct
SendQNow	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID       SendQNow;			\/\/ The interface this query is being sent on right now$/;"	m	struct:DNSQuestion_struct
SendQueries	mDNS.c	/^mDNSlocal void SendQueries(mDNS *const m)$/;"	f
SendRNow	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID SendRNow;			\/\/ The interface this query is being sent on right now$/;"	m	struct:AuthRecord_struct
SendRecordDeregistration	uDNS.c	/^mDNSlocal void SendRecordDeregistration(mDNS *m, AuthRecord *rr)$/;"	f
SendRecordRegistration	uDNS.c	/^mDNSlocal void SendRecordRegistration(mDNS *const m, AuthRecord *rr)$/;"	f
SendResponses	mDNS.c	/^mDNSlocal void SendResponses(mDNS *const m)$/;"	f
SendSPSRegistration	mDNS.c	/^mDNSlocal void SendSPSRegistration(mDNS *const m, NetworkInterfaceInfo *intf, const mDNSOpaque16 id)$/;"	f
SendServiceDeregistration	uDNS.c	/^mDNSlocal void SendServiceDeregistration(mDNS *m, ServiceRecordSet *srs)$/;"	f
SendServiceRegistration	uDNS.c	/^mDNSlocal void SendServiceRegistration(mDNS *m, ServiceRecordSet *srs)$/;"	f
SendSleepGoodbyes	mDNS.c	/^mDNSlocal void SendSleepGoodbyes(mDNS *const m)$/;"	f
SendUnicastQuery	NetMonitor.c	/^mDNSlocal void SendUnicastQuery(mDNS *const m, HostEntry *entry, domainname *name, mDNSu16 rrtype, mDNSInterfaceID InterfaceID)$/;"	f
SendWakeup	mDNS.c	/^mDNSlocal void SendWakeup(mDNS *const m, mDNSInterfaceID InterfaceID, mDNSEthAddr *EthAddr, mDNSOpaque48 *password)$/;"	f
SentSleepProxyRegistration	mDNSEmbeddedAPI.h	/^	mDNSu8   SentSleepProxyRegistration;\/\/ Set if we registered (or tried to register) with a Sleep Proxy$/;"	m	struct:mDNS_struct
ServiceCallback	ProxyResponder.c	/^mDNSlocal void ServiceCallback(mDNS *const m, ServiceRecordSet *const sr, mStatus result)$/;"	f
ServiceCallback	mDNS.c	/^mDNSlocal void ServiceCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
ServiceCallback	mDNSEmbeddedAPI.h	/^	mDNSServiceCallback *ServiceCallback;$/;"	m	struct:ServiceRecordSet_struct
ServiceContext	mDNSEmbeddedAPI.h	/^	void                *ServiceContext;$/;"	m	struct:ServiceRecordSet_struct
ServiceInfo	mDNSEmbeddedAPI.h	/^	} ServiceInfo;$/;"	t	typeref:struct:__anon53
ServiceInfoQuery	mDNSEmbeddedAPI.h	/^typedef struct ServiceInfoQuery_struct ServiceInfoQuery;$/;"	t	typeref:struct:ServiceInfoQuery_struct
ServiceInfoQueryCallback	mDNSEmbeddedAPI.h	/^	mDNSServiceInfoQueryCallback *ServiceInfoQueryCallback;$/;"	m	struct:ServiceInfoQuery_struct
ServiceInfoQueryContext	mDNSEmbeddedAPI.h	/^	void                         *ServiceInfoQueryContext;$/;"	m	struct:ServiceInfoQuery_struct
ServiceInfoQuery_struct	mDNSEmbeddedAPI.h	/^struct ServiceInfoQuery_struct$/;"	s
ServiceRecordSet	mDNSEmbeddedAPI.h	/^typedef struct ServiceRecordSet_struct ServiceRecordSet;$/;"	t	typeref:struct:ServiceRecordSet_struct
ServiceRecordSet_struct	mDNSEmbeddedAPI.h	/^struct ServiceRecordSet_struct$/;"	s
ServiceRegistrationGotZoneData	uDNS.c	/^mDNSexport void ServiceRegistrationGotZoneData(mDNS *const m, mStatus err, const ZoneData *zoneData)$/;"	f
ServiceRegistrations	mDNSEmbeddedAPI.h	/^	ServiceRecordSet *ServiceRegistrations;$/;"	m	struct:mDNS_struct
ServicesCallback	Identify.c	/^mDNSlocal void ServicesCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord)$/;"	f
SetLLQTimer	uDNS.c	/^mDNSlocal void SetLLQTimer(mDNS *const m, DNSQuestion *const q, const LLQOptData *const llq)$/;"	f
SetNewRData	DNSCommon.c	/^mDNSexport void SetNewRData(ResourceRecord *const rr, RData *NewRData, mDNSu16 rdlength)$/;"	f
SetNextAnnounceProbeTime	mDNS.c	/^mDNSlocal void SetNextAnnounceProbeTime(mDNS *const m, const AuthRecord *const rr)$/;"	f
SetNextCacheCheckTime	mDNS.c	/^mDNSlocal void SetNextCacheCheckTime(mDNS *const m, CacheRecord *const rr)$/;"	f
SetNextQueryTime	mDNS.c	/^mDNSexport void SetNextQueryTime(mDNS *const m, const DNSQuestion *const q)$/;"	f
SetRecordRetry	uDNS.c	/^mDNSlocal void SetRecordRetry(mDNS *const m, AuthRecord *rr, mStatus SendErr)$/;"	f
SetSPSProxyListChanged	mDNS.c	4531;"	d	file:
SetTargetToHostName	mDNS.c	/^mDNSlocal void SetTargetToHostName(mDNS *const m, AuthRecord *const rr)$/;"	f
SetupInterfaceList	mDNSPosix.c	/^mDNSlocal int SetupInterfaceList(mDNS *const m)$/;"	f
SetupOneInterface	mDNSPosix.c	/^mDNSlocal int SetupOneInterface(mDNS *const m, struct sockaddr *intfAddr, struct sockaddr *intfMask, const char *intfName, int intfIndex)$/;"	f
SetupOwnerOpt	mDNS.c	/^mDNSlocal void SetupOwnerOpt(const mDNS *const m, const NetworkInterfaceInfo *const intf, rdataOPT *const owner)$/;"	f
SetupSocket	mDNSPosix.c	/^mDNSlocal int SetupSocket(struct sockaddr *intfAddr, mDNSIPPort port, int interfaceIndex, int *sktPtr)$/;"	f
ShouldSuppressKnownAnswer	mDNS.c	/^mDNSlocal mDNSBool ShouldSuppressKnownAnswer(const CacheRecord *const ka, const AuthRecord *const rr)$/;"	f
ShowSortedHostList	NetMonitor.c	/^mDNSlocal void ShowSortedHostList(HostList *list, int max)$/;"	f
ShowTaskSchedulingError	DNSCommon.c	/^mDNSexport void ShowTaskSchedulingError(mDNS *const m)$/;"	f
ShutdownTime	mDNSEmbeddedAPI.h	/^	mDNSs32  ShutdownTime;				\/\/ Set when we're shutting down; allows us to skip some unnecessary steps$/;"	m	struct:mDNS_struct
SkipLeadingLabels	DNSCommon.c	/^mDNSexport const domainname *SkipLeadingLabels(const domainname *d, int skip)$/;"	f
SleepLimit	mDNSEmbeddedAPI.h	/^	mDNSs32  SleepLimit;				\/\/ Time window to allow deregistrations, etc.,$/;"	m	struct:mDNS_struct
SleepProxyServerCallback	mDNS.c	/^mDNSlocal void SleepProxyServerCallback(mDNS *const m, ServiceRecordSet *const srs, mStatus result)$/;"	f
SleepProxyServiceType	mDNSEmbeddedAPI.h	2773;"	d
SleepRecordRegistrations	uDNS.c	/^mDNSexport void SleepRecordRegistrations(mDNS *m)$/;"	f
SleepSeqNum	mDNSEmbeddedAPI.h	/^	mDNSu8   SleepSeqNum;				\/\/ "Epoch number" of our current period of wakefulness$/;"	m	struct:mDNS_struct
SleepServiceRegistrations	uDNS.c	/^mDNSexport void SleepServiceRegistrations(mDNS *m)$/;"	f
SleepState	mDNSEmbeddedAPI.h	/^	mDNSu8   SleepState;				\/\/ Set if we're sleeping$/;"	m	struct:mDNS_struct
SleepState_Awake	mDNSEmbeddedAPI.h	/^	SleepState_Awake = 0,$/;"	e	enum:__anon56
SleepState_Sleeping	mDNSEmbeddedAPI.h	/^	SleepState_Sleeping = 2$/;"	e	enum:__anon56
SleepState_Transferring	mDNSEmbeddedAPI.h	/^	SleepState_Transferring = 1,$/;"	e	enum:__anon56
SmallRecordLimit	mDNS.c	1558;"	d	file:
SockAddrTomDNSAddr	mDNSPosix.c	/^mDNSlocal void SockAddrTomDNSAddr(const struct sockaddr *const sa, mDNSAddr *ipAddr, mDNSIPPort *ipPort)$/;"	f
SocketDataReady	mDNSPosix.c	/^mDNSlocal void SocketDataReady(mDNS *const m, PosixNetworkInterface *intf, int skt)$/;"	f
StandardAuthRDSize	mDNSEmbeddedAPI.h	1683;"	d
StartGetZoneData	uDNS.c	/^mDNSexport ZoneData *StartGetZoneData(mDNS *const m, const domainname *const name, const ZoneService target, ZoneDataCallback callback, void *ZoneDataContext)$/;"	f
StartLLQPolling	uDNS.c	/^mDNSlocal void StartLLQPolling(mDNS *const m, DNSQuestion *q)$/;"	f
StartQuery	Identify.c	/^mDNSlocal mStatus StartQuery(DNSQuestion *q, char *qname, mDNSu16 qtype, const mDNSAddr *target, mDNSQuestionCallback callback)$/;"	f
StartSRVNatMap	uDNS.c	/^mDNSlocal void StartSRVNatMap(mDNS *m, ServiceRecordSet *srs)$/;"	f
StaticHostname	mDNSEmbeddedAPI.h	/^	domainname        StaticHostname;       \/\/ Current answer to reverse-map query$/;"	m	struct:mDNS_struct
StatusCallback	mDNSEmbeddedAPI.h	/^	mDNSRecordCallback *StatusCallback;       \/\/ callback to deliver success or error code to client layer$/;"	m	struct:HostnameInfo
StatusContext	mDNSEmbeddedAPI.h	/^	const void *StatusContext;                \/\/ Client Context$/;"	m	struct:HostnameInfo
StopNow	ExampleClientApp.c	/^static volatile mDNSBool StopNow;$/;"	v	file:
StopNow	Identify.c	/^static volatile int StopNow;	\/\/ 0 means running, 1 means stop because we got an answer, 2 means stop because of Ctrl-C$/;"	v	file:
StrictUnicastOrdering	uDNS.c	/^mDNSBool StrictUnicastOrdering = mDNSfalse;$/;"	v
StripFirstLabel	mDNSEmbeddedAPI.h	3027;"	d
SubTypes	mDNSEmbeddedAPI.h	/^	AuthRecord          *SubTypes;$/;"	m	struct:ServiceRecordSet_struct
SuppressOnThisInterface	mDNS.c	/^mDNSlocal mDNSBool SuppressOnThisInterface(const DupSuppressInfo ds[DupSuppressInfoSize], const NetworkInterfaceInfo * const intf)$/;"	f
SuppressProbes	mDNSEmbeddedAPI.h	/^	mDNSs32 SuppressProbes;$/;"	m	struct:mDNS_struct
SuppressSending	mDNSEmbeddedAPI.h	/^	mDNSs32  SuppressSending;			\/\/ Don't send *any* packets during this time$/;"	m	struct:mDNS_struct
SuppressStdPort53Queries	mDNSEmbeddedAPI.h	/^	mDNSs32 SuppressStdPort53Queries;       \/\/ Wait before allowing the next standard unicast query to the user's configured DNS server$/;"	m	struct:mDNS_struct
SuspendLLQs	mDNS.c	/^mDNSlocal void SuspendLLQs(mDNS *m)$/;"	f
SwapDNSHeaderBytes	mDNSEmbeddedAPI.h	3217;"	d
SystemWakeOnLANEnabled	mDNSEmbeddedAPI.h	/^	mDNSu8   SystemWakeOnLANEnabled;	\/\/ Set if we want to register with a Sleep Proxy before going to sleep$/;"	m	struct:mDNS_struct
TCPConnectionCallback	mDNSEmbeddedAPI.h	/^typedef void (*TCPConnectionCallback)(TCPSocket *sock, void *context, mDNSBool ConnectionEstablished, mStatus err);$/;"	t
TCPSocket	mDNSEmbeddedAPI.h	/^typedef struct TCPSocket_struct TCPSocket;$/;"	t	typeref:struct:TCPSocket_struct
TCPSocketFlags	mDNSEmbeddedAPI.h	/^	} TCPSocketFlags;$/;"	t	typeref:enum:__anon59
TCPSocket_struct	DNSCommon.c	/^struct TCPSocket_struct { TCPSocketFlags flags; \/* ... *\/ };$/;"	s	file:
TCPSocket_struct	uDNS.c	/^struct TCPSocket_struct { TCPSocketFlags flags; \/* ... *\/ };$/;"	s	file:
TSIG_ErrBadKey	DNSCommon.h	/^	TSIG_ErrBadKey  = 17,$/;"	e	enum:__anon9
TSIG_ErrBadSig	DNSCommon.h	/^	TSIG_ErrBadSig  = 16,$/;"	e	enum:__anon9
TSIG_ErrBadTime	DNSCommon.h	/^	TSIG_ErrBadTime = 18$/;"	e	enum:__anon9
TSIG_ErrorCode	DNSCommon.h	/^	} TSIG_ErrorCode;$/;"	t	typeref:enum:__anon9
TXTRecordRef	dns_sd.h	/^typedef union _TXTRecordRef_t { char PrivateData[16]; char *ForceNaturalAlignment; } TXTRecordRef;$/;"	t	typeref:union:_TXTRecordRef_t
TXTinfo	mDNSEmbeddedAPI.h	/^	mDNSu8          TXTinfo[2048];		\/\/ Additional demultiplexing information (e.g. LPR queue name)$/;"	m	struct:__anon53
TXTlen	mDNSEmbeddedAPI.h	/^	mDNSu16         TXTlen;$/;"	m	struct:__anon53
Tail	GenLinkedList.h	/^				*Tail;$/;"	m	struct:GenDoubleLinkedList
Tail	GenLinkedList.h	/^				*Tail;$/;"	m	struct:GenLinkedList
Tail	GenLinkedList.h	/^				Tail;$/;"	m	struct:GenLinkedOffsetList
Target	mDNSEmbeddedAPI.h	/^	mDNSAddr              Target;			\/\/ Non-zero if you want to direct queries to a specific unicast target address$/;"	m	struct:DNSQuestion_struct
TargetPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort            TargetPort;		\/\/ Must be set if Target is set$/;"	m	struct:DNSQuestion_struct
TargetQID	mDNSEmbeddedAPI.h	/^	mDNSOpaque16          TargetQID;		\/\/ Must be set if Target is set$/;"	m	struct:DNSQuestion_struct
Target_AutoHost	mDNSEmbeddedAPI.h	/^	Target_AutoHost = 1,$/;"	e	enum:__anon44
Target_AutoHostAndNATMAP	mDNSEmbeddedAPI.h	/^	Target_AutoHostAndNATMAP = 2$/;"	e	enum:__anon44
Target_Manual	mDNSEmbeddedAPI.h	/^	Target_Manual = 0,$/;"	e	enum:__anon44
TestForSelfConflict	mDNSEmbeddedAPI.h	/^	mDNSBool          TestForSelfConflict;		\/\/ on name conflict, check if we're just seeing our own orphaned records$/;"	m	struct:ServiceRecordSet_struct
ThirdLabel	mDNSEmbeddedAPI.h	3031;"	d
ThisAPInterval	mDNSEmbeddedAPI.h	/^	mDNSs32         ThisAPInterval;		\/\/ In platform time units: Current interval for announce\/probe$/;"	m	struct:AuthRecord_struct
ThisQInterval	mDNSEmbeddedAPI.h	/^	mDNSs32               ThisQInterval;	\/\/ LastQTime + ThisQInterval is the next scheduled transmission of this Q$/;"	m	struct:DNSQuestion_struct
TicksTTL	mDNS.c	1749;"	d	file:
Time	mDNSEmbeddedAPI.h	/^	mDNSs32               Time;$/;"	m	struct:__anon48
TimeExpire	mDNSEmbeddedAPI.h	/^	mDNSs32         TimeExpire;			\/\/ In platform time units$/;"	m	struct:AuthRecord_struct
TimeRcvd	mDNSEmbeddedAPI.h	/^	mDNSs32         TimeRcvd;			\/\/ In platform time units$/;"	m	struct:AuthRecord_struct
TimeRcvd	mDNSEmbeddedAPI.h	/^	mDNSs32         TimeRcvd;			\/\/ In platform time units$/;"	m	struct:CacheRecord_struct
TimeToAnnounceThisRecord	mDNS.c	1747;"	d	file:
TimeToSendThisQuestion	mDNS.c	1583;"	d	file:
TimeToSendThisRecord	mDNS.c	1748;"	d	file:
TruncateUTF8ToLength	DNSCommon.c	/^mDNSexport mDNSu32 TruncateUTF8ToLength(mDNSu8 *string, mDNSu32 length, mDNSu32 max)$/;"	f
TunnelClients	mDNSEmbeddedAPI.h	/^	ClientTunnel     *TunnelClients;$/;"	m	struct:mDNS_struct
Type	mDNSEmbeddedAPI.h	/^	mDNSs32               Type;				\/\/ v4 or v6?$/;"	m	struct:__anon48
UDPSocket	mDNSEmbeddedAPI.h	/^typedef struct UDPSocket_struct UDPSocket;$/;"	t	typeref:struct:UDPSocket_struct
UDPSocket_struct	DNSCommon.c	/^struct UDPSocket_struct$/;"	s	file:
UDPSocket_struct	mDNS.c	/^struct UDPSocket_struct$/;"	s	file:
UPnPInterfaceID	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID   UPnPInterfaceID;$/;"	m	struct:mDNS_struct
UPnPRouterAddressString	mDNSEmbeddedAPI.h	/^	mDNSu8           *UPnPRouterAddressString;	\/\/ holds both the router's address and port$/;"	m	struct:mDNS_struct
UPnPRouterPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort        UPnPRouterPort;			\/\/ port we send discovery messages to$/;"	m	struct:mDNS_struct
UPnPRouterURL	mDNSEmbeddedAPI.h	/^	mDNSu8           *UPnPRouterURL;			\/\/ router's URL string$/;"	m	struct:mDNS_struct
UPnPSOAPAddressString	mDNSEmbeddedAPI.h	/^	mDNSu8           *UPnPSOAPAddressString;	\/\/ holds both address and port for SOAP messages$/;"	m	struct:mDNS_struct
UPnPSOAPPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort        UPnPSOAPPort;				\/\/ port we send SOAP messages to$/;"	m	struct:mDNS_struct
UPnPSOAPURL	mDNSEmbeddedAPI.h	/^	mDNSu8           *UPnPSOAPURL;				\/\/ router's SOAP control URL string$/;"	m	struct:mDNS_struct
UPnPWANPPPConnection	mDNSEmbeddedAPI.h	/^	mDNSBool          UPnPWANPPPConnection;     \/\/ whether we're using WANIPConnection or WANPPPConnection$/;"	m	struct:mDNS_struct
USE_SEPARATE_UDNS_SERVICE_LIST	mDNSDebug.h	201;"	d
UTF8str255	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[256]; } UTF8str255;		\/\/ Null-terminated C string$/;"	t	typeref:struct:__anon30
UnansweredQueries	mDNSEmbeddedAPI.h	/^	mDNSu32         UnansweredQueries;	\/\/ Number of times we've issued a query for this record without getting an answer$/;"	m	struct:CacheRecord_struct
UnicastDNSPort	DNSCommon.c	/^mDNSexport const mDNSIPPort UnicastDNSPort         = { { UnicastDNSPortAsNumber         >> 8, UnicastDNSPortAsNumber         & 0xFF } };$/;"	v
UnicastDNSPortAsNumber	DNSCommon.c	608;"	d	file:
UnicastPort4	mDNSEmbeddedAPI.h	/^	mDNSIPPort UnicastPort4;$/;"	m	struct:mDNS_struct
UnicastPort6	mDNSEmbeddedAPI.h	/^	mDNSIPPort UnicastPort6;$/;"	m	struct:mDNS_struct
UniqueAnswers	mDNSEmbeddedAPI.h	/^	mDNSu32               UniqueAnswers;	\/\/ Number of answers received with kDNSClass_UniqueRRSet bit set$/;"	m	struct:DNSQuestion_struct
UnlinkAuthRecord	uDNS.c	/^mDNSlocal mStatus UnlinkAuthRecord(mDNS *const m, AuthRecord *const rr)$/;"	f
UpdateBlocked	mDNSEmbeddedAPI.h	/^	mDNSs32         UpdateBlocked;		\/\/ Set if update delaying is in effect$/;"	m	struct:AuthRecord_struct
UpdateCallback	mDNSEmbeddedAPI.h	/^	mDNSRecordUpdateCallback *UpdateCallback;$/;"	m	struct:AuthRecord_struct
UpdateCredits	mDNSEmbeddedAPI.h	/^	mDNSu32         UpdateCredits;		\/\/ Token-bucket rate limiting of excessive updates$/;"	m	struct:AuthRecord_struct
UpdateInterfaceProtocols	mDNS.c	/^mDNSlocal void UpdateInterfaceProtocols(mDNS *const m, NetworkInterfaceInfo *active)$/;"	f
UpdatePort	mDNSEmbeddedAPI.h	/^	mDNSIPPort   UpdatePort;	\/\/ port on which server accepts dynamic updates$/;"	m	struct:AuthRecord_struct
UpdateQuestionDuplicates	mDNS.c	/^mDNSlocal void UpdateQuestionDuplicates(mDNS *const m, DNSQuestion *const question)$/;"	f
UpdateReqFlags	DNSCommon.c	/^mDNSexport const mDNSOpaque16 UpdateReqFlags  = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_Update,                  0 } };$/;"	v
UpdateRespFlags	DNSCommon.c	/^mDNSexport const mDNSOpaque16 UpdateRespFlags = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_Update,                  0 } };$/;"	v
UpdateSRV	uDNS.c	/^mDNSlocal void UpdateSRV(mDNS *m, ServiceRecordSet *srs)$/;"	f
UpdateSRVRecords	uDNS.c	/^mDNSlocal void UpdateSRVRecords(mDNS *m)$/;"	f
UpdateServer	mDNSEmbeddedAPI.h	/^	mDNSAddr     UpdateServer;	\/\/ DNS server that handles updates for this zone$/;"	m	struct:AuthRecord_struct
ValidDNSOpt	mDNSEmbeddedAPI.h	1659;"	d
ValidOwnerLength	mDNSEmbeddedAPI.h	1654;"	d
ValidQuestionTarget	mDNS.c	7561;"	d	file:
ValidSPSName	mDNSEmbeddedAPI.h	3446;"	d
ValidTransportProtocol	DNSCommon.c	1222;"	d	file:
ValidateDomainName	DNSCommon.h	262;"	d
ValidateRData	DNSCommon.c	/^mDNSexport mDNSBool ValidateRData(const mDNSu16 rrtype, const mDNSu16 rdlength, const RData *const rd)$/;"	f
WaitForAnswer	Identify.c	/^mDNSlocal void WaitForAnswer(mDNS *const m, int seconds)$/;"	f
WakeUp	mDNSEmbeddedAPI.h	/^	OwnerOptData    WakeUp;				\/\/ Fpr Sleep Proxy records, MAC address of original owner (so we can wake it)$/;"	m	struct:AuthRecord_struct
WatchForInterfaceChange	mDNSPosix.c	/^mDNSlocal mStatus WatchForInterfaceChange(mDNS *const m)$/;"	f
X	DNSDigest.c	1117;"	d	file:
X	DNSDigest.c	1127;"	d	file:
XX	mDNS.c	9480;"	d	file:
ZoneClass	mDNSEmbeddedAPI.h	/^	mDNSu16          ZoneClass;			\/\/ Discovered result: DNS Class from SOA record$/;"	m	struct:ZoneData_struct
ZoneData	mDNSEmbeddedAPI.h	/^typedef struct ZoneData_struct ZoneData;$/;"	t	typeref:struct:ZoneData_struct
ZoneDataCallback	mDNSEmbeddedAPI.h	/^	ZoneDataCallback *ZoneDataCallback;	\/\/ Caller-specified function to be called upon completion$/;"	m	struct:ZoneData_struct
ZoneDataCallback	mDNSEmbeddedAPI.h	/^typedef void ZoneDataCallback(mDNS *const m, mStatus err, const ZoneData *result);$/;"	t
ZoneDataContext	mDNSEmbeddedAPI.h	/^	void             *ZoneDataContext;$/;"	m	struct:ZoneData_struct
ZoneDataSRV	uDNS.c	2846;"	d	file:
ZoneData_struct	mDNSEmbeddedAPI.h	/^struct ZoneData_struct$/;"	s
ZoneName	mDNSEmbeddedAPI.h	/^	domainname       ZoneName;			\/\/ Discovered result: Left-hand-side of SOA record$/;"	m	struct:ZoneData_struct
ZonePrivate	mDNSEmbeddedAPI.h	/^	mDNSBool         ZonePrivate;		\/\/ Discovered result: Does zone require encrypted queries?$/;"	m	struct:ZoneData_struct
ZoneService	mDNSEmbeddedAPI.h	/^	ZoneService      ZoneService;		\/\/ Which service we're seeking for this zone (update, query, or LLQ)$/;"	m	struct:ZoneData_struct
ZoneService	mDNSEmbeddedAPI.h	/^typedef enum { ZoneServiceUpdate, ZoneServiceQuery, ZoneServiceLLQ } ZoneService;$/;"	t	typeref:enum:__anon54
ZoneServiceLLQ	mDNSEmbeddedAPI.h	/^typedef enum { ZoneServiceUpdate, ZoneServiceQuery, ZoneServiceLLQ } ZoneService;$/;"	e	enum:__anon54
ZoneServiceQuery	mDNSEmbeddedAPI.h	/^typedef enum { ZoneServiceUpdate, ZoneServiceQuery, ZoneServiceLLQ } ZoneService;$/;"	e	enum:__anon54
ZoneServiceUpdate	mDNSEmbeddedAPI.h	/^typedef enum { ZoneServiceUpdate, ZoneServiceQuery, ZoneServiceLLQ } ZoneService;$/;"	e	enum:__anon54
_DNS_SD_H	dns_sd.h	80;"	d
_PLATFORM_HAS_STRONG_PRNG_	mDNSEmbeddedAPI.h	3292;"	d
_TXTRecordRef_t	dns_sd.h	/^typedef union _TXTRecordRef_t { char PrivateData[16]; char *ForceNaturalAlignment; } TXTRecordRef;$/;"	u
_UNUSED	dns_sd.h	117;"	d
__DNSCOMMON_H_	DNSCommon.h	162;"	d
__GenLinkedList__	GenLinkedList.h	36;"	d
__UDNS_H_	uDNS.h	222;"	d
__crashreporter_info__	PosixDaemon.c	/^const char *__crashreporter_info__ = mDNSResponderVersionString_SCCS + 5;$/;"	v
__func__	DNSCommon.h	411;"	d
__mDNSClientAPI_h	mDNSEmbeddedAPI.h	998;"	d
__mDNSDebug_h	mDNSDebug.h	162;"	d
__mDNSPlatformPosix_h	mDNSPosix.h	82;"	d
__mDNSUNP_h	mDNSUNP.h	85;"	d
_extradata	mDNSEmbeddedAPI.h	/^	mDNSu8 _extradata[MaximumRDSize-InlineCacheRDSize];		\/\/ Glue on the necessary number of extra bytes$/;"	m	struct:__anon45
_nss_mdns_gethostbyaddr_r	nss_mdns.c	/^_nss_mdns_gethostbyaddr_r ($/;"	f
_nss_mdns_gethostbyname2_r	nss_mdns.c	/^_nss_mdns_gethostbyname2_r ($/;"	f
_nss_mdns_gethostbyname_r	nss_mdns.c	/^_nss_mdns_gethostbyname_r ($/;"	f
add_address_to_buffer	nss_mdns.c	/^add_address_to_buffer (result_map_t * result, const void * data, int len)$/;"	f	file:
add_alias_to_buffer	nss_mdns.c	/^add_alias_to_buffer (result_map_t * result, const char * data, int len)$/;"	f	file:
add_domain	nss_mdns.c	/^add_domain (config_t * conf, const char * domain)$/;"	f	file:
add_hostname_len	nss_mdns.c	/^add_hostname_len (result_map_t * result, const char * fullname, int len)$/;"	f	file:
add_hostname_or_alias	nss_mdns.c	/^add_hostname_or_alias (result_map_t * result, const char * data, int len)$/;"	f	file:
addr	NetMonitor.c	/^	mDNSAddr addr;$/;"	m	struct:__anon6	file:
addr	mDNSEmbeddedAPI.h	/^	mDNSAddr        addr;$/;"	m	struct:DNSServer
addr_idx	nss_mdns.c	/^	int addr_idx;$/;"	m	struct:result_map	file:
addrs	nss_mdns.c	/^	char * addrs [k_addrs_max + 1];$/;"	m	struct:buf_header	file:
addrs_count	nss_mdns.c	/^	int addrs_count;$/;"	m	struct:result_map	file:
af_to_rr	nss_mdns.c	/^af_to_rr (int af)$/;"	f
af_to_str	nss_mdns.c	/^af_to_str (int in)$/;"	f
aliasIntf	mDNSPosix.h	/^	PosixNetworkInterface * aliasIntf;$/;"	m	struct:PosixNetworkInterface
alias_idx	nss_mdns.c	/^	int alias_idx;$/;"	m	struct:result_map	file:
aliases	nss_mdns.c	/^	char * aliases [k_aliases_max + 1];$/;"	m	struct:buf_header	file:
aliases_count	nss_mdns.c	/^	int aliases_count;$/;"	m	struct:result_map	file:
altForm	DNSCommon.c	/^	char          altForm;$/;"	m	struct:mDNSprintf_format	file:
ar	mDNSEmbeddedAPI.h	/^	AuthRecord ar;          \/\/ Note: Must be last element of structure, to accomodate oversized AuthRecords$/;"	m	struct:ARListElem
arv4	mDNSEmbeddedAPI.h	/^	AuthRecord arv4;                          \/\/ registered IPv4 address record$/;"	m	struct:HostnameInfo
arv6	mDNSEmbeddedAPI.h	/^	AuthRecord arv6;                          \/\/ registered IPv6 address record$/;"	m	struct:HostnameInfo
asl_uuid	mDNSEmbeddedAPI.h	/^	uuid_t           asl_uuid;					\/\/ uuid for ASL logging$/;"	m	struct:mDNS_struct
assert0	dns_sd.h	/^    char assert0[(sizeof(union _TXTRecordRef_t) == 16) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_DNS_SD
assert0	mDNSEmbeddedAPI.h	/^	char assert0[(sizeof(rdataSRV)         == 262                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert1	mDNSEmbeddedAPI.h	/^	char assert1[(sizeof(DNSMessageHeader) ==  12                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert2	mDNSEmbeddedAPI.h	/^	char assert2[(sizeof(DNSMessage)       ==  12+AbsoluteMaxDNSMessageData) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert3	mDNSEmbeddedAPI.h	/^	char assert3[(sizeof(mDNSs8)           ==   1                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert4	mDNSEmbeddedAPI.h	/^	char assert4[(sizeof(mDNSu8)           ==   1                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert5	mDNSEmbeddedAPI.h	/^	char assert5[(sizeof(mDNSs16)          ==   2                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert6	mDNSEmbeddedAPI.h	/^	char assert6[(sizeof(mDNSu16)          ==   2                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert7	mDNSEmbeddedAPI.h	/^	char assert7[(sizeof(mDNSs32)          ==   4                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert8	mDNSEmbeddedAPI.h	/^	char assert8[(sizeof(mDNSu32)          ==   4                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assert9	mDNSEmbeddedAPI.h	/^	char assert9[(sizeof(mDNSOpaque16)     ==   2                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertA	mDNSEmbeddedAPI.h	/^	char assertA[(sizeof(mDNSOpaque32)     ==   4                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertB	mDNSEmbeddedAPI.h	/^	char assertB[(sizeof(mDNSOpaque128)    ==  16                          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertC	mDNSEmbeddedAPI.h	/^	char assertC[(sizeof(CacheRecord  )    ==  sizeof(CacheGroup)          ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertD	mDNSEmbeddedAPI.h	/^	char assertD[(sizeof(int)              >=  4                           ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertE	mDNSEmbeddedAPI.h	/^	char assertE[(StandardAuthRDSize       >=  256                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertF	mDNSEmbeddedAPI.h	/^	char assertF[(sizeof(EthernetHeader)   ==   14                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertG	mDNSEmbeddedAPI.h	/^	char assertG[(sizeof(ARP_EthIP     )   ==   28                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertH	mDNSEmbeddedAPI.h	/^	char assertH[(sizeof(IPv4Header    )   ==   20                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertI	mDNSEmbeddedAPI.h	/^	char assertI[(sizeof(IPv6Header    )   ==   40                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertJ	mDNSEmbeddedAPI.h	/^	char assertJ[(sizeof(IPv6ND        )   ==   24                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertK	mDNSEmbeddedAPI.h	/^	char assertK[(sizeof(UDPHeader     )   ==    8                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertL	mDNSEmbeddedAPI.h	/^	char assertL[(sizeof(IKEHeader     )   ==   28                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
assertM	mDNSEmbeddedAPI.h	/^	char assertM[(sizeof(TCPHeader     )   ==   20                         ) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
b	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 2]; mDNSu16 NotAnInteger; } mDNSOpaque16;$/;"	m	union:__anon18
b	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 4]; mDNSu32 NotAnInteger; } mDNSOpaque32;$/;"	m	union:__anon19
b	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 8]; mDNSu16 w[4]; mDNSu32 l[2]; } mDNSOpaque64;$/;"	m	union:__anon20
b	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[16]; mDNSu16 w[8]; mDNSu32 l[4]; } mDNSOpaque128;$/;"	m	union:__anon21
b64keydata	mDNSEmbeddedAPI.h	/^	char             b64keydata[32];$/;"	m	struct:DomainAuthInfo
bitmap	mDNSEmbeddedAPI.h	/^	mDNSu8 bitmap[32];$/;"	m	struct:__anon34
buf_header	nss_mdns.c	/^typedef struct buf_header$/;"	s	file:
buf_header_t	nss_mdns.c	/^} buf_header_t;$/;"	t	typeref:struct:buf_header	file:
buffer	nss_mdns.c	/^	char * buffer;$/;"	m	struct:result_map	file:
c	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[ 64]; } domainlabel;		\/\/ One label: length byte and up to 63 characters$/;"	m	struct:__anon28
c	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[256]; } UTF8str255;		\/\/ Null-terminated C string$/;"	m	struct:__anon30
c	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[256]; } domainname;		\/\/ Up to 256 bytes of length-prefixed domainlabels$/;"	m	struct:__anon29
callback_body_ptr	nss_mdns.c	/^callback_body_ptr ($/;"	f	file:
cg	mDNSEmbeddedAPI.h	/^union CacheEntity_union { CacheEntity *next; CacheGroup cg; CacheRecord cr; };$/;"	m	union:CacheEntity_union
checkUpdateResult	uDNS.c	/^mDNSlocal mStatus checkUpdateResult(mDNS *const m, const domainname *const displayname, const mDNSu8 rcode, const DNSMessage *const msg, const mDNSu8 *const end)$/;"	f
clientCallback	mDNSEmbeddedAPI.h	/^	NATTraversalClientCallback  clientCallback;$/;"	m	struct:NATTraversalInfo_struct
clientContext	mDNSEmbeddedAPI.h	/^	void                       *clientContext;$/;"	m	struct:NATTraversalInfo_struct
cmp_dns_suffix	nss_mdns.c	/^cmp_dns_suffix (const char * name, const char * domain)$/;"	f
comment	nss_mdns.c	/^	const char * comment;$/;"	m	struct:__anon14	file:
config_file_context_t	nss_mdns.c	/^} config_file_context_t;$/;"	t	typeref:struct:__anon13	file:
config_is_mdns_suffix	nss_mdns.c	/^config_is_mdns_suffix (const char * name)$/;"	f
config_t	nss_mdns.c	/^} config_t;$/;"	t	typeref:struct:__anon12	file:
contains_address	nss_mdns.c	/^contains_address (result_map_t * result, const void * data, int len)$/;"	f	file:
contains_alias	nss_mdns.c	/^contains_alias (result_map_t * result, const char * alias)$/;"	f	file:
contains_domain	nss_mdns.c	/^contains_domain (const config_t * conf, const char * domain)$/;"	f	file:
contains_domain_suffix	nss_mdns.c	/^contains_domain_suffix (const config_t * conf, const char * addr)$/;"	f	file:
coreIntf	mDNSPosix.h	/^	NetworkInterfaceInfo    coreIntf;$/;"	m	struct:PosixNetworkInterface
coreServ	Responder.c	/^    ServiceRecordSet coreServ;$/;"	m	struct:PosixService	file:
count_dots	nss_mdns.c	/^count_dots (const char * name)$/;"	f
cr	mDNSEmbeddedAPI.h	/^union CacheEntity_union { CacheEntity *next; CacheGroup cg; CacheRecord cr; };$/;"	m	union:CacheEntity_union
daemon	mDNSUNP.c	/^int daemon(int nochdir, int noclose)$/;"	f
data	DNSDigest.c	/^	mDNSu32 data[MD5_BLOCK_LONG];$/;"	m	struct:MD5state_st	file:
data	mDNSEmbeddedAPI.h	/^	mDNSu8      data[StandardAuthRDSize];$/;"	m	union:__anon35
data	mDNSEmbeddedAPI.h	/^	mDNSu8      data[StandardAuthRDSize];$/;"	m	union:__anon36
data	mDNSEmbeddedAPI.h	/^	mDNSu8     data[InlineCacheRDSize];$/;"	m	struct:__anon38
debug_noop	mDNSDebug.c	/^void debug_noop(const char *format, ...)  { (void) format; }$/;"	f
debug_noop	mDNSDebug.h	242;"	d
debug_noop	mDNSDebug.h	248;"	d
debugf	mDNSDebug.h	271;"	d
debugf	mDNSDebug.h	274;"	d
default_config	nss_mdns.c	/^default_config (config_t * conf)$/;"	f	file:
deltime	mDNSEmbeddedAPI.h	/^	mDNSs32          deltime;				\/\/ If we're planning to delete this DomainAuthInfo, the time we want it deleted$/;"	m	struct:DomainAuthInfo
dns_rdata_to_name	nss_mdns.c	/^dns_rdata_to_name (const char * rdata, int rdlen, char * name, int name_len)$/;"	f
domain	mDNSEmbeddedAPI.h	/^	domainname       domain;$/;"	m	struct:DomainAuthInfo
domain	mDNSEmbeddedAPI.h	/^	domainname      domain;		\/\/ name->server matching for "split dns"$/;"	m	struct:DNSServer
domain	mDNSEmbeddedAPI.h	/^	domainname domain;$/;"	m	struct:SearchListElem
domain	nss_mdns.c	/^	char * domain;$/;"	m	struct:domain_entry	file:
domain_entry	nss_mdns.c	/^typedef struct domain_entry$/;"	s	file:
domain_entry_t	nss_mdns.c	/^} domain_entry_t;$/;"	t	typeref:struct:domain_entry	file:
domainlabel	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[ 64]; } domainlabel;		\/\/ One label: length byte and up to 63 characters$/;"	t	typeref:struct:__anon28
domainname	mDNSEmbeddedAPI.h	/^typedef struct { mDNSu8 c[256]; } domainname;		\/\/ Up to 256 bytes of length-prefixed domainlabels$/;"	t	typeref:struct:__anon29
domains	nss_mdns.c	/^	domain_entry_t * domains;$/;"	m	struct:__anon12	file:
done	nss_mdns.c	/^	int done;$/;"	m	struct:result_map	file:
dstname	mDNSEmbeddedAPI.h	/^	domainname dstname;$/;"	m	struct:ClientTunnel
dummy	mDNSEmbeddedAPI.h	/^typedef struct mDNSInterfaceID_dummystruct { void *dummy; } *mDNSInterfaceID;$/;"	m	struct:mDNSInterfaceID_dummystruct
err	mDNSEmbeddedAPI.h	/^	mDNSu16      err;	\/\/ Or UDP reply port, in setup request$/;"	m	struct:__anon32
errcode_t	nss_mdns.c	/^typedef int errcode_t;$/;"	t	file:
expire	mDNSEmbeddedAPI.h	/^	mDNSs32               expire;			\/\/ ticks (absolute)$/;"	m	struct:DNSQuestion_struct
expire	mDNSEmbeddedAPI.h	/^	mDNSs32      expire;		\/\/ In platform time units: expiration of lease (-1 for static)$/;"	m	struct:AuthRecord_struct
fd	mDNSPosix.c	/^	int							fd;$/;"	m	struct:PosixEventSource	file:
fieldWidth	DNSCommon.c	/^	unsigned int  fieldWidth;$/;"	m	struct:mDNSprintf_format	file:
filename	nss_mdns.c	/^	const char * filename;$/;"	m	struct:__anon13	file:
flag	mDNSEmbeddedAPI.h	/^	int flag;		\/\/ -1 means delete, 0 means unchanged, +1 means newly added$/;"	m	struct:SearchListElem
flags	DNSCommon.c	/^struct TCPSocket_struct { TCPSocketFlags flags; \/* ... *\/ };$/;"	m	struct:TCPSocket_struct	file:
flags	mDNSEmbeddedAPI.h	/^	mDNSu32         flags;		\/\/ Set when we're planning to delete this from the list$/;"	m	struct:DNSServer
flags	uDNS.c	/^struct TCPSocket_struct { TCPSocketFlags flags; \/* ... *\/ };$/;"	m	struct:TCPSocket_struct	file:
for	parselog.py	/^import math   # for pi$/;"	i
forceSign	DNSCommon.c	/^	unsigned      forceSign : 1;$/;"	m	struct:mDNSprintf_format	file:
format_reverse_addr	nss_mdns.c	/^format_reverse_addr ($/;"	f
format_reverse_addr_in	nss_mdns.c	/^format_reverse_addr_in ($/;"	f
format_reverse_addr_in6	nss_mdns.c	/^format_reverse_addr_in6 ($/;"	f
fqdn	mDNSEmbeddedAPI.h	/^	domainname fqdn;$/;"	m	struct:HostnameInfo
freeL	mDNSDebug.h	300;"	d
free_ifi_info	mDNSUNP.c	/^free_ifi_info(struct ifi_info *ifihead)$/;"	f
gAvoidPort53	Responder.c	/^static   mDNSBool  gAvoidPort53      = mDNStrue;$/;"	v	file:
gDaemon	Responder.c	/^static   mDNSBool  gDaemon           = mDNSfalse;$/;"	v	file:
gEventFDs	mDNSPosix.c	/^static fd_set			gEventFDs;$/;"	v	file:
gEventSignalSet	mDNSPosix.c	/^static sigset_t			gEventSignalSet;		\/\/ Signals which event loop listens for$/;"	v	file:
gEventSignals	mDNSPosix.c	/^static sigset_t			gEventSignals;			\/\/ Signals which were received while inside loop$/;"	v	file:
gEventSources	mDNSPosix.c	/^static GenLinkedList	gEventSources;			\/\/ linked list of PosixEventSource's$/;"	v	file:
gMDNSPlatformPosixVerboseLevel	mDNSPosix.c	/^int gMDNSPlatformPosixVerboseLevel = 0;$/;"	v
gMaxFD	mDNSPosix.c	/^static int				gMaxFD;					\/\/ largest fd in gEventFDs$/;"	v	file:
gPIDFile	Responder.c	/^static const char *gPIDFile          = kDefaultPIDFile;$/;"	v	file:
gPortNumber	Responder.c	/^static        int  gPortNumber       = kDefaultPortNumber;$/;"	v	file:
gProgramName	Client.c	/^static const char *gProgramName = ProgramName;$/;"	v	file:
gProgramName	Responder.c	/^static const char *gProgramName = ProgramName;$/;"	v	file:
gRRCache	Client.c	/^static CacheEntity gRRCache[RR_CACHE_SIZE];$/;"	v	file:
gRRCache	Identify.c	/^static CacheEntity gRRCache[RR_CACHE_SIZE];$/;"	v	file:
gRRCache	PosixDaemon.c	/^static CacheEntity gRRCache[RR_CACHE_SIZE];$/;"	v	file:
gReceivedSigHup	Responder.c	/^static volatile mDNSBool gReceivedSigHup;$/;"	v	file:
gReceivedSigUsr1	Responder.c	/^static volatile mDNSBool gReceivedSigUsr1;$/;"	v	file:
gServiceDomain	Client.c	/^static const char *gServiceDomain    = kDefaultDomain;$/;"	v	file:
gServiceDomain	Responder.c	/^static const char *gServiceDomain    = kDefaultServiceDomain;$/;"	v	file:
gServiceFile	Responder.c	/^static const char *gServiceFile      = "";$/;"	v	file:
gServiceID	Responder.c	/^static int gServiceID = 0;$/;"	v	file:
gServiceList	Responder.c	/^static PosixService *gServiceList = NULL;$/;"	v	file:
gServiceName	Responder.c	/^static const char *gServiceName      = "";$/;"	v	file:
gServiceText	Responder.c	/^static mDNSu8      gServiceText[sizeof(RDataBody)];$/;"	v	file:
gServiceTextLen	Responder.c	/^static mDNSu16     gServiceTextLen   = 0;$/;"	v	file:
gServiceType	Client.c	/^static const char *gServiceType      = kDefaultServiceType;$/;"	v	file:
gServiceType	Responder.c	/^static const char *gServiceType      = kDefaultServiceType;$/;"	v	file:
gStopNow	Responder.c	/^static volatile mDNSBool gStopNow;$/;"	v	file:
g_config	nss_mdns.c	/^static config_t * g_config = NULL;$/;"	v	file:
g_config_mutex	nss_mdns.c	/^pthread_mutex_t g_config_mutex =$/;"	v
getDomainName	DNSCommon.c	/^mDNSexport const mDNSu8 *getDomainName(const DNSMessage *const msg, const mDNSu8 *ptr, const mDNSu8 *const end,$/;"	f
getQuestion	DNSCommon.c	/^mDNSexport const mDNSu8 *getQuestion(const DNSMessage *msg, const mDNSu8 *ptr, const mDNSu8 *end, const mDNSInterfaceID InterfaceID,$/;"	f
getVal16	DNSCommon.c	/^mDNSlocal mDNSu16 getVal16(const mDNSu8 **ptr)$/;"	f
get_ifi_info	mDNSUNP.c	/^struct ifi_info *get_ifi_info(int family, int doaliases)$/;"	f
get_ifi_info_linuxv6	mDNSUNP.c	/^struct ifi_info *get_ifi_info_linuxv6(int family, int doaliases)$/;"	f
get_next_word	nss_mdns.c	/^get_next_word (char * input, char **next)$/;"	f	file:
hSize	DNSCommon.c	/^	unsigned      hSize : 1;$/;"	m	struct:mDNSprintf_format	file:
handle_events	nss_mdns.c	/^handle_events (DNSServiceRef sdref, result_map_t * result, const char * str)$/;"	f	file:
hardware	Identify.c	/^static char hostname[MAX_ESCAPED_DOMAIN_NAME], hardware[256], software[256];$/;"	v	file:
havePrecision	DNSCommon.c	/^	unsigned      havePrecision : 1;$/;"	m	struct:mDNSprintf_format	file:
header	nss_mdns.c	/^	buf_header_t * header;$/;"	m	struct:result_map	file:
hndlRecordUpdateReply	uDNS.c	/^mDNSlocal void hndlRecordUpdateReply(mDNS *m, AuthRecord *rr, mStatus err)$/;"	f
hndlServiceUpdateReply	uDNS.c	/^mDNSlocal void hndlServiceUpdateReply(mDNS *const m, ServiceRecordSet *srs,  mStatus err)$/;"	f
hostaddr	Identify.c	/^static mDNSAddr lastsrc, hostaddr, target;$/;"	v	file:
hostent	nss_mdns.c	/^	hostent * hostent;$/;"	m	struct:result_map	file:
hostent	nss_mdns.c	/^typedef struct hostent hostent;$/;"	t	typeref:struct:hostent	file:
hostlabel	ProxyResponder.c	/^	domainlabel hostlabel;		\/\/ Conforms to standard DNS letter-digit-hyphen host name rules$/;"	m	struct:__anon15	file:
hostlabel	mDNSEmbeddedAPI.h	/^	domainlabel hostlabel;				\/\/ Conforms to RFC 1034 "letter-digit-hyphen" ARPANET host name rules$/;"	m	struct:mDNS_struct
hostname	Identify.c	/^static char hostname[MAX_ESCAPED_DOMAIN_NAME], hardware[256], software[256];$/;"	v	file:
hostname	NetMonitor.c	/^	domainname hostname;$/;"	m	struct:__anon6	file:
hostname	nss_mdns.c	/^	char hostname [k_hostname_maxlen + 1];$/;"	m	struct:buf_header	file:
hostnameGetPublicAddressCallback	uDNS.c	/^mDNSlocal void hostnameGetPublicAddressCallback(mDNS *m, NATTraversalInfo *n)$/;"	f
hosts	NetMonitor.c	/^	HostEntry	*hosts;$/;"	m	struct:__anon7	file:
id	Identify.c	/^static mDNSOpaque16 lastid, id;$/;"	v	file:
id	mDNSEmbeddedAPI.h	/^	mDNSOpaque16      id;$/;"	m	struct:ServiceRecordSet_struct
id	mDNSEmbeddedAPI.h	/^	mDNSOpaque64          id;$/;"	m	struct:DNSQuestion_struct
id	mDNSEmbeddedAPI.h	/^	mDNSOpaque64 id;$/;"	m	struct:__anon32
ifi_addr	mDNSUNP.h	/^  struct sockaddr  *ifi_addr;   \/* primary address *\/$/;"	m	struct:ifi_info	typeref:struct:ifi_info::sockaddr
ifi_brdaddr	mDNSUNP.h	/^  struct sockaddr  *ifi_brdaddr;\/* broadcast address *\/$/;"	m	struct:ifi_info	typeref:struct:ifi_info::sockaddr
ifi_dstaddr	mDNSUNP.h	/^  struct sockaddr  *ifi_dstaddr;\/* destination address *\/$/;"	m	struct:ifi_info	typeref:struct:ifi_info::sockaddr
ifi_flags	mDNSUNP.h	/^  short   ifi_flags;            \/* IFF_xxx constants from <net\/if.h> *\/$/;"	m	struct:ifi_info
ifi_haddr	mDNSUNP.h	/^  u_char  ifi_haddr[IFI_HADDR]; \/* hardware address *\/$/;"	m	struct:ifi_info
ifi_hlen	mDNSUNP.h	/^  u_short ifi_hlen;             \/* #bytes in hardware address: 0, 6, 8 *\/$/;"	m	struct:ifi_info
ifi_index	mDNSUNP.h	/^  int     ifi_index;            \/* interface index *\/$/;"	m	struct:ifi_info
ifi_info	mDNSUNP.h	/^struct ifi_info {$/;"	s
ifi_myflags	mDNSUNP.h	/^  short   ifi_myflags;          \/* our own IFI_xxx flags *\/$/;"	m	struct:ifi_info
ifi_name	mDNSUNP.h	/^  char    ifi_name[IFI_NAME];   \/* interface name, null terminated *\/$/;"	m	struct:ifi_info
ifi_netmask	mDNSUNP.h	/^  struct sockaddr  *ifi_netmask;$/;"	m	struct:ifi_info	typeref:struct:ifi_info::sockaddr
ifi_next	mDNSUNP.h	/^  struct ifi_info  *ifi_next;   \/* next of these structures *\/$/;"	m	struct:ifi_info	typeref:struct:ifi_info::ifi_info
ifname	mDNSEmbeddedAPI.h	/^	char            ifname[64];			\/\/ Windows uses a GUID string for the interface name, which doesn't fit in 16 bytes$/;"	m	struct:NetworkInterfaceInfo_struct
imsg	mDNSEmbeddedAPI.h	/^	union { DNSMessage m; void *p; } imsg;  \/\/ Incoming message received from wire$/;"	m	struct:mDNS_struct	typeref:union:mDNS_struct::__anon57
index	mDNSPosix.h	/^	int                     index;$/;"	m	struct:PosixNetworkInterface
info	mDNSEmbeddedAPI.h	/^	ServiceInfo                  *info;$/;"	m	struct:ServiceInfoQuery_struct
init_config	nss_mdns.c	/^init_config ()$/;"	f
init_result	nss_mdns.c	/^init_result ($/;"	f	file:
int16_t	dns_sd.h	/^typedef INT16       int16_t;$/;"	t
int32_t	dns_sd.h	/^typedef INT32       int32_t;$/;"	t
int8_t	dns_sd.h	/^typedef INT8        int8_t;$/;"	t
interface	mDNSEmbeddedAPI.h	/^	mDNSInterfaceID interface;	\/\/ For specialized uses; we can have DNS servers reachable over specific interfaces$/;"	m	struct:DNSServer
intfName	mDNSPosix.h	/^	const char *            intfName;$/;"	m	struct:PosixNetworkInterface
ip	ProxyResponder.c	/^	mDNSv4Addr ip;$/;"	m	struct:__anon15	file:
ip	mDNSEmbeddedAPI.h	/^	mDNSAddr        ip;					\/\/ Remote (destination) IP address where this service can be accessed$/;"	m	struct:__anon53
ip	mDNSEmbeddedAPI.h	/^	mDNSAddr        ip;					\/\/ The IPv4 or IPv6 address to advertise$/;"	m	struct:NetworkInterfaceInfo_struct
ip	mDNSEmbeddedAPI.h	/^	union { mDNSv6Addr v6; mDNSv4Addr v4; } ip;$/;"	m	struct:__anon24	typeref:union:__anon24::__anon25
ipi_addr	mDNSUNP.h	/^    struct sockaddr_storage ipi_addr;$/;"	m	struct:my_in_pktinfo	typeref:struct:my_in_pktinfo::sockaddr_storage
ipi_ifindex	mDNSUNP.h	/^    int                     ipi_ifindex;            \/* received interface index *\/$/;"	m	struct:my_in_pktinfo
ipi_ifname	mDNSUNP.h	/^    char                    ipi_ifname[IFI_NAME];   \/* received interface name  *\/$/;"	m	struct:my_in_pktinfo
ipv4	mDNSEmbeddedAPI.h	/^	mDNSv4Addr  ipv4;		\/\/ For 'A' record$/;"	m	union:__anon35
ipv4	mDNSEmbeddedAPI.h	/^	mDNSv4Addr  ipv4;		\/\/ For 'A' record$/;"	m	union:__anon36
ipv6	mDNSEmbeddedAPI.h	/^	mDNSv6Addr  ipv6;		\/\/ For 'AAAA' record$/;"	m	union:__anon35
ipv6	mDNSEmbeddedAPI.h	/^	mDNSv6Addr  ipv6;		\/\/ For 'AAAA' record$/;"	m	union:__anon36
is_applicable_addr	nss_mdns.c	/^is_applicable_addr ($/;"	f	file:
is_applicable_name	nss_mdns.c	/^is_applicable_name ($/;"	f	file:
islocal	nss_mdns.c	/^islocal (const char * name)$/;"	f
kDNSClass_CH	mDNSEmbeddedAPI.h	/^	kDNSClass_CH               = 3,		\/\/ CHAOS$/;"	e	enum:__anon16
kDNSClass_CS	mDNSEmbeddedAPI.h	/^	kDNSClass_CS               = 2,		\/\/ CSNET$/;"	e	enum:__anon16
kDNSClass_HS	mDNSEmbeddedAPI.h	/^	kDNSClass_HS               = 4,		\/\/ Hesiod$/;"	e	enum:__anon16
kDNSClass_IN	mDNSEmbeddedAPI.h	/^	kDNSClass_IN               = 1,		\/\/ Internet$/;"	e	enum:__anon16
kDNSClass_Mask	mDNSEmbeddedAPI.h	/^	kDNSClass_Mask             = 0x7FFF,\/\/ Multicast DNS uses the bottom 15 bits to identify the record class...$/;"	e	enum:__anon16
kDNSClass_NONE	mDNSEmbeddedAPI.h	/^	kDNSClass_NONE             = 254,	\/\/ Used in DNS UPDATE [RFC 2136]$/;"	e	enum:__anon16
kDNSClass_UniqueRRSet	mDNSEmbeddedAPI.h	/^	kDNSClass_UniqueRRSet      = 0x8000,\/\/ ... and the top bit indicates that all other cached records are now invalid$/;"	e	enum:__anon16
kDNSFlag0_AA	DNSCommon.h	/^	kDNSFlag0_AA          = 0x04,		\/\/ Authoritative Answer?$/;"	e	enum:__anon8
kDNSFlag0_OP_Iquery	DNSCommon.h	/^	kDNSFlag0_OP_Iquery   = 0x08,$/;"	e	enum:__anon8
kDNSFlag0_OP_Mask	DNSCommon.h	/^	kDNSFlag0_OP_Mask     = 0x78,		\/\/ Operation type$/;"	e	enum:__anon8
kDNSFlag0_OP_Notify	DNSCommon.h	/^	kDNSFlag0_OP_Notify   = 0x20,$/;"	e	enum:__anon8
kDNSFlag0_OP_Status	DNSCommon.h	/^	kDNSFlag0_OP_Status   = 0x10,$/;"	e	enum:__anon8
kDNSFlag0_OP_StdQuery	DNSCommon.h	/^	kDNSFlag0_OP_StdQuery = 0x00,$/;"	e	enum:__anon8
kDNSFlag0_OP_Unused3	DNSCommon.h	/^	kDNSFlag0_OP_Unused3  = 0x18,$/;"	e	enum:__anon8
kDNSFlag0_OP_Update	DNSCommon.h	/^	kDNSFlag0_OP_Update   = 0x28,$/;"	e	enum:__anon8
kDNSFlag0_QROP_Mask	DNSCommon.h	/^	kDNSFlag0_QROP_Mask   = kDNSFlag0_QR_Mask | kDNSFlag0_OP_Mask,$/;"	e	enum:__anon8
kDNSFlag0_QR_Mask	DNSCommon.h	/^	kDNSFlag0_QR_Mask     = 0x80,		\/\/ Query or response?$/;"	e	enum:__anon8
kDNSFlag0_QR_Query	DNSCommon.h	/^	kDNSFlag0_QR_Query    = 0x00,$/;"	e	enum:__anon8
kDNSFlag0_QR_Response	DNSCommon.h	/^	kDNSFlag0_QR_Response = 0x80,$/;"	e	enum:__anon8
kDNSFlag0_RD	DNSCommon.h	/^	kDNSFlag0_RD          = 0x01,		\/\/ Recursion Desired?$/;"	e	enum:__anon8
kDNSFlag0_TC	DNSCommon.h	/^	kDNSFlag0_TC          = 0x02,		\/\/ Truncated?$/;"	e	enum:__anon8
kDNSFlag1_AD	DNSCommon.h	/^	kDNSFlag1_AD          = 0x20,		\/\/ Authentic Data [RFC 2535]$/;"	e	enum:__anon8
kDNSFlag1_CD	DNSCommon.h	/^	kDNSFlag1_CD          = 0x10,		\/\/ Checking Disabled [RFC 2535]$/;"	e	enum:__anon8
kDNSFlag1_RA	DNSCommon.h	/^	kDNSFlag1_RA          = 0x80,		\/\/ Recursion Available?$/;"	e	enum:__anon8
kDNSFlag1_RC_FormErr	DNSCommon.h	/^	kDNSFlag1_RC_FormErr  = 0x01,$/;"	e	enum:__anon8
kDNSFlag1_RC_Mask	DNSCommon.h	/^	kDNSFlag1_RC_Mask     = 0x0F,		\/\/ Response code$/;"	e	enum:__anon8
kDNSFlag1_RC_NXDomain	DNSCommon.h	/^	kDNSFlag1_RC_NXDomain = 0x03,$/;"	e	enum:__anon8
kDNSFlag1_RC_NXRRSet	DNSCommon.h	/^	kDNSFlag1_RC_NXRRSet  = 0x08,$/;"	e	enum:__anon8
kDNSFlag1_RC_NoErr	DNSCommon.h	/^	kDNSFlag1_RC_NoErr    = 0x00,$/;"	e	enum:__anon8
kDNSFlag1_RC_NotAuth	DNSCommon.h	/^	kDNSFlag1_RC_NotAuth  = 0x09,$/;"	e	enum:__anon8
kDNSFlag1_RC_NotImpl	DNSCommon.h	/^	kDNSFlag1_RC_NotImpl  = 0x04,$/;"	e	enum:__anon8
kDNSFlag1_RC_NotZone	DNSCommon.h	/^	kDNSFlag1_RC_NotZone  = 0x0A$/;"	e	enum:__anon8
kDNSFlag1_RC_Refused	DNSCommon.h	/^	kDNSFlag1_RC_Refused  = 0x05,$/;"	e	enum:__anon8
kDNSFlag1_RC_ServFail	DNSCommon.h	/^	kDNSFlag1_RC_ServFail = 0x02,$/;"	e	enum:__anon8
kDNSFlag1_RC_YXDomain	DNSCommon.h	/^	kDNSFlag1_RC_YXDomain = 0x06,$/;"	e	enum:__anon8
kDNSFlag1_RC_YXRRSet	DNSCommon.h	/^	kDNSFlag1_RC_YXRRSet  = 0x07,$/;"	e	enum:__anon8
kDNSFlag1_Zero	DNSCommon.h	/^	kDNSFlag1_Zero        = 0x40,		\/\/ Reserved; must be zero$/;"	e	enum:__anon8
kDNSOpt_LLQ	mDNSEmbeddedAPI.h	1608;"	d
kDNSOpt_Lease	mDNSEmbeddedAPI.h	1609;"	d
kDNSOpt_NSID	mDNSEmbeddedAPI.h	1610;"	d
kDNSOpt_Owner	mDNSEmbeddedAPI.h	1611;"	d
kDNSQClass_ANY	mDNSEmbeddedAPI.h	/^	kDNSQClass_ANY             = 255,	\/\/ Not a DNS class, but a DNS query class, meaning "all classes"$/;"	e	enum:__anon16
kDNSQClass_UnicastResponse	mDNSEmbeddedAPI.h	/^	kDNSQClass_UnicastResponse = 0x8000	\/\/ Top bit set in a question means "unicast response acceptable"$/;"	e	enum:__anon16
kDNSQType_ANY	mDNSEmbeddedAPI.h	/^	kDNSQType_ANY			\/\/ Not a DNS type, but a DNS query type, meaning "all types"$/;"	e	enum:__anon17
kDNSRecordTypeActiveMask	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeActiveMask       = (kDNSRecordTypeAdvisory | kDNSRecordTypeShared | kDNSRecordTypeVerified | kDNSRecordTypeKnownUnique),$/;"	e	enum:__anon31
kDNSRecordTypeAdvisory	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeAdvisory         = 0x04,	\/\/ Like Shared, but no goodbye packet$/;"	e	enum:__anon31
kDNSRecordTypeDeregistering	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeDeregistering    = 0x01,	\/\/ Shared record about to announce its departure and leave the list$/;"	e	enum:__anon31
kDNSRecordTypeKnownUnique	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeKnownUnique      = 0x20,	\/\/ Known Unique means mDNS can assume name is unique without checking$/;"	e	enum:__anon31
kDNSRecordTypePacketAdd	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAdd        = 0x80,	\/\/ Received in the Additional  Section of a DNS Response$/;"	e	enum:__anon31
kDNSRecordTypePacketAddUnique	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAddUnique  = 0x90,	\/\/ Received in the Additional  Section of a DNS Response with kDNSClass_UniqueRRSet set$/;"	e	enum:__anon31
kDNSRecordTypePacketAns	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAns        = 0xC0,	\/\/ Received in the Answer      Section of a DNS Response$/;"	e	enum:__anon31
kDNSRecordTypePacketAnsUnique	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAnsUnique  = 0xD0,	\/\/ Received in the Answer      Section of a DNS Response with kDNSClass_UniqueRRSet set$/;"	e	enum:__anon31
kDNSRecordTypePacketAuth	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAuth       = 0xA0,	\/\/ Received in the Authorities Section of a DNS Response$/;"	e	enum:__anon31
kDNSRecordTypePacketAuthUnique	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketAuthUnique = 0xB0,	\/\/ Received in the Authorities Section of a DNS Response with kDNSClass_UniqueRRSet set$/;"	e	enum:__anon31
kDNSRecordTypePacketNegative	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketNegative   = 0xF0,	\/\/ Pseudo-RR generated to cache non-existence results like NXDomain$/;"	e	enum:__anon31
kDNSRecordTypePacketUniqueMask	mDNSEmbeddedAPI.h	/^	kDNSRecordTypePacketUniqueMask = 0x10	\/\/ True for PacketAddUnique, PacketAnsUnique, PacketAuthUnique$/;"	e	enum:__anon31
kDNSRecordTypeShared	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeShared           = 0x08,	\/\/ Shared means record name does not have to be unique -- use random delay on responses$/;"	e	enum:__anon31
kDNSRecordTypeUnique	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeUnique           = 0x02,	\/\/ Will become a kDNSRecordTypeVerified when probing is complete$/;"	e	enum:__anon31
kDNSRecordTypeUniqueMask	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeUniqueMask       = (kDNSRecordTypeUnique | kDNSRecordTypeVerified | kDNSRecordTypeKnownUnique),$/;"	e	enum:__anon31
kDNSRecordTypeUnregistered	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeUnregistered     = 0x00,	\/\/ Not currently in any list$/;"	e	enum:__anon31
kDNSRecordTypeVerified	mDNSEmbeddedAPI.h	/^	kDNSRecordTypeVerified         = 0x10,	\/\/ Unique means mDNS should check that name is unique (and then send immediate responses)$/;"	e	enum:__anon31
kDNSServiceClass_IN	dns_sd.h	/^    kDNSServiceClass_IN       = 1       \/* Internet *\/$/;"	e	enum:__anon62
kDNSServiceCompMulticastDNS	dns_sd.h	2338;"	d
kDNSServiceCompPrivateDNS	dns_sd.h	2337;"	d
kDNSServiceErr_AlreadyRegistered	dns_sd.h	/^    kDNSServiceErr_AlreadyRegistered         = -65547,$/;"	e	enum:__anon64
kDNSServiceErr_BadFlags	dns_sd.h	/^    kDNSServiceErr_BadFlags                  = -65543,$/;"	e	enum:__anon64
kDNSServiceErr_BadInterfaceIndex	dns_sd.h	/^    kDNSServiceErr_BadInterfaceIndex         = -65552,$/;"	e	enum:__anon64
kDNSServiceErr_BadKey	dns_sd.h	/^    kDNSServiceErr_BadKey                    = -65561,$/;"	e	enum:__anon64
kDNSServiceErr_BadParam	dns_sd.h	/^    kDNSServiceErr_BadParam                  = -65540,$/;"	e	enum:__anon64
kDNSServiceErr_BadReference	dns_sd.h	/^    kDNSServiceErr_BadReference              = -65541,$/;"	e	enum:__anon64
kDNSServiceErr_BadSig	dns_sd.h	/^    kDNSServiceErr_BadSig                    = -65560,$/;"	e	enum:__anon64
kDNSServiceErr_BadState	dns_sd.h	/^    kDNSServiceErr_BadState                  = -65542,$/;"	e	enum:__anon64
kDNSServiceErr_BadTime	dns_sd.h	/^    kDNSServiceErr_BadTime                   = -65559,  \/* Codes up to here existed in Tiger *\/$/;"	e	enum:__anon64
kDNSServiceErr_DoubleNAT	dns_sd.h	/^    kDNSServiceErr_DoubleNAT                 = -65558,$/;"	e	enum:__anon64
kDNSServiceErr_Firewall	dns_sd.h	/^    kDNSServiceErr_Firewall                  = -65550,$/;"	e	enum:__anon64
kDNSServiceErr_Incompatible	dns_sd.h	/^    kDNSServiceErr_Incompatible              = -65551,  \/* client library incompatible with daemon *\/$/;"	e	enum:__anon64
kDNSServiceErr_Invalid	dns_sd.h	/^    kDNSServiceErr_Invalid                   = -65549,$/;"	e	enum:__anon64
kDNSServiceErr_NATPortMappingDisabled	dns_sd.h	/^    kDNSServiceErr_NATPortMappingDisabled    = -65565,  \/* NAT supports NAT-PMP or UPnP but it's disabled by the administrator *\/$/;"	e	enum:__anon64
kDNSServiceErr_NATPortMappingUnsupported	dns_sd.h	/^    kDNSServiceErr_NATPortMappingUnsupported = -65564,  \/* NAT doesn't support NAT-PMP or UPnP *\/$/;"	e	enum:__anon64
kDNSServiceErr_NATTraversal	dns_sd.h	/^    kDNSServiceErr_NATTraversal              = -65557,$/;"	e	enum:__anon64
kDNSServiceErr_NameConflict	dns_sd.h	/^    kDNSServiceErr_NameConflict              = -65548,$/;"	e	enum:__anon64
kDNSServiceErr_NoAuth	dns_sd.h	/^    kDNSServiceErr_NoAuth                    = -65555,$/;"	e	enum:__anon64
kDNSServiceErr_NoError	dns_sd.h	/^    kDNSServiceErr_NoError                   = 0,$/;"	e	enum:__anon64
kDNSServiceErr_NoMemory	dns_sd.h	/^    kDNSServiceErr_NoMemory                  = -65539,$/;"	e	enum:__anon64
kDNSServiceErr_NoRouter	dns_sd.h	/^    kDNSServiceErr_NoRouter                  = -65566,  \/* No router currently configured (probably no network connectivity) *\/$/;"	e	enum:__anon64
kDNSServiceErr_NoSuchKey	dns_sd.h	/^    kDNSServiceErr_NoSuchKey                 = -65556,$/;"	e	enum:__anon64
kDNSServiceErr_NoSuchName	dns_sd.h	/^    kDNSServiceErr_NoSuchName                = -65538,$/;"	e	enum:__anon64
kDNSServiceErr_NoSuchRecord	dns_sd.h	/^    kDNSServiceErr_NoSuchRecord              = -65554,$/;"	e	enum:__anon64
kDNSServiceErr_NotInitialized	dns_sd.h	/^    kDNSServiceErr_NotInitialized            = -65545,$/;"	e	enum:__anon64
kDNSServiceErr_PollingMode	dns_sd.h	/^    kDNSServiceErr_PollingMode               = -65567$/;"	e	enum:__anon64
kDNSServiceErr_Refused	dns_sd.h	/^    kDNSServiceErr_Refused                   = -65553,$/;"	e	enum:__anon64
kDNSServiceErr_ServiceNotRunning	dns_sd.h	/^    kDNSServiceErr_ServiceNotRunning         = -65563,  \/* Background daemon not running *\/$/;"	e	enum:__anon64
kDNSServiceErr_Transient	dns_sd.h	/^    kDNSServiceErr_Transient                 = -65562,$/;"	e	enum:__anon64
kDNSServiceErr_Unknown	dns_sd.h	/^    kDNSServiceErr_Unknown                   = -65537,  \/* 0xFFFE FFFF *\/$/;"	e	enum:__anon64
kDNSServiceErr_Unsupported	dns_sd.h	/^    kDNSServiceErr_Unsupported               = -65544,$/;"	e	enum:__anon64
kDNSServiceFlagsAdd	dns_sd.h	/^    kDNSServiceFlagsAdd                 = 0x2,$/;"	e	enum:__anon60
kDNSServiceFlagsAllowRemoteQuery	dns_sd.h	/^    kDNSServiceFlagsAllowRemoteQuery    = 0x200,$/;"	e	enum:__anon60
kDNSServiceFlagsBrowseDomains	dns_sd.h	/^    kDNSServiceFlagsBrowseDomains       = 0x40,$/;"	e	enum:__anon60
kDNSServiceFlagsDefault	dns_sd.h	/^    kDNSServiceFlagsDefault             = 0x4,$/;"	e	enum:__anon60
kDNSServiceFlagsForce	dns_sd.h	/^    kDNSServiceFlagsForce               = 0x800,$/;"	e	enum:__anon60
kDNSServiceFlagsForceMulticast	dns_sd.h	/^    kDNSServiceFlagsForceMulticast      = 0x400,$/;"	e	enum:__anon60
kDNSServiceFlagsLongLivedQuery	dns_sd.h	/^    kDNSServiceFlagsLongLivedQuery      = 0x100,$/;"	e	enum:__anon60
kDNSServiceFlagsMoreComing	dns_sd.h	/^    kDNSServiceFlagsMoreComing          = 0x1,$/;"	e	enum:__anon60
kDNSServiceFlagsNoAutoRename	dns_sd.h	/^    kDNSServiceFlagsNoAutoRename        = 0x8,$/;"	e	enum:__anon60
kDNSServiceFlagsNonBrowsable	dns_sd.h	/^    kDNSServiceFlagsNonBrowsable        = 0x2000,$/;"	e	enum:__anon60
kDNSServiceFlagsRegistrationDomains	dns_sd.h	/^    kDNSServiceFlagsRegistrationDomains = 0x80,$/;"	e	enum:__anon60
kDNSServiceFlagsReturnIntermediates	dns_sd.h	/^    kDNSServiceFlagsReturnIntermediates = 0x1000,$/;"	e	enum:__anon60
kDNSServiceFlagsShareConnection	dns_sd.h	/^    kDNSServiceFlagsShareConnection     = 0x4000,$/;"	e	enum:__anon60
kDNSServiceFlagsShared	dns_sd.h	/^    kDNSServiceFlagsShared              = 0x10,$/;"	e	enum:__anon60
kDNSServiceFlagsSuppressUnusable	dns_sd.h	/^    kDNSServiceFlagsSuppressUnusable    = 0x8000$/;"	e	enum:__anon60
kDNSServiceFlagsUnique	dns_sd.h	/^    kDNSServiceFlagsUnique              = 0x20,$/;"	e	enum:__anon60
kDNSServiceInterfaceIndexAny	dns_sd.h	572;"	d
kDNSServiceInterfaceIndexLocalOnly	dns_sd.h	573;"	d
kDNSServiceInterfaceIndexUnicast	dns_sd.h	574;"	d
kDNSServiceMaxDomainName	dns_sd.h	487;"	d
kDNSServiceMaxServiceName	dns_sd.h	482;"	d
kDNSServiceProperty_DaemonVersion	dns_sd.h	634;"	d
kDNSServiceProtocol_IPv4	dns_sd.h	/^    kDNSServiceProtocol_IPv4 = 0x01,$/;"	e	enum:__anon61
kDNSServiceProtocol_IPv6	dns_sd.h	/^    kDNSServiceProtocol_IPv6 = 0x02,$/;"	e	enum:__anon61
kDNSServiceProtocol_TCP	dns_sd.h	/^    kDNSServiceProtocol_TCP  = 0x20$/;"	e	enum:__anon61
kDNSServiceProtocol_UDP	dns_sd.h	/^    kDNSServiceProtocol_UDP  = 0x10,$/;"	e	enum:__anon61
kDNSServiceType_A	dns_sd.h	/^    kDNSServiceType_A         = 1,      \/* Host address. *\/$/;"	e	enum:__anon63
kDNSServiceType_A6	dns_sd.h	/^    kDNSServiceType_A6        = 38,     \/* IPv6 Address (deprecated) *\/$/;"	e	enum:__anon63
kDNSServiceType_AAAA	dns_sd.h	/^    kDNSServiceType_AAAA      = 28,     \/* IPv6 Address. *\/$/;"	e	enum:__anon63
kDNSServiceType_AFSDB	dns_sd.h	/^    kDNSServiceType_AFSDB     = 18,     \/* AFS cell database. *\/$/;"	e	enum:__anon63
kDNSServiceType_ANY	dns_sd.h	/^    kDNSServiceType_ANY       = 255     \/* Wildcard match. *\/$/;"	e	enum:__anon63
kDNSServiceType_APL	dns_sd.h	/^    kDNSServiceType_APL       = 42,     \/* Address Prefix List *\/$/;"	e	enum:__anon63
kDNSServiceType_ATMA	dns_sd.h	/^    kDNSServiceType_ATMA      = 34,     \/* ATM Address *\/$/;"	e	enum:__anon63
kDNSServiceType_AXFR	dns_sd.h	/^    kDNSServiceType_AXFR      = 252,    \/* Transfer zone of authority. *\/$/;"	e	enum:__anon63
kDNSServiceType_CERT	dns_sd.h	/^    kDNSServiceType_CERT      = 37,     \/* Certification record *\/$/;"	e	enum:__anon63
kDNSServiceType_CNAME	dns_sd.h	/^    kDNSServiceType_CNAME     = 5,      \/* Canonical name. *\/$/;"	e	enum:__anon63
kDNSServiceType_DHCID	dns_sd.h	/^    kDNSServiceType_DHCID     = 49,     \/* DHCP Client Identifier *\/$/;"	e	enum:__anon63
kDNSServiceType_DNAME	dns_sd.h	/^    kDNSServiceType_DNAME     = 39,     \/* Non-terminal DNAME (for IPv6) *\/$/;"	e	enum:__anon63
kDNSServiceType_DNSKEY	dns_sd.h	/^    kDNSServiceType_DNSKEY    = 48,     \/* DNSKEY *\/$/;"	e	enum:__anon63
kDNSServiceType_DS	dns_sd.h	/^    kDNSServiceType_DS        = 43,     \/* Delegation Signer *\/$/;"	e	enum:__anon63
kDNSServiceType_EID	dns_sd.h	/^    kDNSServiceType_EID       = 31,     \/* Endpoint identifier. *\/$/;"	e	enum:__anon63
kDNSServiceType_GID	dns_sd.h	/^    kDNSServiceType_GID       = 102,    \/* IANA-Reserved *\/$/;"	e	enum:__anon63
kDNSServiceType_GPOS	dns_sd.h	/^    kDNSServiceType_GPOS      = 27,     \/* Geographical position (withdrawn). *\/$/;"	e	enum:__anon63
kDNSServiceType_HINFO	dns_sd.h	/^    kDNSServiceType_HINFO     = 13,     \/* Host information. *\/$/;"	e	enum:__anon63
kDNSServiceType_HIP	dns_sd.h	/^    kDNSServiceType_HIP       = 55,     \/* Host Identity Protocol *\/$/;"	e	enum:__anon63
kDNSServiceType_IPSECKEY	dns_sd.h	/^    kDNSServiceType_IPSECKEY  = 45,     \/* IPSECKEY *\/$/;"	e	enum:__anon63
kDNSServiceType_ISDN	dns_sd.h	/^    kDNSServiceType_ISDN      = 20,     \/* ISDN calling address. *\/$/;"	e	enum:__anon63
kDNSServiceType_IXFR	dns_sd.h	/^    kDNSServiceType_IXFR      = 251,    \/* Incremental zone transfer. *\/$/;"	e	enum:__anon63
kDNSServiceType_KEY	dns_sd.h	/^    kDNSServiceType_KEY       = 25,     \/* Security key. *\/$/;"	e	enum:__anon63
kDNSServiceType_KX	dns_sd.h	/^    kDNSServiceType_KX        = 36,     \/* Key Exchange *\/$/;"	e	enum:__anon63
kDNSServiceType_LOC	dns_sd.h	/^    kDNSServiceType_LOC       = 29,     \/* Location Information. *\/$/;"	e	enum:__anon63
kDNSServiceType_MAILA	dns_sd.h	/^    kDNSServiceType_MAILA     = 254,    \/* Transfer mail agent records. *\/$/;"	e	enum:__anon63
kDNSServiceType_MAILB	dns_sd.h	/^    kDNSServiceType_MAILB     = 253,    \/* Transfer mailbox records. *\/$/;"	e	enum:__anon63
kDNSServiceType_MB	dns_sd.h	/^    kDNSServiceType_MB        = 7,      \/* Mailbox domain name. *\/$/;"	e	enum:__anon63
kDNSServiceType_MD	dns_sd.h	/^    kDNSServiceType_MD        = 3,      \/* Mail destination. *\/$/;"	e	enum:__anon63
kDNSServiceType_MF	dns_sd.h	/^    kDNSServiceType_MF        = 4,      \/* Mail forwarder. *\/$/;"	e	enum:__anon63
kDNSServiceType_MG	dns_sd.h	/^    kDNSServiceType_MG        = 8,      \/* Mail group member. *\/$/;"	e	enum:__anon63
kDNSServiceType_MINFO	dns_sd.h	/^    kDNSServiceType_MINFO     = 14,     \/* Mailbox information. *\/$/;"	e	enum:__anon63
kDNSServiceType_MR	dns_sd.h	/^    kDNSServiceType_MR        = 9,      \/* Mail rename name. *\/$/;"	e	enum:__anon63
kDNSServiceType_MX	dns_sd.h	/^    kDNSServiceType_MX        = 15,     \/* Mail routing information. *\/$/;"	e	enum:__anon63
kDNSServiceType_NAPTR	dns_sd.h	/^    kDNSServiceType_NAPTR     = 35,     \/* Naming Authority PoinTeR *\/$/;"	e	enum:__anon63
kDNSServiceType_NIMLOC	dns_sd.h	/^    kDNSServiceType_NIMLOC    = 32,     \/* Nimrod Locator. *\/$/;"	e	enum:__anon63
kDNSServiceType_NS	dns_sd.h	/^    kDNSServiceType_NS        = 2,      \/* Authoritative server. *\/$/;"	e	enum:__anon63
kDNSServiceType_NSAP	dns_sd.h	/^    kDNSServiceType_NSAP      = 22,     \/* NSAP address. *\/$/;"	e	enum:__anon63
kDNSServiceType_NSAP_PTR	dns_sd.h	/^    kDNSServiceType_NSAP_PTR  = 23,     \/* Reverse NSAP lookup (deprecated). *\/$/;"	e	enum:__anon63
kDNSServiceType_NSEC	dns_sd.h	/^    kDNSServiceType_NSEC      = 47,     \/* Denial of Existence *\/$/;"	e	enum:__anon63
kDNSServiceType_NSEC3	dns_sd.h	/^    kDNSServiceType_NSEC3     = 50,     \/* Hashed Authenticated Denial of Existence *\/$/;"	e	enum:__anon63
kDNSServiceType_NSEC3PARAM	dns_sd.h	/^    kDNSServiceType_NSEC3PARAM= 51,     \/* Hashed Authenticated Denial of Existence *\/$/;"	e	enum:__anon63
kDNSServiceType_NULL	dns_sd.h	/^    kDNSServiceType_NULL      = 10,     \/* Null resource record. *\/$/;"	e	enum:__anon63
kDNSServiceType_NXT	dns_sd.h	/^    kDNSServiceType_NXT       = 30,     \/* Next domain (security). *\/$/;"	e	enum:__anon63
kDNSServiceType_OPT	dns_sd.h	/^    kDNSServiceType_OPT       = 41,     \/* EDNS0 option (meta-RR) *\/$/;"	e	enum:__anon63
kDNSServiceType_PTR	dns_sd.h	/^    kDNSServiceType_PTR       = 12,     \/* Domain name pointer. *\/$/;"	e	enum:__anon63
kDNSServiceType_PX	dns_sd.h	/^    kDNSServiceType_PX        = 26,     \/* X.400 mail mapping. *\/$/;"	e	enum:__anon63
kDNSServiceType_RP	dns_sd.h	/^    kDNSServiceType_RP        = 17,     \/* Responsible person. *\/$/;"	e	enum:__anon63
kDNSServiceType_RRSIG	dns_sd.h	/^    kDNSServiceType_RRSIG     = 46,     \/* RRSIG *\/$/;"	e	enum:__anon63
kDNSServiceType_RT	dns_sd.h	/^    kDNSServiceType_RT        = 21,     \/* Router. *\/$/;"	e	enum:__anon63
kDNSServiceType_SIG	dns_sd.h	/^    kDNSServiceType_SIG       = 24,     \/* Security signature. *\/$/;"	e	enum:__anon63
kDNSServiceType_SINK	dns_sd.h	/^    kDNSServiceType_SINK      = 40,     \/* Kitchen sink (experimental) *\/$/;"	e	enum:__anon63
kDNSServiceType_SOA	dns_sd.h	/^    kDNSServiceType_SOA       = 6,      \/* Start of authority zone. *\/$/;"	e	enum:__anon63
kDNSServiceType_SPF	dns_sd.h	/^    kDNSServiceType_SPF       = 99,     \/* Sender Policy Framework for E-Mail *\/$/;"	e	enum:__anon63
kDNSServiceType_SRV	dns_sd.h	/^    kDNSServiceType_SRV       = 33,     \/* Server Selection. *\/$/;"	e	enum:__anon63
kDNSServiceType_SSHFP	dns_sd.h	/^    kDNSServiceType_SSHFP     = 44,     \/* SSH Key Fingerprint *\/$/;"	e	enum:__anon63
kDNSServiceType_TKEY	dns_sd.h	/^    kDNSServiceType_TKEY      = 249,    \/* Transaction key *\/$/;"	e	enum:__anon63
kDNSServiceType_TSIG	dns_sd.h	/^    kDNSServiceType_TSIG      = 250,    \/* Transaction signature. *\/$/;"	e	enum:__anon63
kDNSServiceType_TXT	dns_sd.h	/^    kDNSServiceType_TXT       = 16,     \/* One or more text strings (NOT "zero or more..."). *\/$/;"	e	enum:__anon63
kDNSServiceType_UID	dns_sd.h	/^    kDNSServiceType_UID       = 101,    \/* IANA-Reserved *\/$/;"	e	enum:__anon63
kDNSServiceType_UINFO	dns_sd.h	/^    kDNSServiceType_UINFO     = 100,    \/* IANA-Reserved *\/$/;"	e	enum:__anon63
kDNSServiceType_UNSPEC	dns_sd.h	/^    kDNSServiceType_UNSPEC    = 103,    \/* IANA-Reserved *\/$/;"	e	enum:__anon63
kDNSServiceType_WKS	dns_sd.h	/^    kDNSServiceType_WKS       = 11,     \/* Well known service. *\/$/;"	e	enum:__anon63
kDNSServiceType_X25	dns_sd.h	/^    kDNSServiceType_X25       = 19,     \/* X_25 calling address. *\/$/;"	e	enum:__anon63
kDNSType_A	mDNSEmbeddedAPI.h	/^	kDNSType_A = 1,			\/\/  1 Address$/;"	e	enum:__anon17
kDNSType_A6	mDNSEmbeddedAPI.h	/^	kDNSType_A6,			\/\/ 38 IPv6 Address (deprecated)$/;"	e	enum:__anon17
kDNSType_AAAA	mDNSEmbeddedAPI.h	/^	kDNSType_AAAA,			\/\/ 28 IPv6 Address$/;"	e	enum:__anon17
kDNSType_AFSDB	mDNSEmbeddedAPI.h	/^	kDNSType_AFSDB,			\/\/ 18 AFS cell database$/;"	e	enum:__anon17
kDNSType_APL	mDNSEmbeddedAPI.h	/^	kDNSType_APL,			\/\/ 42 Address Prefix List$/;"	e	enum:__anon17
kDNSType_ATMA	mDNSEmbeddedAPI.h	/^	kDNSType_ATMA,			\/\/ 34 ATM Address$/;"	e	enum:__anon17
kDNSType_AXFR	mDNSEmbeddedAPI.h	/^	kDNSType_AXFR,			\/\/ 252 Transfer zone of authority$/;"	e	enum:__anon17
kDNSType_CERT	mDNSEmbeddedAPI.h	/^	kDNSType_CERT,			\/\/ 37 Certification record$/;"	e	enum:__anon17
kDNSType_CNAME	mDNSEmbeddedAPI.h	/^	kDNSType_CNAME,			\/\/  5 Canonical Name$/;"	e	enum:__anon17
kDNSType_DHCID	mDNSEmbeddedAPI.h	/^	kDNSType_DHCID,			\/\/ 49 DHCP Client Identifier$/;"	e	enum:__anon17
kDNSType_DNAME	mDNSEmbeddedAPI.h	/^	kDNSType_DNAME,			\/\/ 39 Non-terminal DNAME (for IPv6)$/;"	e	enum:__anon17
kDNSType_DNSKEY	mDNSEmbeddedAPI.h	/^	kDNSType_DNSKEY,		\/\/ 48 DNSKEY$/;"	e	enum:__anon17
kDNSType_DS	mDNSEmbeddedAPI.h	/^	kDNSType_DS,			\/\/ 43 Delegation Signer$/;"	e	enum:__anon17
kDNSType_EID	mDNSEmbeddedAPI.h	/^	kDNSType_EID,			\/\/ 31 Endpoint identifier$/;"	e	enum:__anon17
kDNSType_GID	mDNSEmbeddedAPI.h	/^	kDNSType_GID,			\/\/ 102 IANA-Reserved$/;"	e	enum:__anon17
kDNSType_GPOS	mDNSEmbeddedAPI.h	/^	kDNSType_GPOS,			\/\/ 27 Geographical position (withdrawn)$/;"	e	enum:__anon17
kDNSType_HINFO	mDNSEmbeddedAPI.h	/^	kDNSType_HINFO,			\/\/ 13 Host information$/;"	e	enum:__anon17
kDNSType_HIP	mDNSEmbeddedAPI.h	/^	kDNSType_HIP = 55,		\/\/ 55 Host Identity Protocol$/;"	e	enum:__anon17
kDNSType_IPSECKEY	mDNSEmbeddedAPI.h	/^	kDNSType_IPSECKEY,		\/\/ 45 IPSECKEY$/;"	e	enum:__anon17
kDNSType_ISDN	mDNSEmbeddedAPI.h	/^	kDNSType_ISDN,			\/\/ 20 ISDN calling address$/;"	e	enum:__anon17
kDNSType_IXFR	mDNSEmbeddedAPI.h	/^	kDNSType_IXFR,			\/\/ 251 Incremental zone transfer$/;"	e	enum:__anon17
kDNSType_KEY	mDNSEmbeddedAPI.h	/^	kDNSType_KEY,			\/\/ 25 Security key$/;"	e	enum:__anon17
kDNSType_KX	mDNSEmbeddedAPI.h	/^	kDNSType_KX,			\/\/ 36 Key Exchange$/;"	e	enum:__anon17
kDNSType_LOC	mDNSEmbeddedAPI.h	/^	kDNSType_LOC,			\/\/ 29 Location Information$/;"	e	enum:__anon17
kDNSType_MAILA	mDNSEmbeddedAPI.h	/^	kDNSType_MAILA,			\/\/ 254 Transfer mail agent records$/;"	e	enum:__anon17
kDNSType_MAILB	mDNSEmbeddedAPI.h	/^	kDNSType_MAILB,			\/\/ 253 Transfer mailbox records$/;"	e	enum:__anon17
kDNSType_MB	mDNSEmbeddedAPI.h	/^	kDNSType_MB,			\/\/  7 Mailbox$/;"	e	enum:__anon17
kDNSType_MD	mDNSEmbeddedAPI.h	/^	kDNSType_MD,			\/\/  3 Mail Destination$/;"	e	enum:__anon17
kDNSType_MF	mDNSEmbeddedAPI.h	/^	kDNSType_MF,			\/\/  4 Mail Forwarder$/;"	e	enum:__anon17
kDNSType_MG	mDNSEmbeddedAPI.h	/^	kDNSType_MG,			\/\/  8 Mail Group$/;"	e	enum:__anon17
kDNSType_MINFO	mDNSEmbeddedAPI.h	/^	kDNSType_MINFO,			\/\/ 14 Mailbox information$/;"	e	enum:__anon17
kDNSType_MR	mDNSEmbeddedAPI.h	/^	kDNSType_MR,			\/\/  9 Mail Rename$/;"	e	enum:__anon17
kDNSType_MX	mDNSEmbeddedAPI.h	/^	kDNSType_MX,			\/\/ 15 Mail Exchanger$/;"	e	enum:__anon17
kDNSType_NAPTR	mDNSEmbeddedAPI.h	/^	kDNSType_NAPTR,			\/\/ 35 Naming Authority PoinTeR$/;"	e	enum:__anon17
kDNSType_NIMLOC	mDNSEmbeddedAPI.h	/^	kDNSType_NIMLOC,		\/\/ 32 Nimrod Locator$/;"	e	enum:__anon17
kDNSType_NS	mDNSEmbeddedAPI.h	/^	kDNSType_NS,			\/\/  2 Name Server$/;"	e	enum:__anon17
kDNSType_NSAP	mDNSEmbeddedAPI.h	/^	kDNSType_NSAP,			\/\/ 22 NSAP address$/;"	e	enum:__anon17
kDNSType_NSAP_PTR	mDNSEmbeddedAPI.h	/^	kDNSType_NSAP_PTR,		\/\/ 23 Reverse NSAP lookup (deprecated)$/;"	e	enum:__anon17
kDNSType_NSEC	mDNSEmbeddedAPI.h	/^	kDNSType_NSEC,			\/\/ 47 Denial of Existence$/;"	e	enum:__anon17
kDNSType_NSEC3	mDNSEmbeddedAPI.h	/^	kDNSType_NSEC3,			\/\/ 50 Hashed Authenticated Denial of Existence$/;"	e	enum:__anon17
kDNSType_NSEC3PARAM	mDNSEmbeddedAPI.h	/^	kDNSType_NSEC3PARAM,	\/\/ 51 Hashed Authenticated Denial of Existence$/;"	e	enum:__anon17
kDNSType_NULL	mDNSEmbeddedAPI.h	/^	kDNSType_NULL,			\/\/ 10 NULL RR$/;"	e	enum:__anon17
kDNSType_NXT	mDNSEmbeddedAPI.h	/^	kDNSType_NXT,			\/\/ 30 Next domain (security)$/;"	e	enum:__anon17
kDNSType_OPT	mDNSEmbeddedAPI.h	/^	kDNSType_OPT,			\/\/ 41 EDNS0 option (meta-RR)$/;"	e	enum:__anon17
kDNSType_PTR	mDNSEmbeddedAPI.h	/^	kDNSType_PTR,			\/\/ 12 Domain name pointer$/;"	e	enum:__anon17
kDNSType_PX	mDNSEmbeddedAPI.h	/^	kDNSType_PX,			\/\/ 26 X.400 mail mapping$/;"	e	enum:__anon17
kDNSType_RP	mDNSEmbeddedAPI.h	/^	kDNSType_RP,			\/\/ 17 Responsible person$/;"	e	enum:__anon17
kDNSType_RRSIG	mDNSEmbeddedAPI.h	/^	kDNSType_RRSIG,			\/\/ 46 RRSIG$/;"	e	enum:__anon17
kDNSType_RT	mDNSEmbeddedAPI.h	/^	kDNSType_RT,			\/\/ 21 Router$/;"	e	enum:__anon17
kDNSType_SIG	mDNSEmbeddedAPI.h	/^	kDNSType_SIG,			\/\/ 24 Security signature$/;"	e	enum:__anon17
kDNSType_SINK	mDNSEmbeddedAPI.h	/^	kDNSType_SINK,			\/\/ 40 Kitchen sink (experimental)$/;"	e	enum:__anon17
kDNSType_SOA	mDNSEmbeddedAPI.h	/^	kDNSType_SOA,			\/\/  6 Start of Authority$/;"	e	enum:__anon17
kDNSType_SPF	mDNSEmbeddedAPI.h	/^	kDNSType_SPF = 99,		\/\/ 99 Sender Policy Framework for E-Mail$/;"	e	enum:__anon17
kDNSType_SRV	mDNSEmbeddedAPI.h	/^	kDNSType_SRV,			\/\/ 33 Service record$/;"	e	enum:__anon17
kDNSType_SSHFP	mDNSEmbeddedAPI.h	/^	kDNSType_SSHFP,			\/\/ 44 SSH Key Fingerprint$/;"	e	enum:__anon17
kDNSType_TKEY	mDNSEmbeddedAPI.h	/^	kDNSType_TKEY = 249,	\/\/ 249 Transaction key$/;"	e	enum:__anon17
kDNSType_TSIG	mDNSEmbeddedAPI.h	/^	kDNSType_TSIG,			\/\/ 250 Transaction signature$/;"	e	enum:__anon17
kDNSType_TXT	mDNSEmbeddedAPI.h	/^	kDNSType_TXT,			\/\/ 16 Arbitrary text string$/;"	e	enum:__anon17
kDNSType_UID	mDNSEmbeddedAPI.h	/^	kDNSType_UID,			\/\/ 101 IANA-Reserved$/;"	e	enum:__anon17
kDNSType_UINFO	mDNSEmbeddedAPI.h	/^	kDNSType_UINFO,			\/\/ 100 IANA-Reserved$/;"	e	enum:__anon17
kDNSType_UNSPEC	mDNSEmbeddedAPI.h	/^	kDNSType_UNSPEC,		\/\/ 103 IANA-Reserved$/;"	e	enum:__anon17
kDNSType_WKS	mDNSEmbeddedAPI.h	/^	kDNSType_WKS,			\/\/ 11 Well-known-service$/;"	e	enum:__anon17
kDNSType_X25	mDNSEmbeddedAPI.h	/^	kDNSType_X25,			\/\/ 19 X_25 calling address$/;"	e	enum:__anon17
kDefaultDomain	Client.c	/^static const char kDefaultDomain[]      = "local.";$/;"	v	file:
kDefaultPIDFile	Responder.c	/^static const char kDefaultPIDFile[]     = "\/var\/run\/mDNSResponder.pid";$/;"	v	file:
kDefaultPortNumber	Responder.c	/^    kDefaultPortNumber = 548$/;"	e	enum:__anon3	file:
kDefaultReconfirmTimeForFlappingInterface	mDNS.c	3154;"	d	file:
kDefaultReconfirmTimeForNoAnswer	mDNS.c	3153;"	d	file:
kDefaultReconfirmTimeForWake	mDNS.c	3152;"	d	file:
kDefaultServiceDomain	Responder.c	/^static const char kDefaultServiceDomain[] = "local.";$/;"	v	file:
kDefaultServiceType	Client.c	/^static const char kDefaultServiceType[] = "_afpovertcp._tcp";$/;"	v	file:
kDefaultServiceType	Responder.c	/^static const char kDefaultServiceType[] = "_afpovertcp._tcp.";$/;"	v	file:
kHostNameTTL	mDNSEmbeddedAPI.h	1343;"	d
kLLQOp_Event	mDNSEmbeddedAPI.h	2265;"	d
kLLQOp_Refresh	mDNSEmbeddedAPI.h	2264;"	d
kLLQOp_Setup	mDNSEmbeddedAPI.h	2263;"	d
kLLQ_DefLease	mDNSEmbeddedAPI.h	2259;"	d
kLLQ_INIT_RESEND	mDNSEmbeddedAPI.h	2261;"	d
kLLQ_MAX_TRIES	mDNSEmbeddedAPI.h	2260;"	d
kLLQ_Vers	mDNSEmbeddedAPI.h	2258;"	d
kMaxUpdateCredits	mDNS.c	1560;"	d	file:
kMinimumReconfirmTime	mDNS.c	3151;"	d	file:
kReportTopHosts	NetMonitor.c	198;"	d	file:
kReportTopServices	NetMonitor.c	197;"	d	file:
kStandardTTL	mDNSEmbeddedAPI.h	1342;"	d
kTCPSocketFlags_UseTLS	mDNSEmbeddedAPI.h	/^	kTCPSocketFlags_UseTLS = (1 << 0)$/;"	e	enum:__anon59
kTCPSocketFlags_Zero	mDNSEmbeddedAPI.h	/^	kTCPSocketFlags_Zero   = 0,$/;"	e	enum:__anon59
kUpdateCreditRefreshInterval	mDNS.c	1561;"	d	file:
k_addrs_max	nss_mdns.c	492;"	d	file:
k_aliases_max	nss_mdns.c	491;"	d	file:
k_comment_char	nss_mdns.c	/^const char k_comment_char = '#';$/;"	v
k_conf_file	nss_mdns.c	/^const char * k_conf_file = "\/etc\/nss_mdns.conf";$/;"	v
k_default_domains	nss_mdns.c	/^const char * k_default_domains [] =$/;"	v
k_dns_separator	nss_mdns.c	/^static const char k_dns_separator = '.';$/;"	v	file:
k_empty_config	nss_mdns.c	/^const config_t k_empty_config =$/;"	v
k_hostname_maxlen	nss_mdns.c	489;"	d	file:
k_keyword_domain	nss_mdns.c	/^const char * k_keyword_domain = "domain";$/;"	v
k_label_maxlen	nss_mdns.c	/^static const int k_label_maxlen = DNS_LABEL_MAXLEN;$/;"	v	file:
k_local_suffix	nss_mdns.c	/^static const char * k_local_suffix = "local";$/;"	v	file:
k_select_time	nss_mdns.c	/^	k_select_time = { 0, 500000 };$/;"	v	typeref:struct:timeval	file:
k_table_af	nss_mdns.c	/^static const table_entry_t k_table_af [] =$/;"	v	file:
k_table_af_size	nss_mdns.c	/^static const int k_table_af_size =$/;"	v	file:
k_table_ns_class	nss_mdns.c	/^static const char * k_table_ns_class [] =$/;"	v	file:
k_table_ns_class_size	nss_mdns.c	/^static const int k_table_ns_class_size =$/;"	v	file:
k_table_ns_type	nss_mdns.c	/^static const char * k_table_ns_type [] =$/;"	v	file:
k_table_ns_type_size	nss_mdns.c	/^static const int k_table_ns_type_size =$/;"	v	file:
keydata_ipad	mDNSEmbeddedAPI.h	/^	mDNSu8           keydata_ipad[HMAC_LEN];	\/\/ padded key for inner hash rounds$/;"	m	struct:DomainAuthInfo
keydata_opad	mDNSEmbeddedAPI.h	/^	mDNSu8           keydata_opad[HMAC_LEN];	\/\/ padded key for outer hash rounds$/;"	m	struct:DomainAuthInfo
keyname	mDNSEmbeddedAPI.h	/^	domainname       keyname;$/;"	m	struct:DomainAuthInfo
killmdnsd	mdnsd.sh	/^	killmdnsd() {$/;"	f
l	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 8]; mDNSu16 w[4]; mDNSu32 l[2]; } mDNSOpaque64;$/;"	m	union:__anon20
l	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[16]; mDNSu16 w[8]; mDNSu32 l[4]; } mDNSOpaque128;$/;"	m	union:__anon21
lSize	DNSCommon.c	/^	unsigned      lSize : 1;$/;"	m	struct:mDNSprintf_format	file:
lastid	Identify.c	/^static mDNSOpaque16 lastid, id;$/;"	v	file:
lastsrc	Identify.c	/^static mDNSAddr lastsrc, hostaddr, target;$/;"	v	file:
lasttest	mDNSEmbeddedAPI.h	/^	mDNSs32         lasttest;	\/\/ Time we sent last bug-detection query to this server$/;"	m	struct:DNSServer
leftJustify	DNSCommon.c	/^	unsigned      leftJustify : 1;$/;"	m	struct:mDNSprintf_format	file:
linenum	nss_mdns.c	/^	int linenum;$/;"	m	struct:__anon13	file:
llqOp	mDNSEmbeddedAPI.h	/^	mDNSu16      llqOp;$/;"	m	struct:__anon32
llqlease	mDNSEmbeddedAPI.h	/^	mDNSu32      llqlease;$/;"	m	struct:__anon32
load_config	nss_mdns.c	/^load_config (config_t * conf)$/;"	f	file:
loc_inner	mDNSEmbeddedAPI.h	/^	mDNSv6Addr loc_inner;$/;"	m	struct:ClientTunnel
loc_outer	mDNSEmbeddedAPI.h	/^	mDNSv4Addr loc_outer;$/;"	m	struct:ClientTunnel
localdomain	mDNSEmbeddedAPI.h	2771;"	d
lock_Questions	mDNSEmbeddedAPI.h	/^	mDNSu8  lock_Questions;$/;"	m	struct:mDNS_struct
lock_Records	mDNSEmbeddedAPI.h	/^	mDNSu8  lock_Records;$/;"	m	struct:mDNS_struct
lock_rrcache	mDNSEmbeddedAPI.h	/^	mDNSu8  lock_rrcache;				\/\/ For debugging: Set at times when these lists may not be modified$/;"	m	struct:mDNS_struct
m	mDNSEmbeddedAPI.h	/^	mDNS             *m;$/;"	m	struct:tcpInfo_t
m	mDNSEmbeddedAPI.h	/^	mDNS             *m;$/;"	m	struct:tcpLNTInfo_struct
m	mDNSEmbeddedAPI.h	/^	union { DNSMessage m; void *p; } imsg;  \/\/ Incoming message received from wire$/;"	m	union:mDNS_struct::__anon57
mDNS	mDNSEmbeddedAPI.h	/^typedef struct mDNS_struct mDNS;$/;"	t	typeref:struct:mDNS_struct
mDNS	mDNSPosix.c	/^	mDNS *mDNS;$/;"	m	struct:IfChangeRec	file:
mDNSAddr	mDNSEmbeddedAPI.h	/^	} mDNSAddr;$/;"	t	typeref:struct:__anon24
mDNSAddrIsDNSMulticast	DNSCommon.c	/^mDNSexport mDNSBool mDNSAddrIsDNSMulticast(const mDNSAddr *ip)$/;"	f
mDNSAddrIsRFC1918	mDNSEmbeddedAPI.h	3110;"	d
mDNSAddrType_IPv4	mDNSEmbeddedAPI.h	/^	mDNSAddrType_IPv4    = 4,$/;"	e	enum:__anon22
mDNSAddrType_IPv6	mDNSEmbeddedAPI.h	/^	mDNSAddrType_IPv6    = 6,$/;"	e	enum:__anon22
mDNSAddrType_None	mDNSEmbeddedAPI.h	/^	mDNSAddrType_None    = 0,$/;"	e	enum:__anon22
mDNSAddrType_Unknown	mDNSEmbeddedAPI.h	/^	mDNSAddrType_Unknown = ~0	\/\/ Special marker value used in known answer list recording$/;"	e	enum:__anon22
mDNSAddressIsAllDNSLinkGroup	mDNSEmbeddedAPI.h	3131;"	d
mDNSAddressIsLinkLocal	mDNSEmbeddedAPI.h	3154;"	d
mDNSAddressIsOnes	mDNSEmbeddedAPI.h	3143;"	d
mDNSAddressIsValid	mDNSEmbeddedAPI.h	3147;"	d
mDNSAddressIsValidNonZero	mDNSEmbeddedAPI.h	3139;"	d
mDNSAddressIsZero	mDNSEmbeddedAPI.h	3135;"	d
mDNSBool	mDNSEmbeddedAPI.h	/^typedef          int   mDNSBool;$/;"	t
mDNSCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSCallback(mDNS *const m, mStatus result);$/;"	t
mDNSCoreBeSleepProxyServer	mDNS.c	/^mDNSexport void mDNSCoreBeSleepProxyServer(mDNS *const m, mDNSu8 sps, mDNSu8 port, mDNSu8 marginalpower, mDNSu8 totpower)$/;"	f
mDNSCoreHaveAdvertisedMulticastServices	mDNS.c	/^mDNSexport mDNSBool mDNSCoreHaveAdvertisedMulticastServices(mDNS *const m)$/;"	f
mDNSCoreInitComplete	mDNS.c	/^mDNSexport void mDNSCoreInitComplete(mDNS *const m, mStatus result)$/;"	f
mDNSCoreIntervalToNextWake	mDNS.c	/^mDNSexport mDNSs32 mDNSCoreIntervalToNextWake(mDNS *const m, mDNSs32 now)$/;"	f
mDNSCoreMachineSleep	mDNS.c	/^mDNSexport void mDNSCoreMachineSleep(mDNS *const m, mDNSBool sleep)$/;"	f
mDNSCoreReadyForSleep	mDNS.c	/^mDNSexport mDNSBool mDNSCoreReadyForSleep(mDNS *m, mDNSs32 now)$/;"	f
mDNSCoreReceive	Identify.c	/^mDNSexport void mDNSCoreReceive(mDNS *const m, DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
mDNSCoreReceive	Identify.c	72;"	d	file:
mDNSCoreReceive	Identify.c	74;"	d	file:
mDNSCoreReceive	NetMonitor.c	/^mDNSexport void mDNSCoreReceive(mDNS *const m, DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
mDNSCoreReceive	NetMonitor.c	112;"	d	file:
mDNSCoreReceive	NetMonitor.c	114;"	d	file:
mDNSCoreReceive	mDNS.c	/^mDNSexport void mDNSCoreReceive(mDNS *const m, void *const pkt, const mDNSu8 *const end,$/;"	f
mDNSCoreReceiveQuery	mDNS.c	/^mDNSlocal void mDNSCoreReceiveQuery(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
mDNSCoreReceiveRawPacket	mDNS.c	/^mDNSexport void mDNSCoreReceiveRawPacket(mDNS *const m, const mDNSu8 *const p, const mDNSu8 *const end, const mDNSInterfaceID InterfaceID)$/;"	f
mDNSCoreReceiveResponse	mDNS.c	/^mDNSlocal void mDNSCoreReceiveResponse(mDNS *const m,$/;"	f
mDNSCoreReceiveUpdate	mDNS.c	/^mDNSlocal void mDNSCoreReceiveUpdate(mDNS *const m,$/;"	f
mDNSCoreReceiveUpdateR	mDNS.c	/^mDNSlocal void mDNSCoreReceiveUpdateR(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *end, const mDNSInterfaceID InterfaceID)$/;"	f
mDNSCoreRestartQueries	mDNS.c	/^mDNSexport void mDNSCoreRestartQueries(mDNS *const m)$/;"	f
mDNSEthAddr	mDNSEmbeddedAPI.h	/^typedef mDNSOpaque48  mDNSEthAddr;		\/\/ An Ethernet address is a six-byte opaque identifier (not an integer)$/;"	t
mDNSEthAddressIsZero	mDNSEmbeddedAPI.h	3126;"	d
mDNSIPPort	mDNSEmbeddedAPI.h	/^typedef mDNSOpaque16  mDNSIPPort;		\/\/ An IP port is a two-byte opaque identifier (not an integer)$/;"	t
mDNSIPPortIsZero	mDNSEmbeddedAPI.h	3121;"	d
mDNSIPv4AddressIsOnes	mDNSEmbeddedAPI.h	3128;"	d
mDNSIPv4AddressIsZero	mDNSEmbeddedAPI.h	3124;"	d
mDNSIPv6AddressIsOnes	mDNSEmbeddedAPI.h	3129;"	d
mDNSIPv6AddressIsZero	mDNSEmbeddedAPI.h	3125;"	d
mDNSInterfaceID	mDNSEmbeddedAPI.h	/^typedef struct mDNSInterfaceID_dummystruct { void *dummy; } *mDNSInterfaceID;$/;"	t	typeref:struct:mDNSInterfaceID_dummystruct
mDNSInterfaceID_dummystruct	mDNSEmbeddedAPI.h	/^typedef struct mDNSInterfaceID_dummystruct { void *dummy; } *mDNSInterfaceID;$/;"	s
mDNSInterfaceMark	DNSCommon.c	/^mDNSexport const mDNSInterfaceID mDNSInterfaceMark = (mDNSInterfaceID)-1;$/;"	v
mDNSInterface_Any	DNSCommon.c	/^mDNSexport const mDNSInterfaceID mDNSInterface_Any       = 0;$/;"	v
mDNSInterface_LocalOnly	DNSCommon.c	/^mDNSexport const mDNSInterfaceID mDNSInterface_LocalOnly = (mDNSInterfaceID)-2;$/;"	v
mDNSInterface_Unicast	DNSCommon.c	/^mDNSexport const mDNSInterfaceID mDNSInterface_Unicast   = (mDNSInterfaceID)-3;$/;"	v
mDNSIsDigit	DNSCommon.h	247;"	d
mDNSIsLetter	DNSCommon.h	250;"	d
mDNSIsLowerCase	DNSCommon.h	249;"	d
mDNSIsUpperCase	DNSCommon.h	248;"	d
mDNSLogLevel_t	mDNSDebug.h	/^	} mDNSLogLevel_t;$/;"	t	typeref:enum:__anon65
mDNSMixRandomSeed	DNSCommon.c	/^mDNSlocal mDNSu32 mDNSMixRandomSeed(mDNSu32 seed, mDNSu8 iteration)$/;"	f
mDNSNULL	mDNSEmbeddedAPI.h	1245;"	d
mDNSNetMonitor	NetMonitor.c	/^mDNSlocal mStatus mDNSNetMonitor(void)$/;"	f
mDNSOpaque128	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[16]; mDNSu16 w[8]; mDNSu32 l[4]; } mDNSOpaque128;$/;"	t	typeref:union:__anon21
mDNSOpaque16	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 2]; mDNSu16 NotAnInteger; } mDNSOpaque16;$/;"	t	typeref:union:__anon18
mDNSOpaque16IsZero	mDNSEmbeddedAPI.h	3122;"	d
mDNSOpaque16fromIntVal	mDNSEmbeddedAPI.h	/^mDNSinline mDNSOpaque16 mDNSOpaque16fromIntVal(mDNSu16 v)$/;"	f
mDNSOpaque32	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 4]; mDNSu32 NotAnInteger; } mDNSOpaque32;$/;"	t	typeref:union:__anon19
mDNSOpaque64	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 8]; mDNSu16 w[4]; mDNSu32 l[2]; } mDNSOpaque64;$/;"	t	typeref:union:__anon20
mDNSOpaque64IsZero	mDNSEmbeddedAPI.h	3123;"	d
mDNSPlatformClose	mDNSPosix.c	/^mDNSexport void mDNSPlatformClose(mDNS *const m)$/;"	f
mDNSPlatformDynDNSHostNameStatusChanged	mDNSPosix.c	/^mDNSexport void mDNSPlatformDynDNSHostNameStatusChanged(const domainname *const dname, const mStatus status)$/;"	f
mDNSPlatformGetPrimaryInterface	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformGetPrimaryInterface(mDNS * const m, mDNSAddr * v4, mDNSAddr * v6, mDNSAddr * router)$/;"	f
mDNSPlatformInit	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformInit(mDNS *const m)$/;"	f
mDNSPlatformInit_CanReceiveUnicast	mDNSPosix.c	/^mDNSlocal mDNSBool mDNSPlatformInit_CanReceiveUnicast(void)$/;"	f
mDNSPlatformInterfaceIDfromInterfaceIndex	mDNSPosix.c	/^mDNSexport mDNSInterfaceID mDNSPlatformInterfaceIDfromInterfaceIndex(mDNS *const m, mDNSu32 index)$/;"	f
mDNSPlatformInterfaceIndexfromInterfaceID	mDNSPosix.c	/^mDNSexport mDNSu32 mDNSPlatformInterfaceIndexfromInterfaceID(mDNS *const m, mDNSInterfaceID id)$/;"	f
mDNSPlatformLock	mDNSPosix.c	/^mDNSexport void    mDNSPlatformLock   (const mDNS *const m)$/;"	f
mDNSPlatformMemAllocate	mDNSEmbeddedAPI.h	3282;"	d
mDNSPlatformMemAllocate	mDNSPosix.c	/^mDNSexport void *  mDNSPlatformMemAllocate(mDNSu32 len) { return(malloc(len)); }$/;"	f
mDNSPlatformMemCopy	mDNSPosix.c	/^mDNSexport void    mDNSPlatformMemCopy(void *dst, const void *src, mDNSu32 len)$/;"	f
mDNSPlatformMemFree	mDNSPosix.c	/^mDNSexport void    mDNSPlatformMemFree    (void *mem)   { free(mem); }$/;"	f
mDNSPlatformMemSame	mDNSPosix.c	/^mDNSexport mDNSBool mDNSPlatformMemSame(const void *dst, const void *src, mDNSu32 len)$/;"	f
mDNSPlatformMemZero	mDNSPosix.c	/^mDNSexport void    mDNSPlatformMemZero(void *dst, mDNSu32 len)$/;"	f
mDNSPlatformOneSecond	mDNSPosix.c	/^mDNSexport mDNSs32  mDNSPlatformOneSecond = 1024;$/;"	v
mDNSPlatformPosixRefreshInterfaceList	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformPosixRefreshInterfaceList(mDNS *const m)$/;"	f
mDNSPlatformRandomSeed	mDNSPosix.c	/^mDNSexport mDNSu32 mDNSPlatformRandomSeed(void)$/;"	f
mDNSPlatformRawTime	mDNSPosix.c	/^mDNSexport mDNSs32  mDNSPlatformRawTime()$/;"	f
mDNSPlatformReadTCP	mDNSPosix.c	/^mDNSexport long mDNSPlatformReadTCP(TCPSocket *sock, void *buf, unsigned long buflen, mDNSBool * closed)$/;"	f
mDNSPlatformSendRawPacket	mDNSPosix.c	/^mDNSexport void mDNSPlatformSendRawPacket(const void *const msg, const mDNSu8 *const end, mDNSInterfaceID InterfaceID)$/;"	f
mDNSPlatformSendUDP	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformSendUDP(const mDNS *const m, const void *const msg, const mDNSu8 *const end,$/;"	f
mDNSPlatformSetDNSConfig	mDNSPosix.c	/^mDNSexport void mDNSPlatformSetDNSConfig(mDNS *const m, mDNSBool setservers, mDNSBool setsearch, domainname *const fqdn, DNameListElem **RegDomains, DNameListElem **BrowseDomains)$/;"	f
mDNSPlatformSetLocalARP	mDNSPosix.c	/^mDNSexport void mDNSPlatformSetLocalARP(const mDNSv4Addr *const tpa, const mDNSEthAddr *const tha, mDNSInterfaceID InterfaceID)$/;"	f
mDNSPlatformSourceAddrForDest	PlatformCommon.c	/^mDNSexport void mDNSPlatformSourceAddrForDest(mDNSAddr *const src, const mDNSAddr *const dst)$/;"	f
mDNSPlatformStatus	mDNSEmbeddedAPI.h	/^	mStatus mDNSPlatformStatus;$/;"	m	struct:mDNS_struct
mDNSPlatformStrCopy	mDNSPosix.c	/^mDNSexport void    mDNSPlatformStrCopy(void *dst, const void *src)$/;"	f
mDNSPlatformStrLen	mDNSPosix.c	/^mDNSexport mDNSu32  mDNSPlatformStrLen (const void *src)$/;"	f
mDNSPlatformTCPAccept	mDNSPosix.c	/^mDNSexport TCPSocket *mDNSPlatformTCPAccept(TCPSocketFlags flags, int sd)$/;"	f
mDNSPlatformTCPCloseConnection	mDNSPosix.c	/^mDNSexport void mDNSPlatformTCPCloseConnection(TCPSocket *sock)$/;"	f
mDNSPlatformTCPConnect	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformTCPConnect(TCPSocket *sock, const mDNSAddr *dst, mDNSOpaque16 dstport, mDNSInterfaceID InterfaceID,$/;"	f
mDNSPlatformTCPGetFD	mDNSPosix.c	/^mDNSexport int mDNSPlatformTCPGetFD(TCPSocket *sock)$/;"	f
mDNSPlatformTCPSocket	mDNSPosix.c	/^mDNSexport TCPSocket *mDNSPlatformTCPSocket(mDNS * const m, TCPSocketFlags flags, mDNSIPPort * port)$/;"	f
mDNSPlatformTLSSetupCerts	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformTLSSetupCerts(void)$/;"	f
mDNSPlatformTLSTearDownCerts	mDNSPosix.c	/^mDNSexport void mDNSPlatformTLSTearDownCerts(void)$/;"	f
mDNSPlatformTimeInit	mDNSPosix.c	/^mDNSexport mStatus mDNSPlatformTimeInit(void)$/;"	f
mDNSPlatformUDPClose	mDNSPosix.c	/^mDNSexport void           mDNSPlatformUDPClose(UDPSocket *sock)$/;"	f
mDNSPlatformUDPSocket	mDNSPosix.c	/^mDNSexport UDPSocket *mDNSPlatformUDPSocket(mDNS * const m, mDNSIPPort port)$/;"	f
mDNSPlatformUTC	mDNSPosix.c	/^mDNSexport mDNSs32 mDNSPlatformUTC(void)$/;"	f
mDNSPlatformUnlock	mDNSPosix.c	/^mDNSexport void    mDNSPlatformUnlock (const mDNS *const m)$/;"	f
mDNSPlatformUpdateProxyList	mDNSPosix.c	/^mDNSexport void mDNSPlatformUpdateProxyList(mDNS *const m, const mDNSInterfaceID InterfaceID)$/;"	f
mDNSPlatformWriteDebugMsg	PlatformCommon.c	/^mDNSexport void mDNSPlatformWriteDebugMsg(const char *msg)$/;"	f
mDNSPlatformWriteLogMsg	PlatformCommon.c	/^mDNSexport void mDNSPlatformWriteLogMsg(const char *ident, const char *buffer, mDNSLogLevel_t loglevel)$/;"	f
mDNSPlatformWriteTCP	mDNSPosix.c	/^mDNSexport long mDNSPlatformWriteTCP(TCPSocket *sock, const char *msg, unsigned long len)$/;"	f
mDNSPosixAddFDToEventLoop	mDNSPosix.c	/^mStatus mDNSPosixAddFDToEventLoop(int fd, mDNSPosixEventCallback callback, void *context)$/;"	f
mDNSPosixAddToFDSet	mDNSPosix.c	/^mDNSlocal void mDNSPosixAddToFDSet(int *nfds, fd_set *readfds, int s)$/;"	f
mDNSPosixEventCallback	mDNSPosix.h	/^typedef	void (*mDNSPosixEventCallback)(int fd, short filter, void *context);$/;"	t
mDNSPosixGetFDSet	mDNSPosix.c	/^mDNSexport void mDNSPosixGetFDSet(mDNS *m, int *nfds, fd_set *readfds, struct timeval *timeout)$/;"	f
mDNSPosixIgnoreSignalInEventLoop	mDNSPosix.c	/^mStatus mDNSPosixIgnoreSignalInEventLoop(int signum)$/;"	f
mDNSPosixListenForSignalInEventLoop	mDNSPosix.c	/^mStatus mDNSPosixListenForSignalInEventLoop(int signum)$/;"	f
mDNSPosixProcessFDSet	mDNSPosix.c	/^mDNSexport void mDNSPosixProcessFDSet(mDNS *const m, fd_set *readfds)$/;"	f
mDNSPosixRemoveFDFromEventLoop	mDNSPosix.c	/^mStatus mDNSPosixRemoveFDFromEventLoop(int fd)$/;"	f
mDNSPosixRunEventLoopOnce	mDNSPosix.c	/^mStatus mDNSPosixRunEventLoopOnce(mDNS *m, const struct timeval *pTimeout, $/;"	f
mDNSQuestionCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSQuestionCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, QC_result AddRecord);$/;"	t
mDNSRandom	DNSCommon.c	/^mDNSexport mDNSu32 mDNSRandom(mDNSu32 max)		\/\/ Returns pseudo-random result from zero to max inclusive$/;"	f
mDNSRandomFromSeed	DNSCommon.c	/^mDNSlocal mDNSu32 mDNSRandomFromSeed(mDNSu32 seed)$/;"	f
mDNSRandomNumber	DNSCommon.c	/^mDNSlocal mDNSu32 mDNSRandomNumber()$/;"	f
mDNSRandomNumber	DNSCommon.c	806;"	d	file:
mDNSRecordCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSRecordCallback(mDNS *const m, AuthRecord *const rr, mStatus result);$/;"	t
mDNSRecordUpdateCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSRecordUpdateCallback(mDNS *const m, AuthRecord *const rr, RData *OldRData);$/;"	t
mDNSResponderVersionString_SCCS	PosixDaemon.c	/^mDNSexport const char mDNSResponderVersionString_SCCS[] = "@(#) mDNSResponder (Engineering Build) (" __DATE__ " " __TIME__ ")";$/;"	v
mDNSResponderVersionString_SCCS	PosixDaemon.c	/^mDNSexport const char mDNSResponderVersionString_SCCS[] = "@(#) mDNSResponder (Engineering Build)";$/;"	v
mDNSResponderVersionString_SCCS	PosixDaemon.c	/^mDNSexport const char mDNSResponderVersionString_SCCS[] = "@(#) mDNSResponder-" STRINGIFY(mDNSResponderVersion) " (" __DATE__ " " __TIME__ ")";$/;"	v
mDNSSameAddress	DNSCommon.c	/^mDNSexport mDNSBool mDNSSameAddress(const mDNSAddr *ip1, const mDNSAddr *ip2)$/;"	f
mDNSSameEthAddress	mDNSEmbeddedAPI.h	3119;"	d
mDNSSameIPPort	mDNSEmbeddedAPI.h	3112;"	d
mDNSSameIPv4Address	mDNSEmbeddedAPI.h	3117;"	d
mDNSSameIPv6Address	mDNSEmbeddedAPI.h	3118;"	d
mDNSSameOpaque16	mDNSEmbeddedAPI.h	3113;"	d
mDNSSameOpaque32	mDNSEmbeddedAPI.h	3114;"	d
mDNSSameOpaque64	mDNSEmbeddedAPI.h	3115;"	d
mDNSSendDNSMessage	DNSCommon.c	/^mDNSexport mStatus mDNSSendDNSMessage(mDNS *const m, DNSMessage *const msg, mDNSu8 *end,$/;"	f
mDNSServiceCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSServiceCallback(mDNS *const m, ServiceRecordSet *const sr, mStatus result);$/;"	t
mDNSServiceInfoQueryCallback	mDNSEmbeddedAPI.h	/^typedef void mDNSServiceInfoQueryCallback(mDNS *const m, ServiceInfoQuery *query);$/;"	t
mDNSStorage	Client.c	/^static mDNS mDNSStorage;       \/\/ mDNS core uses this to store its globals$/;"	v	file:
mDNSStorage	Identify.c	/^static mDNS mDNSStorage;       \/\/ mDNS core uses this to store its globals$/;"	v	file:
mDNSStorage	NetMonitor.c	/^mDNS mDNSStorage;						\/\/ mDNS core uses this to store its globals$/;"	v
mDNSStorage	ProxyResponder.c	/^static mDNS mDNSStorage;       \/\/ mDNS core uses this to store its globals$/;"	v	file:
mDNSStorage	Responder.c	/^static mDNS mDNSStorage;       \/\/ mDNS core uses this to store its globals$/;"	v	file:
mDNSTransport_None	mDNSEmbeddedAPI.h	/^	mDNSTransport_None = 0,$/;"	e	enum:__anon23
mDNSTransport_TCP	mDNSEmbeddedAPI.h	/^	mDNSTransport_TCP  = 2$/;"	e	enum:__anon23
mDNSTransport_UDP	mDNSEmbeddedAPI.h	/^	mDNSTransport_UDP  = 1,$/;"	e	enum:__anon23
mDNSVal16	mDNSEmbeddedAPI.h	/^mDNSinline mDNSu16 mDNSVal16(mDNSOpaque16 x) { return((mDNSu16)((mDNSu16)x.b[0] <<  8 | (mDNSu16)x.b[1])); }$/;"	f
mDNSValidHostChar	DNSCommon.h	252;"	d
mDNS_ActivateNetWake_internal	mDNS.c	/^mDNSexport void mDNS_ActivateNetWake_internal(mDNS *const m, NetworkInterfaceInfo *set)$/;"	f
mDNS_AddDNSServer	uDNS.c	/^mDNSexport DNSServer *mDNS_AddDNSServer(mDNS *const m, const domainname *d, const mDNSInterfaceID interface, const mDNSAddr *addr, const mDNSIPPort port)$/;"	f
mDNS_AddDynDNSHostName	uDNS.c	/^mDNSexport void mDNS_AddDynDNSHostName(mDNS *m, const domainname *fqdn, mDNSRecordCallback *StatusCallback, const void *StatusContext)$/;"	f
mDNS_AddRecordToService	mDNS.c	/^mDNSexport mStatus mDNS_AddRecordToService(mDNS *const m, ServiceRecordSet *sr,$/;"	f
mDNS_AddSearchDomain	uDNS.c	/^mDNSexport void mDNS_AddSearchDomain(const domainname *const domain)$/;"	f
mDNS_AddSearchDomain_CString	mDNSEmbeddedAPI.h	3203;"	d
mDNS_AdvertiseDomains	mDNS.c	/^mDNSexport mStatus mDNS_AdvertiseDomains(mDNS *const m, AuthRecord *rr,$/;"	f
mDNS_Close	mDNSEmbeddedAPI.h	2889;"	d
mDNS_ConfigChanged	mDNS.c	/^mDNSexport void mDNS_ConfigChanged(mDNS *const m)$/;"	f
mDNS_DeactivateNetWake_internal	mDNS.c	/^mDNSexport void mDNS_DeactivateNetWake_internal(mDNS *const m, NetworkInterfaceInfo *set)$/;"	f
mDNS_DebugMode	mDNSDebug.c	/^mDNSexport int mDNS_DebugMode = mDNSfalse;$/;"	v
mDNS_DebugMode	mDNSDebug.c	/^mDNSexport int mDNS_DebugMode = mDNStrue;$/;"	v
mDNS_Dereg_conflict	uDNS.h	/^typedef enum { mDNS_Dereg_normal, mDNS_Dereg_conflict, mDNS_Dereg_repeat } mDNS_Dereg_type;$/;"	e	enum:__anon1
mDNS_Dereg_normal	uDNS.h	/^typedef enum { mDNS_Dereg_normal, mDNS_Dereg_conflict, mDNS_Dereg_repeat } mDNS_Dereg_type;$/;"	e	enum:__anon1
mDNS_Dereg_repeat	uDNS.h	/^typedef enum { mDNS_Dereg_normal, mDNS_Dereg_conflict, mDNS_Dereg_repeat } mDNS_Dereg_type;$/;"	e	enum:__anon1
mDNS_Dereg_type	uDNS.h	/^typedef enum { mDNS_Dereg_normal, mDNS_Dereg_conflict, mDNS_Dereg_repeat } mDNS_Dereg_type;$/;"	t	typeref:enum:__anon1
mDNS_Deregister	mDNS.c	/^mDNSexport mStatus mDNS_Deregister(mDNS *const m, AuthRecord *const rr)$/;"	f
mDNS_DeregisterInterface	mDNS.c	/^mDNSexport void mDNS_DeregisterInterface(mDNS *const m, NetworkInterfaceInfo *set, mDNSBool flapping)$/;"	f
mDNS_DeregisterNoSuchService	mDNSEmbeddedAPI.h	2966;"	d
mDNS_DeregisterService	mDNS.c	/^mDNSexport mStatus mDNS_DeregisterService(mDNS *const m, ServiceRecordSet *sr)$/;"	f
mDNS_Deregister_internal	mDNS.c	/^mDNSexport mStatus mDNS_Deregister_internal(mDNS *const m, AuthRecord *const rr, mDNS_Dereg_type drt)$/;"	f
mDNS_DomainType	mDNSEmbeddedAPI.h	/^	} mDNS_DomainType;$/;"	t	typeref:enum:__anon58
mDNS_DomainTypeBrowse	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeBrowse              = 0,$/;"	e	enum:__anon58
mDNS_DomainTypeBrowseAutomatic	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeBrowseAutomatic     = 2,$/;"	e	enum:__anon58
mDNS_DomainTypeBrowseDefault	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeBrowseDefault       = 1,$/;"	e	enum:__anon58
mDNS_DomainTypeMax	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeMax = 4$/;"	e	enum:__anon58
mDNS_DomainTypeNames	mDNS.c	/^mDNSexport const char *const mDNS_DomainTypeNames[] =$/;"	v
mDNS_DomainTypeRegistration	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeRegistration        = 3,$/;"	e	enum:__anon58
mDNS_DomainTypeRegistrationDefault	mDNSEmbeddedAPI.h	/^	mDNS_DomainTypeRegistrationDefault = 4,$/;"	e	enum:__anon58
mDNS_DropLockBeforeCallback	DNSCommon.h	422;"	d
mDNS_Execute	mDNS.c	/^mDNSexport mDNSs32 mDNS_Execute(mDNS *const m)$/;"	f
mDNS_ExitNow	mDNSEmbeddedAPI.h	2890;"	d
mDNS_FinalExit	mDNS.c	/^mDNSexport void mDNS_FinalExit(mDNS *const m)$/;"	f
mDNS_GetDomains	mDNS.c	/^mDNSexport mStatus mDNS_GetDomains(mDNS *const m, DNSQuestion *const question, mDNS_DomainType DomainType, const domainname *dom,$/;"	f
mDNS_GrowCache	mDNS.c	/^mDNSexport void mDNS_GrowCache(mDNS *const m, CacheEntity *storage, mDNSu32 numrecords)$/;"	f
mDNS_GrowCache_internal	mDNS.c	/^mDNSlocal void mDNS_GrowCache_internal(mDNS *const m, CacheEntity *storage, mDNSu32 numrecords)$/;"	f
mDNS_HostNameCallback	mDNS.c	/^mDNSlocal void mDNS_HostNameCallback(mDNS *const m, AuthRecord *const rr, mStatus result)$/;"	f
mDNS_Init	mDNS.c	/^mDNSexport mStatus mDNS_Init(mDNS *const m, mDNS_PlatformSupport *const p,$/;"	f
mDNS_Init_AdvertiseLocalAddresses	mDNSEmbeddedAPI.h	2880;"	d
mDNS_Init_DontAdvertiseLocalAddresses	mDNSEmbeddedAPI.h	2881;"	d
mDNS_Init_NoCache	mDNSEmbeddedAPI.h	2877;"	d
mDNS_Init_NoInitCallback	mDNSEmbeddedAPI.h	2882;"	d
mDNS_Init_NoInitCallbackContext	mDNSEmbeddedAPI.h	2883;"	d
mDNS_Init_ZeroCacheSize	mDNSEmbeddedAPI.h	2878;"	d
mDNS_InstantiateInlines	DNSCommon.c	564;"	d	file:
mDNS_KnownBug_LossySyslog	mDNSEmbeddedAPI.h	/^	mDNS_KnownBug_LossySyslog       = 2		\/\/ <rdar:\/\/problem\/6561888>$/;"	e	enum:__anon55
mDNS_KnownBug_PhantomInterfaces	mDNSEmbeddedAPI.h	/^	mDNS_KnownBug_PhantomInterfaces = 1,$/;"	e	enum:__anon55
mDNS_Lock	DNSCommon.h	414;"	d
mDNS_Lock_	DNSCommon.c	/^mDNSexport void mDNS_Lock_(mDNS *const m)$/;"	f
mDNS_LoggingEnabled	mDNSDebug.c	/^mDNSexport int mDNS_LoggingEnabled = 0;$/;"	v
mDNS_NewMessageID	mDNS.c	/^mDNSexport mDNSOpaque16 mDNS_NewMessageID(mDNS * const m)$/;"	f
mDNS_PacketLoggingEnabled	mDNSDebug.c	/^mDNSexport int mDNS_PacketLoggingEnabled = 0;$/;"	v
mDNS_PlatformSupport	mDNSEmbeddedAPI.h	/^typedef struct mDNS_PlatformSupport_struct mDNS_PlatformSupport;$/;"	t	typeref:struct:mDNS_PlatformSupport_struct
mDNS_PlatformSupport_struct	mDNSPosix.h	/^struct mDNS_PlatformSupport_struct$/;"	s
mDNS_PurgeCacheResourceRecord	mDNS.c	/^mDNSexport void mDNS_PurgeCacheResourceRecord(mDNS *const m, CacheRecord *rr)$/;"	f
mDNS_ReclaimLockAfterCallback	DNSCommon.h	426;"	d
mDNS_Reconfirm	mDNS.c	/^mDNSexport mStatus mDNS_Reconfirm(mDNS *const m, CacheRecord *const cr)$/;"	f
mDNS_ReconfirmByValue	mDNS.c	/^mDNSexport mStatus mDNS_ReconfirmByValue(mDNS *const m, ResourceRecord *const rr)$/;"	f
mDNS_Reconfirm_internal	mDNS.c	/^mDNSlocal mStatus mDNS_Reconfirm_internal(mDNS *const m, CacheRecord *const rr, mDNSu32 interval)$/;"	f
mDNS_Register	mDNS.c	/^mDNSexport mStatus mDNS_Register(mDNS *const m, AuthRecord *const rr)$/;"	f
mDNS_RegisterInterface	mDNS.c	/^mDNSexport mStatus mDNS_RegisterInterface(mDNS *const m, NetworkInterfaceInfo *set, mDNSBool flapping)$/;"	f
mDNS_RegisterNoSuchService	mDNS.c	/^mDNSexport mStatus mDNS_RegisterNoSuchService(mDNS *const m, AuthRecord *const rr,$/;"	f
mDNS_RegisterProxyHost	ProxyResponder.c	/^mDNSlocal mStatus mDNS_RegisterProxyHost(mDNS *m, ProxyHost *p)$/;"	f
mDNS_RegisterService	mDNS.c	/^mDNSexport mStatus mDNS_RegisterService(mDNS *const m, ServiceRecordSet *sr,$/;"	f
mDNS_Register_internal	mDNS.c	/^mDNSexport mStatus mDNS_Register_internal(mDNS *const m, AuthRecord *const rr)$/;"	f
mDNS_RemoveDynDNSHostName	uDNS.c	/^mDNSexport void mDNS_RemoveDynDNSHostName(mDNS *m, const domainname *fqdn)$/;"	f
mDNS_RemoveRecordFromService	mDNS.c	/^mDNSexport mStatus mDNS_RemoveRecordFromService(mDNS *const m, ServiceRecordSet *sr, ExtraResourceRecord *extra,$/;"	f
mDNS_RenameAndReregisterService	mDNS.c	/^mDNSexport mStatus mDNS_RenameAndReregisterService(mDNS *const m, ServiceRecordSet *const sr, const domainlabel *newname)$/;"	f
mDNS_SetFQDN	mDNS.c	/^mDNSexport void mDNS_SetFQDN(mDNS *const m)$/;"	f
mDNS_SetPrimaryInterfaceInfo	uDNS.c	/^mDNSexport void mDNS_SetPrimaryInterfaceInfo(mDNS *m, const mDNSAddr *v4addr, const mDNSAddr *v6addr, const mDNSAddr *router)$/;"	f
mDNS_SetSecretForDomain	uDNS.c	/^mDNSexport mStatus mDNS_SetSecretForDomain(mDNS *m, DomainAuthInfo *info,$/;"	f
mDNS_SetupQuestion	DNSCommon.c	/^mDNSexport void mDNS_SetupQuestion(DNSQuestion *const q, const mDNSInterfaceID InterfaceID, const domainname *const name,$/;"	f
mDNS_SetupResourceRecord	DNSCommon.c	/^mDNSexport void mDNS_SetupResourceRecord(AuthRecord *rr, RData *RDataStorage, mDNSInterfaceID InterfaceID,$/;"	f
mDNS_StartBrowse	mDNS.c	/^mDNSexport mStatus mDNS_StartBrowse(mDNS *const m, DNSQuestion *const question,$/;"	f
mDNS_StartBrowse_internal	mDNS.c	/^mDNSlocal mStatus mDNS_StartBrowse_internal(mDNS *const m, DNSQuestion *const question,$/;"	f
mDNS_StartExit	mDNS.c	/^mDNSexport void mDNS_StartExit(mDNS *const m)$/;"	f
mDNS_StartNATOperation	uDNS.c	/^mDNSexport mStatus mDNS_StartNATOperation(mDNS *m, NATTraversalInfo *traversal)$/;"	f
mDNS_StartNATOperation_internal	uDNS.c	/^mDNSexport mStatus mDNS_StartNATOperation_internal(mDNS *const m, NATTraversalInfo *traversal)$/;"	f
mDNS_StartQuery	mDNS.c	/^mDNSexport mStatus mDNS_StartQuery(mDNS *const m, DNSQuestion *const question)$/;"	f
mDNS_StartQuery_internal	mDNS.c	/^mDNSexport mStatus mDNS_StartQuery_internal(mDNS *const m, DNSQuestion *const question)$/;"	f
mDNS_StartResolveService	mDNS.c	/^mDNSexport mStatus mDNS_StartResolveService(mDNS *const m,$/;"	f
mDNS_StatusCallback	PosixDaemon.c	/^mDNSlocal void mDNS_StatusCallback(mDNS *const m, mStatus result)$/;"	f
mDNS_StopAdvertiseDomains	mDNSEmbeddedAPI.h	2996;"	d
mDNS_StopBrowse	mDNSEmbeddedAPI.h	2974;"	d
mDNS_StopGetDomains	mDNSEmbeddedAPI.h	2994;"	d
mDNS_StopNATOperation	uDNS.c	/^mDNSexport mStatus mDNS_StopNATOperation(mDNS *m, NATTraversalInfo *traversal)$/;"	f
mDNS_StopNATOperation_internal	uDNS.c	/^mDNSexport mStatus mDNS_StopNATOperation_internal(mDNS *m, NATTraversalInfo *traversal)$/;"	f
mDNS_StopQuery	mDNS.c	/^mDNSexport mStatus mDNS_StopQuery(mDNS *const m, DNSQuestion *const question)$/;"	f
mDNS_StopQueryWithRemoves	mDNS.c	/^mDNSexport mStatus mDNS_StopQueryWithRemoves(mDNS *const m, DNSQuestion *const question)$/;"	f
mDNS_StopQuery_internal	mDNS.c	/^mDNSexport mStatus mDNS_StopQuery_internal(mDNS *const m, DNSQuestion *const question)$/;"	f
mDNS_StopResolveService	mDNS.c	/^mDNSexport void    mDNS_StopResolveService (mDNS *const m, ServiceInfoQuery *q)$/;"	f
mDNS_TimeNow	mDNS.c	/^mDNSexport mDNSs32 mDNS_TimeNow(const mDNS *const m)$/;"	f
mDNS_TimeNow_NoLock	mDNSEmbeddedAPI.h	3303;"	d
mDNS_Unlock	DNSCommon.h	418;"	d
mDNS_Unlock_	DNSCommon.c	/^mDNSexport void mDNS_Unlock_(mDNS *const m)$/;"	f
mDNS_Update	mDNS.c	/^mDNSexport mStatus mDNS_Update(mDNS *const m, AuthRecord *const rr, mDNSu32 newttl,$/;"	f
mDNS_VACB_Lim	DNSCommon.c	3188;"	d	file:
mDNS_VACB_Remain	DNSCommon.c	3189;"	d	file:
mDNS_VACB_Size	DNSCommon.c	3186;"	d	file:
mDNS_busy	mDNSEmbeddedAPI.h	/^	mDNSu32 mDNS_busy;					\/\/ Incremented between mDNS_Lock\/mDNS_Unlock section$/;"	m	struct:mDNS_struct
mDNS_numPrereqs	mDNSEmbeddedAPI.h	1369;"	d
mDNS_numUpdates	mDNSEmbeddedAPI.h	1370;"	d
mDNS_numZones	mDNSEmbeddedAPI.h	1368;"	d
mDNS_reentrancy	mDNSEmbeddedAPI.h	/^	mDNSu32 mDNS_reentrancy;			\/\/ Incremented when calling a client callback$/;"	m	struct:mDNS_struct
mDNS_snprintf	DNSCommon.c	/^mDNSexport mDNSu32 mDNS_snprintf(char *sbuffer, mDNSu32 buflen, const char *fmt, ...)$/;"	f
mDNS_struct	mDNSEmbeddedAPI.h	/^struct mDNS_struct$/;"	s
mDNS_vsnprintf	DNSCommon.c	/^mDNSexport mDNSu32 mDNS_vsnprintf(char *sbuffer, mDNSu32 buflen, const char *fmt, va_list arg)$/;"	f
mDNSexport	mDNSEmbeddedAPI.h	1034;"	d
mDNSfalse	mDNSEmbeddedAPI.h	/^enum { mDNSfalse = 0, mDNStrue = 1 };$/;"	e	enum:__anon26
mDNSinline	mDNSEmbeddedAPI.h	2782;"	d
mDNSinline	mDNSEmbeddedAPI.h	2784;"	d
mDNSinline	mDNSEmbeddedAPI.h	2797;"	d
mDNSisspace	DNSDigest.c	1228;"	d	file:
mDNSlocal	mDNSEmbeddedAPI.h	1027;"	d
mDNSprintf_format	DNSCommon.c	/^static const struct mDNSprintf_format$/;"	s	file:
mDNSprintf_format_default	DNSCommon.c	/^	} mDNSprintf_format_default = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };$/;"	v	typeref:struct:mDNSprintf_format	file:
mDNSs16	mDNSEmbeddedAPI.h	/^typedef   signed short mDNSs16;$/;"	t
mDNSs32	mDNSEmbeddedAPI.h	/^typedef   signed int   mDNSs32;$/;"	t
mDNSs32	mDNSEmbeddedAPI.h	/^typedef   signed int32 mDNSs32;$/;"	t
mDNSs32	mDNSEmbeddedAPI.h	/^typedef   signed long  mDNSs32;$/;"	t
mDNSs8	mDNSEmbeddedAPI.h	/^typedef   signed char  mDNSs8;$/;"	t
mDNSstrchr	DNSDigest.c	/^mDNSlocal const char *mDNSstrchr(const char *s, int c)$/;"	f
mDNStrue	mDNSEmbeddedAPI.h	/^enum { mDNSfalse = 0, mDNStrue = 1 };$/;"	e	enum:__anon26
mDNSu16	mDNSEmbeddedAPI.h	/^typedef unsigned short mDNSu16;$/;"	t
mDNSu32	mDNSEmbeddedAPI.h	/^typedef unsigned int   mDNSu32;$/;"	t
mDNSu32	mDNSEmbeddedAPI.h	/^typedef unsigned int32 mDNSu32;$/;"	t
mDNSu32	mDNSEmbeddedAPI.h	/^typedef unsigned long  mDNSu32;$/;"	t
mDNSu8	mDNSEmbeddedAPI.h	/^typedef unsigned char  mDNSu8;$/;"	t
mDNSv4Addr	mDNSEmbeddedAPI.h	/^typedef mDNSOpaque32  mDNSv4Addr;		\/\/ An IP address is a four-byte opaque identifier (not an integer)$/;"	t
mDNSv4AddrIsRFC1918	DNSCommon.c	/^mDNSexport mDNSBool mDNSv4AddrIsRFC1918(mDNSv4Addr *addr)$/;"	f
mDNSv4AddressIsLinkLocal	mDNSEmbeddedAPI.h	3151;"	d
mDNSv6Addr	mDNSEmbeddedAPI.h	/^typedef mDNSOpaque128 mDNSv6Addr;		\/\/ An IPv6 address is a 16-byte opaque identifier (not an integer)$/;"	t
mDNSv6AddressIsLinkLocal	mDNSEmbeddedAPI.h	3152;"	d
mStatus	mDNSEmbeddedAPI.h	/^typedef mDNSs32 mStatus;$/;"	t
mStatus_AlreadyRegistered	mDNSEmbeddedAPI.h	/^	mStatus_AlreadyRegistered         = -65547,$/;"	e	enum:__anon27
mStatus_BadFlagsErr	mDNSEmbeddedAPI.h	/^	mStatus_BadFlagsErr               = -65543,$/;"	e	enum:__anon27
mStatus_BadInterfaceErr	mDNSEmbeddedAPI.h	/^	mStatus_BadInterfaceErr           = -65552,$/;"	e	enum:__anon27
mStatus_BadKey	mDNSEmbeddedAPI.h	/^	mStatus_BadKey                    = -65561,$/;"	e	enum:__anon27
mStatus_BadParamErr	mDNSEmbeddedAPI.h	/^	mStatus_BadParamErr               = -65540,$/;"	e	enum:__anon27
mStatus_BadReferenceErr	mDNSEmbeddedAPI.h	/^	mStatus_BadReferenceErr           = -65541,$/;"	e	enum:__anon27
mStatus_BadSig	mDNSEmbeddedAPI.h	/^	mStatus_BadSig                    = -65560,     \/\/ while we define this per RFC 2845, BIND 9 returns Refused for bad\/missing signatures$/;"	e	enum:__anon27
mStatus_BadStateErr	mDNSEmbeddedAPI.h	/^	mStatus_BadStateErr               = -65542,$/;"	e	enum:__anon27
mStatus_BadTime	mDNSEmbeddedAPI.h	/^	mStatus_BadTime                   = -65559,$/;"	e	enum:__anon27
mStatus_ConfigChanged	mDNSEmbeddedAPI.h	/^	mStatus_ConfigChanged     = -65791,$/;"	e	enum:__anon27
mStatus_ConnEstablished	mDNSEmbeddedAPI.h	/^	mStatus_ConnEstablished   = -65789,$/;"	e	enum:__anon27
mStatus_ConnFailed	mDNSEmbeddedAPI.h	/^	mStatus_ConnFailed        = -65788,$/;"	e	enum:__anon27
mStatus_ConnPending	mDNSEmbeddedAPI.h	/^	mStatus_ConnPending       = -65787,$/;"	e	enum:__anon27
mStatus_DoubleNAT	mDNSEmbeddedAPI.h	/^	mStatus_DoubleNAT                 = -65558,$/;"	e	enum:__anon27
mStatus_Firewall	mDNSEmbeddedAPI.h	/^	mStatus_Firewall                  = -65550,$/;"	e	enum:__anon27
mStatus_GrowCache	mDNSEmbeddedAPI.h	/^	mStatus_GrowCache         = -65790,$/;"	e	enum:__anon27
mStatus_Incompatible	mDNSEmbeddedAPI.h	/^	mStatus_Incompatible              = -65551,$/;"	e	enum:__anon27
mStatus_Invalid	mDNSEmbeddedAPI.h	/^	mStatus_Invalid                   = -65549,$/;"	e	enum:__anon27
mStatus_MemFree	mDNSEmbeddedAPI.h	/^	mStatus_MemFree           = -65792		\/\/ Last value: 0xFFFE FF00$/;"	e	enum:__anon27
mStatus_NATPortMappingDisabled	mDNSEmbeddedAPI.h	/^	mStatus_NATPortMappingDisabled    = -65565,     \/\/ NAT supports NAT-PMP or UPnP but it's disabled by the administrator$/;"	e	enum:__anon27
mStatus_NATPortMappingUnsupported	mDNSEmbeddedAPI.h	/^	mStatus_NATPortMappingUnsupported = -65564,     \/\/ NAT doesn't support NAT-PMP or UPnP$/;"	e	enum:__anon27
mStatus_NATTraversal	mDNSEmbeddedAPI.h	/^	mStatus_NATTraversal              = -65557,$/;"	e	enum:__anon27
mStatus_NameConflict	mDNSEmbeddedAPI.h	/^	mStatus_NameConflict              = -65548,$/;"	e	enum:__anon27
mStatus_NoAuth	mDNSEmbeddedAPI.h	/^	mStatus_NoAuth                    = -65555,$/;"	e	enum:__anon27
mStatus_NoCache	mDNSEmbeddedAPI.h	/^	mStatus_NoCache                   = -65546,$/;"	e	enum:__anon27
mStatus_NoError	mDNSEmbeddedAPI.h	/^	mStatus_NoError           = 0,$/;"	e	enum:__anon27
mStatus_NoMemoryErr	mDNSEmbeddedAPI.h	/^	mStatus_NoMemoryErr               = -65539,$/;"	e	enum:__anon27
mStatus_NoRouter	mDNSEmbeddedAPI.h	/^	mStatus_NoRouter                  = -65566,$/;"	e	enum:__anon27
mStatus_NoSuchKey	mDNSEmbeddedAPI.h	/^	mStatus_NoSuchKey                 = -65556,$/;"	e	enum:__anon27
mStatus_NoSuchNameErr	mDNSEmbeddedAPI.h	/^	mStatus_NoSuchNameErr             = -65538,$/;"	e	enum:__anon27
mStatus_NoSuchRecord	mDNSEmbeddedAPI.h	/^	mStatus_NoSuchRecord              = -65554,$/;"	e	enum:__anon27
mStatus_NotInitializedErr	mDNSEmbeddedAPI.h	/^	mStatus_NotInitializedErr         = -65545,$/;"	e	enum:__anon27
mStatus_PollingMode	mDNSEmbeddedAPI.h	/^	mStatus_PollingMode               = -65567,$/;"	e	enum:__anon27
mStatus_Refused	mDNSEmbeddedAPI.h	/^	mStatus_Refused                   = -65553,$/;"	e	enum:__anon27
mStatus_ServiceNotRunning	mDNSEmbeddedAPI.h	/^	mStatus_ServiceNotRunning         = -65563,     \/\/ Background daemon not running$/;"	e	enum:__anon27
mStatus_TransientErr	mDNSEmbeddedAPI.h	/^	mStatus_TransientErr              = -65562,     \/\/ transient failures, e.g. sending packets shortly after a network transition or wake from sleep$/;"	e	enum:__anon27
mStatus_UnknownErr	mDNSEmbeddedAPI.h	/^	mStatus_UnknownErr                = -65537,		\/\/ First value: 0xFFFE FFFF$/;"	e	enum:__anon27
mStatus_UnsupportedErr	mDNSEmbeddedAPI.h	/^	mStatus_UnsupportedErr            = -65544,$/;"	e	enum:__anon27
mStatus_Waiting	mDNSEmbeddedAPI.h	/^	mStatus_Waiting           = 1,$/;"	e	enum:__anon27
main	Client.c	/^int main(int argc, char **argv)$/;"	f
main	Identify.c	/^mDNSexport int main(int argc, char **argv)$/;"	f
main	NetMonitor.c	/^mDNSexport int main(int argc, char **argv)$/;"	f
main	PosixDaemon.c	/^int main(int argc, char **argv)$/;"	f
main	ProxyResponder.c	/^mDNSexport int main(int argc, char **argv)$/;"	f
main	Responder.c	/^int main(int argc, char **argv)$/;"	f
mallocL	mDNSDebug.h	299;"	d
mask	mDNSEmbeddedAPI.h	/^	mDNSAddr        mask;$/;"	m	struct:NetworkInterfaceInfo_struct
math	parselog.py	/^import math   # for pi$/;"	i
max	NetMonitor.c	/^	long		max;$/;"	m	struct:__anon7	file:
md5_block_data_order	DNSDigest.c	/^void md5_block_data_order (MD5_CTX *c, const void *data_, int num)$/;"	f
md5_block_data_order	DNSDigest.c	341;"	d	file:
md5_block_host_order	DNSDigest.c	/^void md5_block_host_order (MD5_CTX *c, const void *data, int num)$/;"	f
md5_block_host_order	DNSDigest.c	309;"	d	file:
mdns_gethostbyname2	nss_mdns.c	/^mdns_gethostbyname2 ($/;"	f
mdns_lookup_addr	nss_mdns.c	/^mdns_lookup_addr ($/;"	f	file:
mdns_lookup_callback	nss_mdns.c	/^mdns_lookup_callback$/;"	f
mdns_lookup_callback	nss_mdns.c	/^mdns_lookup_callback_t mdns_lookup_callback;$/;"	v
mdns_lookup_callback_t	nss_mdns.c	/^mdns_lookup_callback_t$/;"	t	file:
mdns_lookup_name	nss_mdns.c	/^mdns_lookup_name ($/;"	f	file:
members	mDNSEmbeddedAPI.h	/^	CacheRecord    *members;			\/\/ List of CacheRecords with this same name$/;"	m	struct:CacheGroup_struct
mprintf	Identify.c	/^mDNSlocal mDNSu32 mprintf(const char *format, ...)$/;"	f
mprintf	NetMonitor.c	/^mDNSlocal mDNSu32 mprintf(const char *format, ...)$/;"	f
multicastSocket4	mDNSPosix.h	/^	int                     multicastSocket4;$/;"	m	struct:PosixNetworkInterface
multicastSocket6	mDNSPosix.h	/^	int                     multicastSocket6;$/;"	m	struct:PosixNetworkInterface
mx	mDNSEmbeddedAPI.h	/^	rdataMX     mx;$/;"	m	union:__anon35
mx	mDNSEmbeddedAPI.h	/^	rdataMX     mx;$/;"	m	union:__anon36
my_in_pktinfo	mDNSUNP.h	/^struct my_in_pktinfo {$/;"	s
name	mDNSEmbeddedAPI.h	/^	const domainname *name;$/;"	m	struct:__anon42
name	mDNSEmbeddedAPI.h	/^	domainname      name;$/;"	m	struct:__anon53
name	mDNSEmbeddedAPI.h	/^	domainname     *name;				\/\/ Common name for all CacheRecords in this list$/;"	m	struct:CacheGroup_struct
name	mDNSEmbeddedAPI.h	/^	domainname  name;		\/\/ For PTR, NS, CNAME, DNAME$/;"	m	union:__anon35
name	mDNSEmbeddedAPI.h	/^	domainname  name;		\/\/ For PTR, NS, CNAME, DNAME$/;"	m	union:__anon36
name	mDNSEmbeddedAPI.h	/^	domainname name;$/;"	m	struct:DNameListElem
name	nss_mdns.c	/^	const char * name;$/;"	m	struct:__anon14	file:
namehash	mDNSEmbeddedAPI.h	/^	mDNSu32          namehash;			\/\/ Name-based (i.e. case-insensitive) hash of name$/;"	m	struct:__anon42
namehash	mDNSEmbeddedAPI.h	/^	mDNSu32         namehash;			\/\/ Name-based (i.e. case insensitive) hash of name$/;"	m	struct:CacheGroup_struct
namestorage	mDNSEmbeddedAPI.h	/^	domainname      namestorage;$/;"	m	struct:AuthRecord_struct
namestorage	mDNSEmbeddedAPI.h	/^	domainname namestorage;									\/\/ Needs to go *after* the extra rdata bytes$/;"	m	struct:__anon45
namestorage	mDNSEmbeddedAPI.h	/^	mDNSu8          namestorage[InlineCacheGroupNameSize];$/;"	m	struct:CacheGroup_struct
natTraversalHandleAddressReply	uDNS.c	/^mDNSexport void natTraversalHandleAddressReply(mDNS *const m, mDNSu16 err, mDNSv4Addr ExtAddr)$/;"	f
natTraversalHandlePortMapReply	uDNS.c	/^mDNSexport void natTraversalHandlePortMapReply(mDNS *const m, NATTraversalInfo *n, const mDNSInterfaceID InterfaceID, mDNSu16 err, mDNSIPPort extport, mDNSu32 lease)$/;"	f
natinfo	mDNSEmbeddedAPI.h	/^	NATTraversalInfo natinfo;$/;"	m	struct:HostnameInfo
newrdlength	mDNSEmbeddedAPI.h	/^	mDNSu16         newrdlength;		\/\/ ... and the length of the new RData$/;"	m	struct:AuthRecord_struct
next	NetMonitor.c	/^	ActivityStat *next;$/;"	m	struct:ActivityStat_struct	file:
next	NetMonitor.c	/^	FilterList *next;$/;"	m	struct:FilterList_struct	file:
next	Responder.c	/^    PosixService *next;$/;"	m	struct:PosixService	file:
next	mDNSEmbeddedAPI.h	/^	AuthRecord     *next;				\/\/ Next in list; first element of structure for efficiency reasons$/;"	m	struct:AuthRecord_struct
next	mDNSEmbeddedAPI.h	/^	CacheGroup     *next;				\/\/ Next CacheGroup object in this hash table bucket$/;"	m	struct:CacheGroup_struct
next	mDNSEmbeddedAPI.h	/^	CacheRecord    *next;				\/\/ Next in list; first element of structure for efficiency reasons$/;"	m	struct:CacheRecord_struct
next	mDNSEmbeddedAPI.h	/^	DNSQuestion          *next;$/;"	m	struct:DNSQuestion_struct
next	mDNSEmbeddedAPI.h	/^	ExtraResourceRecord *next;$/;"	m	struct:ExtraResourceRecord_struct
next	mDNSEmbeddedAPI.h	/^	NATTraversalInfo           *next;$/;"	m	struct:NATTraversalInfo_struct
next	mDNSEmbeddedAPI.h	/^	NetworkInterfaceInfo *next;$/;"	m	struct:NetworkInterfaceInfo_struct
next	mDNSEmbeddedAPI.h	/^	struct ARListElem *next;$/;"	m	struct:ARListElem	typeref:struct:ARListElem::ARListElem
next	mDNSEmbeddedAPI.h	/^	struct ClientTunnel *next;$/;"	m	struct:ClientTunnel	typeref:struct:ClientTunnel::ClientTunnel
next	mDNSEmbeddedAPI.h	/^	struct DNSServer *next;$/;"	m	struct:DNSServer	typeref:struct:DNSServer::DNSServer
next	mDNSEmbeddedAPI.h	/^	struct DNameListElem *next;$/;"	m	struct:DNameListElem	typeref:struct:DNameListElem::DNameListElem
next	mDNSEmbeddedAPI.h	/^	struct DomainAuthInfo *next;$/;"	m	struct:DomainAuthInfo	typeref:struct:DomainAuthInfo::DomainAuthInfo
next	mDNSEmbeddedAPI.h	/^	struct HostnameInfo *next;$/;"	m	struct:HostnameInfo	typeref:struct:HostnameInfo::HostnameInfo
next	mDNSEmbeddedAPI.h	/^	struct SearchListElem *next;$/;"	m	struct:SearchListElem	typeref:struct:SearchListElem::SearchListElem
next	mDNSEmbeddedAPI.h	/^	tcpLNTInfo       *next;$/;"	m	struct:tcpLNTInfo_struct
next	mDNSEmbeddedAPI.h	/^union CacheEntity_union { CacheEntity *next; CacheGroup cg; CacheRecord cr; };$/;"	m	union:CacheEntity_union
next	nss_mdns.c	/^	struct domain_entry * next;$/;"	m	struct:domain_entry	typeref:struct:domain_entry::domain_entry	file:
nicelabel	mDNSEmbeddedAPI.h	/^	domainlabel nicelabel;				\/\/ Rich text label encoded using canonically precomposed UTF-8$/;"	m	struct:mDNS_struct
nread	mDNSEmbeddedAPI.h	/^	unsigned long     nread;			\/\/ number of bytes read so far$/;"	m	struct:tcpLNTInfo_struct
nread	mDNSEmbeddedAPI.h	/^	unsigned long     nread;$/;"	m	struct:tcpInfo_t
ns_class_t	nss_mdns.c	/^typedef int ns_class_t;$/;"	t	file:
ns_class_to_str	nss_mdns.c	/^ns_class_to_str (ns_class_t in)$/;"	f
ns_type_t	nss_mdns.c	/^typedef int ns_type_t;$/;"	t	file:
ns_type_to_str	nss_mdns.c	/^ns_type_to_str (ns_type_t in)$/;"	f
nsec	mDNSEmbeddedAPI.h	/^	rdataNSEC   nsec;$/;"	m	union:__anon35
nsec	mDNSEmbeddedAPI.h	/^	rdataNSEC   nsec;$/;"	m	union:__anon36
nss_status	nss_mdns.c	/^typedef enum nss_status nss_status;$/;"	t	typeref:enum:nss_status	file:
nta	mDNSEmbeddedAPI.h	/^	ZoneData             *nta;				\/\/ Used for getting zone data for private or LLQ query$/;"	m	struct:DNSQuestion_struct
nta	mDNSEmbeddedAPI.h	/^	ZoneData  *nta;$/;"	m	struct:AuthRecord_struct
ntries	mDNSEmbeddedAPI.h	/^	mDNSs16               ntries;           \/\/ for UDP: the number of packets sent for this LLQ state$/;"	m	struct:DNSQuestion_struct
num	DNSDigest.c	/^	int num;$/;"	m	struct:MD5state_st	file:
num	NetMonitor.c	/^	long		num;$/;"	m	struct:__anon7	file:
numReplies	mDNSEmbeddedAPI.h	/^	int               numReplies;$/;"	m	struct:tcpInfo_t
num_pkts_accepted	mDNSPosix.c	/^static int num_pkts_accepted = 0;$/;"	v	file:
num_pkts_rejected	mDNSPosix.c	/^static int num_pkts_rejected = 0;$/;"	v	file:
num_registered_interfaces	mDNSPosix.c	/^static int num_registered_interfaces = 0;$/;"	v	file:
omsg	mDNSEmbeddedAPI.h	/^	DNSMessage        omsg;                 \/\/ Outgoing message we're building$/;"	m	struct:mDNS_struct
onesEthAddr	DNSCommon.c	/^mDNSexport const mDNSEthAddr     onesEthAddr       = { { 255, 255, 255, 255, 255, 255 } };$/;"	v
onesID	DNSCommon.c	/^mDNSexport const mDNSOpaque16 onesID          = { { 255, 255 } };$/;"	v
onesIPv4Addr	DNSCommon.c	/^mDNSexport const mDNSv4Addr      onesIPv4Addr      = { { 255, 255, 255, 255 } };$/;"	v
onesIPv6Addr	DNSCommon.c	/^mDNSexport const mDNSv6Addr      onesIPv6Addr      = { { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 } };$/;"	v
op	mDNSEmbeddedAPI.h	/^	LNTOp_t           op;				\/\/ operation performed using this connection$/;"	m	struct:tcpLNTInfo_struct
opt	mDNSEmbeddedAPI.h	/^	rdataOPT    opt[2];		\/\/ For EDNS0 OPT record; RDataBody may contain multiple variable-length rdataOPT objects packed together$/;"	m	union:__anon35
opt	mDNSEmbeddedAPI.h	/^	rdataOPT    opt[2];		\/\/ For EDNS0 OPT record; RDataBody may contain multiple variable-length rdataOPT objects packed together$/;"	m	union:__anon36
os	parselog.py	/^import sys, os$/;"	i
p	mDNSEmbeddedAPI.h	/^	mDNS_PlatformSupport *p;			\/\/ Pointer to platform-specific data of indeterminite size$/;"	m	struct:mDNS_struct
p	mDNSEmbeddedAPI.h	/^	union { DNSMessage m; void *p; } imsg;  \/\/ Incoming message received from wire$/;"	m	union:mDNS_struct::__anon57
packedstruct	mDNSEmbeddedAPI.h	1059;"	d
packedstruct	mDNSEmbeddedAPI.h	1062;"	d
packedunion	mDNSEmbeddedAPI.h	1060;"	d
packedunion	mDNSEmbeddedAPI.h	1063;"	d
padding	mDNSEmbeddedAPI.h	/^	mDNSu16    padding;		\/\/ So that RDataBody is aligned on 32-bit boundary$/;"	m	struct:__anon37
padding	mDNSEmbeddedAPI.h	/^	mDNSu16    padding;		\/\/ So that data is aligned on 32-bit boundary$/;"	m	struct:__anon38
parentNATInfo	mDNSEmbeddedAPI.h	/^	NATTraversalInfo *parentNATInfo;	\/\/ pointer back to the parent NATTraversalInfo$/;"	m	struct:tcpLNTInfo_struct
parselog	parselog.py	/^def parselog(inFile):$/;"	f
password	mDNSEmbeddedAPI.h	/^	mDNSOpaque48 password;	\/\/ Optional password$/;"	m	struct:__anon33
penaltyTime	mDNSEmbeddedAPI.h	/^	mDNSs32			penaltyTime; \/\/ amount of time this server is penalized			$/;"	m	struct:DNSServer
pi	parselog.py	/^import math   # for pi$/;"	i
pkts	NetMonitor.c	/^	unsigned long pkts[HostPkt_NumTypes];$/;"	m	struct:__anon6	file:
plen_to_mask	mDNSUNP.c	/^void plen_to_mask(int plen, char *addr) {$/;"	f
port	DNSCommon.c	/^	mDNSIPPort port; \/\/ MUST BE FIRST FIELD -- mDNSCoreReceive expects every UDPSocket_struct to begin with mDNSIPPort port$/;"	m	struct:UDPSocket_struct	file:
port	mDNS.c	/^	mDNSIPPort port; \/\/ MUST BE FIRST FIELD -- mDNSCoreReceive expects every UDPSocket_struct to begin with mDNSIPPort port$/;"	m	struct:UDPSocket_struct	file:
port	mDNSEmbeddedAPI.h	/^	mDNSIPPort      port;				\/\/ Port where this service can be accessed$/;"	m	struct:__anon53
port	mDNSEmbeddedAPI.h	/^	mDNSIPPort      port;$/;"	m	struct:DNSServer
precision	DNSCommon.c	/^	unsigned int  precision;$/;"	m	struct:mDNSprintf_format	file:
printed	NetMonitor.c	/^	int printed;$/;"	m	struct:ActivityStat_struct	file:
printstats	NetMonitor.c	/^mDNSlocal void printstats(int max)$/;"	f
process_config_line	nss_mdns.c	/^process_config_line ($/;"	f	file:
putDeleteAllRRSets	DNSCommon.c	/^mDNSexport mDNSu8 *putDeleteAllRRSets(DNSMessage *msg, mDNSu8 *ptr, const domainname *name)$/;"	f
putDeleteRRSet	DNSCommon.c	/^mDNSexport mDNSu8 *putDeleteRRSet(DNSMessage *msg, mDNSu8 *ptr, const domainname *name, mDNSu16 rrtype)$/;"	f
putDeletionRecord	DNSCommon.c	/^mDNSexport mDNSu8 *putDeletionRecord(DNSMessage *msg, mDNSu8 *ptr, ResourceRecord *rr)$/;"	f
putDomainNameAsLabels	DNSCommon.c	/^mDNSexport mDNSu8 *putDomainNameAsLabels(const DNSMessage *const msg,$/;"	f
putEmptyResourceRecord	DNSCommon.c	/^mDNSlocal mDNSu8 *putEmptyResourceRecord(DNSMessage *const msg, mDNSu8 *ptr, const mDNSu8 *const limit, mDNSu16 *count, const AuthRecord *rr)$/;"	f
putHINFO	DNSCommon.c	/^mDNSexport mDNSu8 *putHINFO(const mDNS *const m, DNSMessage *const msg, mDNSu8 *end, DomainAuthInfo *authInfo)$/;"	f
putLLQ	uDNS.c	/^mDNSlocal mDNSu8 *putLLQ(DNSMessage *const msg, mDNSu8 *ptr, const DNSQuestion *const question, const LLQOptData *const data)$/;"	f
putPrereqNameNotInUse	DNSCommon.c	/^mDNSexport mDNSu8 *putPrereqNameNotInUse(const domainname *const name, DNSMessage *const msg, mDNSu8 *const ptr, mDNSu8 *const end)$/;"	f
putQuestion	DNSCommon.c	/^mDNSexport mDNSu8 *putQuestion(DNSMessage *const msg, mDNSu8 *ptr, const mDNSu8 *const limit, const domainname *const name, mDNSu16 rrtype, mDNSu16 rrclass)$/;"	f
putRData	DNSCommon.c	/^mDNSexport mDNSu8 *putRData(const DNSMessage *const msg, mDNSu8 *ptr, const mDNSu8 *const limit, const ResourceRecord *const rr)$/;"	f
putUpdateLease	DNSCommon.c	/^mDNSexport mDNSu8 *putUpdateLease(DNSMessage *msg, mDNSu8 *end, mDNSu32 lease)$/;"	f
putVal16	DNSCommon.c	/^mDNSlocal mDNSu8 *putVal16(mDNSu8 *ptr, mDNSu16 val)$/;"	f
putVal32	DNSCommon.c	/^mDNSlocal mDNSu8 *putVal32(mDNSu8 *ptr, mDNSu32 val)$/;"	f
putZone	DNSCommon.c	/^mDNSexport mDNSu8 *putZone(DNSMessage *const msg, mDNSu8 *ptr, mDNSu8 *limit, const domainname *zone, mDNSOpaque16 zoneClass)$/;"	f
px	mDNSEmbeddedAPI.h	/^	rdataPX     px;			\/\/ This is large; not included in the normal RDataBody definition$/;"	m	union:__anon36
q	mDNSEmbeddedAPI.h	/^	DNSQuestion q;$/;"	m	struct:ClientTunnel
qAv4	mDNSEmbeddedAPI.h	/^	DNSQuestion                   qAv4;$/;"	m	struct:ServiceInfoQuery_struct
qAv6	mDNSEmbeddedAPI.h	/^	DNSQuestion                   qAv6;$/;"	m	struct:ServiceInfoQuery_struct
qDNSServer	mDNSEmbeddedAPI.h	/^	DNSServer            *qDNSServer;		\/\/ Caching server for this query (in the absence of an SRV saying otherwise)$/;"	m	struct:DNSQuestion_struct
qSRV	mDNSEmbeddedAPI.h	/^	DNSQuestion                   qSRV;$/;"	m	struct:ServiceInfoQuery_struct
qTXT	mDNSEmbeddedAPI.h	/^	DNSQuestion                   qTXT;$/;"	m	struct:ServiceInfoQuery_struct
qclass	mDNSEmbeddedAPI.h	/^	mDNSu16               qclass;$/;"	m	struct:DNSQuestion_struct
qname	mDNSEmbeddedAPI.h	/^	domainname            qname;$/;"	m	struct:DNSQuestion_struct
qnamehash	mDNSEmbeddedAPI.h	/^	mDNSu32               qnamehash;$/;"	m	struct:DNSQuestion_struct
qtype	mDNSEmbeddedAPI.h	/^	mDNSu16               qtype;$/;"	m	struct:DNSQuestion_struct
question	mDNSEmbeddedAPI.h	/^	DNSQuestion      *question;   \/\/ For queries$/;"	m	struct:tcpInfo_t
question	mDNSEmbeddedAPI.h	/^	DNSQuestion      question;			\/\/ Storage for any active question$/;"	m	struct:ZoneData_struct
r	mDNSEmbeddedAPI.h	/^	AuthRecord r;$/;"	m	struct:ExtraResourceRecord_struct
r	mDNSEmbeddedAPI.h	/^	CacheRecord r;$/;"	m	struct:__anon45
r_errno	nss_mdns.c	/^	int r_errno;$/;"	m	struct:result_map	file:
r_h_errno	nss_mdns.c	/^	int r_h_errno;$/;"	m	struct:result_map	file:
rdata	mDNSEmbeddedAPI.h	/^	RData           *rdata;				\/\/ Pointer to storage for this rdata$/;"	m	struct:__anon42
rdataNSEC	mDNSEmbeddedAPI.h	/^	} rdataNSEC;$/;"	t	typeref:struct:__anon34
rdatahash	mDNSEmbeddedAPI.h	/^	mDNSu32          rdatahash;			\/\/ For rdata containing domain name (e.g. PTR, SRV, CNAME etc.), case-insensitive name hash$/;"	m	struct:__anon42
rdatastorage	mDNSEmbeddedAPI.h	/^	RData           rdatastorage;		\/\/ Normally the storage is right here, except for oversized records$/;"	m	struct:AuthRecord_struct
rdestimate	mDNSEmbeddedAPI.h	/^	mDNSu16          rdestimate;		\/\/ Upper bound on on-the-wire size of rdata after name compression$/;"	m	struct:__anon42
rdlength	mDNSEmbeddedAPI.h	/^	mDNSu16          rdlength;			\/\/ Size of the raw rdata, in bytes, in the on-the-wire format$/;"	m	struct:__anon42
re	parselog.py	/^import re$/;"	i
rec	mDNSEmbeddedAPI.h	/^	LargeCacheRecord  rec;                  \/\/ Resource Record extracted from received message$/;"	m	struct:mDNS_struct
recordstat	NetMonitor.c	/^mDNSlocal void recordstat(HostEntry *entry, const domainname *fqdn, int op, mDNSu16 rrtype)$/;"	f
recvSetupResponse	uDNS.c	/^mDNSlocal void recvSetupResponse(mDNS *const m, mDNSu8 rcode, DNSQuestion *const q, const LLQOptData *const llq)$/;"	f
recvfrom_flags	mDNSUNP.c	/^recvfrom_flags(int fd, void *ptr, size_t nbytes, int *flagsp,$/;"	f
regState_DeregDeferred	mDNSEmbeddedAPI.h	/^	regState_DeregDeferred     = 5,     \/\/ dereg requested while in Pending state - send dereg AFTER registration is confirmed$/;"	e	enum:__anon43
regState_DeregPending	mDNSEmbeddedAPI.h	/^	regState_DeregPending      = 4,     \/\/ dereg sent, reply not received$/;"	e	enum:__anon43
regState_ExtraQueued	mDNSEmbeddedAPI.h	/^	regState_ExtraQueued       = 13,    \/\/ extra record to be registered upon completion of service registration (RecordRegistrations only)$/;"	e	enum:__anon43
regState_FetchingZoneData	mDNSEmbeddedAPI.h	/^	regState_FetchingZoneData  = 1,     \/\/ getting info - update not sent$/;"	e	enum:__anon43
regState_NATError	mDNSEmbeddedAPI.h	/^	regState_NATError          = 14     \/\/ unable to complete NAT traversal$/;"	e	enum:__anon43
regState_NATMap	mDNSEmbeddedAPI.h	/^	regState_NATMap            = 10,    \/\/ establishing NAT port mapping (service registrations only)$/;"	e	enum:__anon43
regState_NoTarget	mDNSEmbeddedAPI.h	/^	regState_NoTarget          = 12,    \/\/ service registration pending registration of hostname (ServiceRegistrations only)$/;"	e	enum:__anon43
regState_Pending	mDNSEmbeddedAPI.h	/^	regState_Pending           = 2,     \/\/ update sent, reply not received$/;"	e	enum:__anon43
regState_Refresh	mDNSEmbeddedAPI.h	/^	regState_Refresh           = 9,     \/\/ outstanding refresh (or target change) message$/;"	e	enum:__anon43
regState_Registered	mDNSEmbeddedAPI.h	/^	regState_Registered        = 3,     \/\/ update sent, reply received$/;"	e	enum:__anon43
regState_Unregistered	mDNSEmbeddedAPI.h	/^	regState_Unregistered      = 8,     \/\/ not in any list$/;"	e	enum:__anon43
regState_UpdatePending	mDNSEmbeddedAPI.h	/^	regState_UpdatePending     = 11,    \/\/ update in flight as result of mDNS_Update call$/;"	e	enum:__anon43
regState_Zero	mDNSEmbeddedAPI.h	/^	regState_Zero              = 0,$/;"	e	enum:__anon43
regState_t	mDNSEmbeddedAPI.h	/^	} regState_t;$/;"	t	typeref:enum:__anon43
reply	mDNSEmbeddedAPI.h	/^	DNSMessage       *reply;$/;"	m	struct:tcpInfo_t
replyLen	mDNSEmbeddedAPI.h	/^	int               replyLen;$/;"	m	struct:tcpLNTInfo_struct
replylen	mDNSEmbeddedAPI.h	/^	mDNSu16           replylen;$/;"	m	struct:tcpInfo_t
request	mDNSEmbeddedAPI.h	/^	DNSMessage        request;$/;"	m	struct:tcpInfo_t
requestLen	mDNSEmbeddedAPI.h	/^	int               requestLen;$/;"	m	struct:tcpInfo_t
requestLen	mDNSEmbeddedAPI.h	/^	int               requestLen;$/;"	m	struct:tcpLNTInfo_struct
resrec	mDNSEmbeddedAPI.h	/^	ResourceRecord  resrec;				\/\/ 36 bytes when compiling for 32-bit; 48 when compiling for 64-bit$/;"	m	struct:AuthRecord_struct
resrec	mDNSEmbeddedAPI.h	/^	ResourceRecord  resrec;				\/\/ 36 bytes when compiling for 32-bit; 48 when compiling for 64-bit$/;"	m	struct:CacheRecord_struct
result_map	nss_mdns.c	/^typedef struct result_map$/;"	s	file:
result_map_t	nss_mdns.c	/^} result_map_t;$/;"	t	typeref:struct:result_map	file:
retries	mDNSEmbeddedAPI.h	/^	int               retries;			\/\/ number of times we've tried to do this port mapping$/;"	m	struct:tcpLNTInfo_struct
retryGetAddr	mDNSEmbeddedAPI.h	/^	mDNSs32           retryGetAddr;				\/\/ absolute time when we retry$/;"	m	struct:mDNS_struct
retryInterval	mDNSEmbeddedAPI.h	/^	mDNSs32                     retryInterval;		\/\/ Current interval, between last packet we sent and the next one$/;"	m	struct:NATTraversalInfo_struct
retryIntervalGetAddr	mDNSEmbeddedAPI.h	/^	mDNSs32           retryIntervalGetAddr;		\/\/ delta between time sent and retry$/;"	m	struct:mDNS_struct
retryPortMap	mDNSEmbeddedAPI.h	/^	mDNSs32                     retryPortMap;		\/\/ If Protocol is nonzero, time to send our next mapping packet$/;"	m	struct:NATTraversalInfo_struct
revname	NetMonitor.c	/^	domainname revname;$/;"	m	struct:__anon6	file:
rmt_inner	mDNSEmbeddedAPI.h	/^	mDNSv6Addr rmt_inner;$/;"	m	struct:ClientTunnel
rmt_outer	mDNSEmbeddedAPI.h	/^	mDNSv4Addr rmt_outer;$/;"	m	struct:ClientTunnel
rmt_outer_port	mDNSEmbeddedAPI.h	/^	mDNSIPPort rmt_outer_port;$/;"	m	struct:ClientTunnel
rp	mDNSEmbeddedAPI.h	/^	rdataRP     rp;			\/\/ This is large; not included in the normal RDataBody definition$/;"	m	union:__anon36
rr	mDNSEmbeddedAPI.h	/^	AuthRecord       *rr;         \/\/ For record updates$/;"	m	struct:tcpInfo_t
rr_to_af	nss_mdns.c	/^rr_to_af (ns_type_t rrtype)$/;"	f
rrcache_active	mDNSEmbeddedAPI.h	/^	mDNSu32 rrcache_active;				\/\/ Number of cache entries currently occupied by records that answer active questions$/;"	m	struct:mDNS_struct
rrcache_free	mDNSEmbeddedAPI.h	/^	CacheEntity *rrcache_free;$/;"	m	struct:mDNS_struct
rrcache_hash	mDNSEmbeddedAPI.h	/^	CacheGroup *rrcache_hash[CACHE_HASH_SLOTS];$/;"	m	struct:mDNS_struct
rrcache_report	mDNSEmbeddedAPI.h	/^	mDNSu32 rrcache_report;$/;"	m	struct:mDNS_struct
rrcache_size	mDNSEmbeddedAPI.h	/^	mDNSu32 rrcache_size;				\/\/ Total number of available cache entries$/;"	m	struct:mDNS_struct
rrcache_tail	mDNSEmbeddedAPI.h	/^	CacheRecord   **rrcache_tail;		\/\/ Tail end of that list$/;"	m	struct:CacheGroup_struct
rrcache_totalused	mDNSEmbeddedAPI.h	/^	mDNSu32 rrcache_totalused;			\/\/ Number of cache entries currently occupied$/;"	m	struct:mDNS_struct
rrclass	mDNSEmbeddedAPI.h	/^	mDNSu16          rrclass;$/;"	m	struct:__anon42
rroriginalttl	mDNSEmbeddedAPI.h	/^	mDNSu32          rroriginalttl;		\/\/ In seconds$/;"	m	struct:__anon42
rrtype	mDNSEmbeddedAPI.h	/^	mDNSu16          rrtype;$/;"	m	struct:__anon42
sendChallengeResponse	uDNS.c	/^mDNSlocal void sendChallengeResponse(mDNS *const m, DNSQuestion *const q, const LLQOptData *llq)$/;"	f
sendLLQRefresh	uDNS.c	/^mDNSexport void sendLLQRefresh(mDNS *m, DNSQuestion *q)$/;"	f
seq	mDNSEmbeddedAPI.h	/^	mDNSs8       seq;		\/\/ Sleep\/wake epoch$/;"	m	struct:__anon33
servAddr	mDNSEmbeddedAPI.h	/^	mDNSAddr              servAddr;			\/\/ Address and port learned from _dns-llq, _dns-llq-tls or _dns-query-tls SRV query$/;"	m	struct:DNSQuestion_struct
servPort	mDNSEmbeddedAPI.h	/^	mDNSIPPort            servPort;$/;"	m	struct:DNSQuestion_struct
serviceID	Responder.c	/^    int serviceID;$/;"	m	struct:PosixService	file:
set_err	nss_mdns.c	/^set_err (result_map_t * result, nss_status status, int err, int herr)$/;"	f	file:
set_err_bad_hostname	nss_mdns.c	/^set_err_bad_hostname (result_map_t * result)$/;"	f	file:
set_err_buf_too_small	nss_mdns.c	/^set_err_buf_too_small (result_map_t * result)$/;"	f	file:
set_err_internal_resource_full	nss_mdns.c	/^set_err_internal_resource_full (result_map_t * result)$/;"	f	file:
set_err_mdns_failed	nss_mdns.c	/^set_err_mdns_failed (result_map_t * result)$/;"	f	file:
set_err_notfound	nss_mdns.c	/^set_err_notfound (result_map_t * result)$/;"	f	file:
set_err_success	nss_mdns.c	/^set_err_success (result_map_t * result)$/;"	f	file:
set_err_system	nss_mdns.c	/^set_err_system (result_map_t * result)$/;"	f	file:
setlinebuf	NetMonitor.c	/^void setlinebuf( FILE * fp ) {}$/;"	f
sign	DNSCommon.c	/^	char          sign;		\/\/ +, - or space$/;"	m	struct:mDNSprintf_format	file:
simple_table_index	nss_mdns.c	/^simple_table_index (const char * table [], int size, const char * str)$/;"	f	file:
sizecheck_AuthRecord	mDNSEmbeddedAPI.h	/^	char sizecheck_AuthRecord          [(sizeof(AuthRecord)           <=  1000) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_CacheGroup	mDNSEmbeddedAPI.h	/^	char sizecheck_CacheGroup          [(sizeof(CacheGroup)           <=   176) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_CacheRecord	mDNSEmbeddedAPI.h	/^	char sizecheck_CacheRecord         [(sizeof(CacheRecord)          <=   176) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_ClientTunnel	mDNSEmbeddedAPI.h	/^	char sizecheck_ClientTunnel        [(sizeof(ClientTunnel)         <=  1072) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_DNSQuestion	mDNSEmbeddedAPI.h	/^	char sizecheck_DNSQuestion         [(sizeof(DNSQuestion)          <=   728) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_DNSServer	mDNSEmbeddedAPI.h	/^	char sizecheck_DNSServer           [(sizeof(DNSServer)            <=   312) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_DomainAuthInfo	mDNSEmbeddedAPI.h	/^	char sizecheck_DomainAuthInfo      [(sizeof(DomainAuthInfo)       <=  5500) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_HostnameInfo	mDNSEmbeddedAPI.h	/^	char sizecheck_HostnameInfo        [(sizeof(HostnameInfo)         <=  2800) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_NATTraversalInfo	mDNSEmbeddedAPI.h	/^	char sizecheck_NATTraversalInfo    [(sizeof(NATTraversalInfo)     <=   192) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_NetworkInterfaceInfo	mDNSEmbeddedAPI.h	/^	char sizecheck_NetworkInterfaceInfo[(sizeof(NetworkInterfaceInfo) <=  5968) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_RDataBody	mDNSEmbeddedAPI.h	/^	char sizecheck_RDataBody           [(sizeof(RDataBody)            ==   264) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_ResourceRecord	mDNSEmbeddedAPI.h	/^	char sizecheck_ResourceRecord      [(sizeof(ResourceRecord)       <=    56) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_SearchListElem	uDNS.c	/^	char sizecheck_SearchListElem[(sizeof(SearchListElem) <=  3920) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_uDNS	file:
sizecheck_ServiceInfoQuery	mDNSEmbeddedAPI.h	/^	char sizecheck_ServiceInfoQuery    [(sizeof(ServiceInfoQuery)     <=  2944) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_ServiceRecordSet	mDNSEmbeddedAPI.h	/^	char sizecheck_ServiceRecordSet    [(sizeof(ServiceRecordSet)     <=  5500) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_ZoneData	mDNSEmbeddedAPI.h	/^	char sizecheck_ZoneData            [(sizeof(ZoneData)             <=  1560) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_mDNS
sizecheck_tcpInfo_t	uDNS.c	/^	char sizecheck_tcpInfo_t     [(sizeof(tcpInfo_t)      <=  9056) ? 1 : -1];$/;"	m	struct:CompileTimeAssertionChecks_uDNS	file:
sizeofRDataHeader	mDNSEmbeddedAPI.h	1754;"	d
skipDomainName	DNSCommon.c	/^mDNSexport const mDNSu8 *skipDomainName(const DNSMessage *const msg, const mDNSu8 *ptr, const mDNSu8 *const end)$/;"	f
skipQuestion	DNSCommon.c	/^mDNSexport const mDNSu8 *skipQuestion(const DNSMessage *msg, const mDNSu8 *ptr, const mDNSu8 *end)$/;"	f
skipResourceRecord	DNSCommon.c	/^mDNSexport const mDNSu8 *skipResourceRecord(const DNSMessage *msg, const mDNSu8 *ptr, const mDNSu8 *end)$/;"	f
smallrdatastorage	mDNSEmbeddedAPI.h	/^	RData_small     smallrdatastorage;	\/\/ Storage for small records is right here (4 bytes header + 68 bytes data = 72 bytes)$/;"	m	struct:CacheRecord_struct
soa	mDNSEmbeddedAPI.h	/^	rdataSOA    soa;		\/\/ This is large; not included in the normal RDataBody definition$/;"	m	union:__anon36
sock	mDNSEmbeddedAPI.h	/^	TCPSocket        *sock;$/;"	m	struct:tcpInfo_t
sock	mDNSEmbeddedAPI.h	/^	TCPSocket        *sock;$/;"	m	struct:tcpLNTInfo_struct
sockaddr_storage	mDNSUNP.h	106;"	d
sockaddr_storage	mDNSUNP.h	108;"	d
socklen_t	PlatformCommon.c	/^    typedef unsigned int socklen_t;$/;"	t	file:
socklen_t	mDNSUNP.h	/^    typedef unsigned int socklen_t;$/;"	t
software	Identify.c	/^static char hostname[MAX_ESCAPED_DOMAIN_NAME], hardware[256], software[256];$/;"	v	file:
srs	mDNSEmbeddedAPI.h	/^	ServiceRecordSet *srs;        \/\/ For service record updates$/;"	m	struct:tcpInfo_t
srs_nta	mDNSEmbeddedAPI.h	/^	ZoneData         *srs_nta;$/;"	m	struct:ServiceRecordSet_struct
srs_uselease	mDNSEmbeddedAPI.h	/^	mDNSBool          srs_uselease;				\/\/ dynamic update contains (should contain) lease option$/;"	m	struct:ServiceRecordSet_struct
srv	mDNSEmbeddedAPI.h	/^	rdataSRV    srv;$/;"	m	union:__anon35
srv	mDNSEmbeddedAPI.h	/^	rdataSRV    srv;$/;"	m	union:__anon36
srvtype	NetMonitor.c	/^	domainname srvtype;$/;"	m	struct:ActivityStat_struct	file:
startLLQHandshake	uDNS.c	/^mDNSexport void startLLQHandshake(mDNS *m, DNSQuestion *q)$/;"	f
stat	NetMonitor.c	/^	int stat[OP_NumTypes];$/;"	m	struct:ActivityStat_struct	file:
stat	NetMonitor.c	/^	unsigned long stat[OP_NumTypes];$/;"	m	struct:__anon6	file:
state	mDNSEmbeddedAPI.h	/^	LLQ_State             state;$/;"	m	struct:DNSQuestion_struct
state	mDNSEmbeddedAPI.h	/^	regState_t        state;$/;"	m	struct:ServiceRecordSet_struct
state	mDNSEmbeddedAPI.h	/^	regState_t   state;			\/\/ Maybe combine this with resrec.RecordType state? Right now it's ambiguous and confusing.$/;"	m	struct:AuthRecord_struct
stats	NetMonitor.c	/^static ActivityStat *stats;$/;"	v	file:
status	nss_mdns.c	/^	nss_status status;$/;"	m	struct:result_map	file:
str_to_af	nss_mdns.c	/^str_to_af (const char * str)$/;"	f
str_to_ns_class	nss_mdns.c	/^str_to_ns_class (const char * str)$/;"	f
str_to_ns_type	nss_mdns.c	/^str_to_ns_type (const char * str)$/;"	f
string	parselog.py	/^import string$/;"	i
sys	parselog.py	/^import sys, os$/;"	i
table_entry_t	nss_mdns.c	/^} table_entry_t;$/;"	t	typeref:struct:__anon14	file:
table_index_name	nss_mdns.c	/^table_index_name (const table_entry_t table [], int size, const char * str)$/;"	f	file:
table_index_value	nss_mdns.c	/^table_index_value (const table_entry_t table [], int size, int n)$/;"	f	file:
target	Identify.c	/^static mDNSAddr lastsrc, hostaddr, target;$/;"	v	file:
tcp	mDNSEmbeddedAPI.h	/^	struct tcpInfo_t *tcp;$/;"	m	struct:AuthRecord_struct	typeref:struct:AuthRecord_struct::tcpInfo_t
tcp	mDNSEmbeddedAPI.h	/^	struct tcpInfo_t *tcp;$/;"	m	struct:DNSQuestion_struct	typeref:struct:DNSQuestion_struct::tcpInfo_t
tcp	mDNSEmbeddedAPI.h	/^	struct tcpInfo_t *tcp;$/;"	m	struct:ServiceRecordSet_struct	typeref:struct:ServiceRecordSet_struct::tcpInfo_t
tcpAddrInfo	mDNSEmbeddedAPI.h	/^	tcpLNTInfo        tcpAddrInfo;				\/\/ legacy NAT traversal TCP connection info for external address$/;"	m	struct:mDNS_struct
tcpCallback	uDNS.c	/^mDNSlocal void tcpCallback(TCPSocket *sock, void *context, mDNSBool ConnectionEstablished, mStatus err)$/;"	f
tcpDeviceInfo	mDNSEmbeddedAPI.h	/^	tcpLNTInfo        tcpDeviceInfo;			\/\/ legacy NAT traversal TCP connection info for device info$/;"	m	struct:mDNS_struct
tcpInfo	mDNSEmbeddedAPI.h	/^	tcpLNTInfo                  tcpInfo;			\/\/ Legacy NAT traversal (UPnP) TCP connection$/;"	m	struct:NATTraversalInfo_struct
tcpInfoUnmapList	mDNSEmbeddedAPI.h	/^	tcpLNTInfo       *tcpInfoUnmapList;			\/\/ list of pending unmap requests$/;"	m	struct:mDNS_struct
tcpInfo_t	mDNSEmbeddedAPI.h	/^	} tcpInfo_t;$/;"	t	typeref:struct:tcpInfo_t
tcpInfo_t	mDNSEmbeddedAPI.h	/^typedef struct tcpInfo_t$/;"	s
tcpLNTInfo	mDNSEmbeddedAPI.h	/^typedef struct tcpLNTInfo_struct tcpLNTInfo;$/;"	t	typeref:struct:tcpLNTInfo_struct
tcpLNTInfo_struct	mDNSEmbeddedAPI.h	/^struct tcpLNTInfo_struct$/;"	s
testid	mDNSEmbeddedAPI.h	/^	mDNSOpaque16    testid;$/;"	m	struct:DNSServer
teststate	mDNSEmbeddedAPI.h	/^	mDNSu32         teststate;	\/\/ Have we sent bug-detection query to this server?$/;"	m	struct:DNSServer
timenow	mDNSEmbeddedAPI.h	/^	mDNSs32  timenow;					\/\/ The time that this particular activation of the mDNS code started$/;"	m	struct:mDNS_struct
timenow_adjust	mDNSEmbeddedAPI.h	/^	mDNSs32  timenow_adjust;			\/\/ Correction applied if we ever discover time went backwards$/;"	m	struct:mDNS_struct
timenow_last	mDNSEmbeddedAPI.h	/^	mDNSs32  timenow_last;				\/\/ The time the last time we ran$/;"	m	struct:mDNS_struct
totalops	NetMonitor.c	/^	int totalops;$/;"	m	struct:ActivityStat_struct	file:
totalops	NetMonitor.c	/^	unsigned long totalops;$/;"	m	struct:__anon6	file:
tv_end	NetMonitor.c	/^struct timeval tv_start, tv_end, tv_interval;$/;"	v	typeref:struct:
tv_interval	NetMonitor.c	/^struct timeval tv_start, tv_end, tv_interval;$/;"	v	typeref:struct:
tv_start	NetMonitor.c	/^struct timeval tv_start, tv_end, tv_interval;$/;"	v	typeref:struct:timeval
txt	mDNSEmbeddedAPI.h	/^	UTF8str255  txt;$/;"	m	union:__anon35
txt	mDNSEmbeddedAPI.h	/^	UTF8str255  txt;$/;"	m	union:__anon36
type	mDNSEmbeddedAPI.h	/^	mDNSs32 type;$/;"	m	struct:__anon24
u	mDNSEmbeddedAPI.h	/^	RDataBody  u;$/;"	m	struct:__anon37
uDNS_CheckCurrentQuestion	uDNS.c	/^mDNSexport void uDNS_CheckCurrentQuestion(mDNS *const m)$/;"	f
uDNS_DeregisterRecord	uDNS.c	/^mDNSexport mStatus uDNS_DeregisterRecord(mDNS *const m, AuthRecord *const rr)$/;"	f
uDNS_DeregisterService	uDNS.c	/^mDNSexport mStatus uDNS_DeregisterService(mDNS *const m, ServiceRecordSet *srs)$/;"	f
uDNS_Execute	uDNS.c	/^mDNSexport void uDNS_Execute(mDNS *const m)$/;"	f
uDNS_IsActiveQuery	mDNS.c	1573;"	d	file:
uDNS_LLQType	uDNS.h	/^	} uDNS_LLQType;$/;"	t	typeref:enum:__anon2
uDNS_LLQ_Entire	uDNS.h	/^	uDNS_LLQ_Entire,	\/\/ LLQ initial set of answers: Flush any stale records from cache, but assume TTL is 2 x LLQ refresh interval$/;"	e	enum:__anon2
uDNS_LLQ_Events	uDNS.h	/^	uDNS_LLQ_Events		\/\/ LLQ event packet: don't flush cache; assume TTL is 2 x LLQ refresh interval$/;"	e	enum:__anon2
uDNS_LLQ_Ignore	uDNS.h	/^	uDNS_LLQ_Ignore,	\/\/ LLQ initial challenge packet: ignore -- has no useful records for us$/;"	e	enum:__anon2
uDNS_LLQ_Not	uDNS.h	/^	uDNS_LLQ_Not = 0,	\/\/ Normal uDNS answer: Flush any stale records from cache, and respect record TTL$/;"	e	enum:__anon2
uDNS_ReceiveMsg	uDNS.c	/^mDNSexport void uDNS_ReceiveMsg(mDNS *const m, DNSMessage *const msg, const mDNSu8 *const end, const mDNSAddr *const srcaddr, const mDNSIPPort srcport)$/;"	f
uDNS_ReceiveNATPMPPacket	uDNS.c	/^mDNSexport void uDNS_ReceiveNATPMPPacket(mDNS *m, const mDNSInterfaceID InterfaceID, mDNSu8 *pkt, mDNSu16 len)$/;"	f
uDNS_ReceiveTestQuestionResponse	uDNS.c	/^mDNSlocal mDNSBool uDNS_ReceiveTestQuestionResponse(mDNS *const m, DNSMessage *const msg, const mDNSu8 *const end,$/;"	f
uDNS_RegisterSearchDomains	uDNS.c	/^mDNSexport mStatus uDNS_RegisterSearchDomains(mDNS *const m)$/;"	f
uDNS_RegisterService	mDNS.c	/^mDNSlocal mStatus uDNS_RegisterService(mDNS *const m, ServiceRecordSet *srs)$/;"	f
uDNS_SERVERS_FILE	mDNSPosix.h	122;"	d
uDNS_SendNATMsg	uDNS.c	/^mDNSlocal mStatus uDNS_SendNATMsg(mDNS *m, NATTraversalInfo *info)$/;"	f
uDNS_SetupDNSConfig	mDNS.c	/^mDNSexport mStatus uDNS_SetupDNSConfig(mDNS *const m)$/;"	f
uDNS_UpdateRecord	uDNS.c	/^mDNSexport mStatus uDNS_UpdateRecord(mDNS *m, AuthRecord *rr)$/;"	f
uDNS_next	mDNSEmbeddedAPI.h	/^	ServiceRecordSet *uDNS_next;$/;"	m	struct:ServiceRecordSet_struct
uDNS_recvLLQResponse	uDNS.c	/^mDNSexport uDNS_LLQType uDNS_recvLLQResponse(mDNS *const m, const DNSMessage *const msg, const mDNSu8 *const end, const mDNSAddr *const srcaddr, const mDNSIPPort srcport)$/;"	f
uQueryFlags	DNSCommon.c	/^mDNSexport const mDNSOpaque16 uQueryFlags     = { { kDNSFlag0_QR_Query    | kDNSFlag0_OP_StdQuery | kDNSFlag0_RD, 0 } };$/;"	v
udns_validatelists	uDNS.c	/^mDNSexport void udns_validatelists(void *const v)$/;"	f
udsSupportAddFDToEventLoop	PosixDaemon.c	/^mStatus udsSupportAddFDToEventLoop(int fd, udsEventCallback callback, void *context)$/;"	f
udsSupportRemoveFDFromEventLoop	PosixDaemon.c	/^mStatus udsSupportRemoveFDFromEventLoop(int fd)		\/\/ Note: This also CLOSES the file descriptor$/;"	f
udsserver_exit	NetMonitor.c	/^mDNSexport int udsserver_exit(void) { return 0; }$/;"	f
udsserver_handle_configchange	NetMonitor.c	/^mDNSexport void udsserver_handle_configchange(mDNS *const m) {}$/;"	f
udsserver_idle	NetMonitor.c	/^mDNSexport mDNSs32 udsserver_idle(mDNSs32 nextevent) { return 0; }$/;"	f
udsserver_init	NetMonitor.c	/^mDNSexport int udsserver_init(dnssd_sock_t skts[], mDNSu32 count) { return 0; }$/;"	f
uid	mDNSEmbeddedAPI.h	/^	mDNSu32 uid;$/;"	m	struct:DNameListElem
uint16_t	dns_sd.h	/^typedef UINT16      uint16_t;$/;"	t
uint32_t	dns_sd.h	/^typedef UINT32      uint32_t;$/;"	t
uint8_t	dns_sd.h	/^typedef UINT8       uint8_t;$/;"	t
unansweredQueries	mDNSEmbeddedAPI.h	/^	mDNSu8                unansweredQueries;\/\/ The number of unanswered queries to this server$/;"	m	struct:DNSQuestion_struct
unicastSocket4	mDNSPosix.h	/^	int unicastSocket4;$/;"	m	struct:mDNS_PlatformSupport_struct
unicastSocket6	mDNSPosix.h	/^	int unicastSocket6;$/;"	m	struct:mDNS_PlatformSupport_struct
unlinkSRS	uDNS.c	/^mDNSlocal void unlinkSRS(mDNS *const m, ServiceRecordSet *srs)$/;"	f
updateid	mDNSEmbeddedAPI.h	/^	mDNSOpaque16 updateid;		\/\/ Identifier to match update request and response -- also used when transferring records to Sleep Proxy$/;"	m	struct:AuthRecord_struct
uselease	mDNSEmbeddedAPI.h	/^	mDNSBool     uselease;		\/\/ dynamic update contains (should contain) lease option$/;"	m	struct:AuthRecord_struct
v4	mDNSEmbeddedAPI.h	/^	union { mDNSv6Addr v6; mDNSv4Addr v4; } ip;$/;"	m	union:__anon24::__anon25
v4Requester	mDNSEmbeddedAPI.h	/^	mDNSv4Addr      v4Requester;		\/\/ Recent v4 query for this record, or all-ones if more than one recent query$/;"	m	struct:AuthRecord_struct
v6	mDNSEmbeddedAPI.h	/^	union { mDNSv6Addr v6; mDNSv4Addr v4; } ip;$/;"	m	union:__anon24::__anon25
v6Requester	mDNSEmbeddedAPI.h	/^	mDNSv6Addr      v6Requester;		\/\/ Recent v6 query for this record, or all-ones if more than one recent query$/;"	m	struct:AuthRecord_struct
va_arg	mDNSEmbeddedAPI.h	1007;"	d
va_end	mDNSEmbeddedAPI.h	1006;"	d
va_list	mDNSEmbeddedAPI.h	1004;"	d
va_start	mDNSEmbeddedAPI.h	1005;"	d
value	nss_mdns.c	/^	int value;$/;"	m	struct:__anon14	file:
verbosedebugf	mDNSDebug.h	278;"	d
verbosedebugf	mDNSDebug.h	281;"	d
verbosedebugf_	mDNSDebug.c	/^mDNSexport void verbosedebugf_(const char *format, ...)$/;"	f
vers	mDNSEmbeddedAPI.h	/^	mDNSu16      vers;$/;"	m	struct:__anon32
vers	mDNSEmbeddedAPI.h	/^	mDNSu8       vers;		\/\/ Version number of this Owner OPT record$/;"	m	struct:__anon33
w	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[ 8]; mDNSu16 w[4]; mDNSu32 l[2]; } mDNSOpaque64;$/;"	m	union:__anon20
w	mDNSEmbeddedAPI.h	/^typedef       union { mDNSu8 b[16]; mDNSu16 w[8]; mDNSu32 l[4]; } mDNSOpaque128;$/;"	m	union:__anon21
zeroAddr	DNSCommon.c	/^mDNSexport const mDNSAddr        zeroAddr          = { mDNSAddrType_None, {{{ 0 }}} };$/;"	v
zeroEthAddr	DNSCommon.c	/^mDNSexport const mDNSEthAddr     zeroEthAddr       = { { 0 } };$/;"	v
zeroID	DNSCommon.c	/^mDNSexport const mDNSOpaque16 zeroID          = { { 0, 0 } };$/;"	v
zeroIPPort	DNSCommon.c	/^mDNSexport const mDNSIPPort      zeroIPPort        = { { 0 } };$/;"	v
zeroOpaque64	DNSCommon.c	/^mDNSexport const mDNSOpaque64 zeroOpaque64    = { { 0 } };$/;"	v
zeroOwner	DNSCommon.c	/^mDNSexport const OwnerOptData    zeroOwner         = { 0, 0, { { 0 } }, { { 0 } }, { { 0 } } };$/;"	v
zeroPad	DNSCommon.c	/^	unsigned      zeroPad : 1;$/;"	m	struct:mDNSprintf_format	file:
zerov4Addr	DNSCommon.c	/^mDNSexport const mDNSv4Addr      zerov4Addr        = { { 0 } };$/;"	v
zerov6Addr	DNSCommon.c	/^mDNSexport const mDNSv6Addr      zerov6Addr        = { { 0 } };$/;"	v
zone	mDNSEmbeddedAPI.h	/^	const domainname *zone;		\/\/ the zone that is updated$/;"	m	struct:AuthRecord_struct
zone	mDNSEmbeddedAPI.h	/^	domainname        zone;						\/\/ the zone that is updated$/;"	m	struct:ServiceRecordSet_struct
